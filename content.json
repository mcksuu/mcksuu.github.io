[{"title":"Android resources.arsc的解析","date":"2017-12-13T15:58:50.547Z","path":"2017/12/13/Android resources.arsc的解析/","text":"&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x4ECE;&#x5199;&#x4E0B;&#x8FD9;&#x4E2A;&#x6807;&#x9898;&#x5F00;&#x59CB;&#xFF0C;&#x6211;&#x5C31;&#x77E5;&#x9053;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#x9700;&#x8981;&#x51E0;&#x5929;&#x7684;&#x65F6;&#x95F4;&#x624D;&#x80FD;&#x771F;&#x6B63;&#x5B8C;&#x6210;&#x3002;&#x5F53;&#x7136;&#x4E0D;&#x662F;&#x56E0;&#x4E3A;&#x4E00;&#x5207;&#x4ECE;&#x96F6;&#x5F00;&#x59CB;&#xFF0C;&#x53EA;&#x662F;&#x56E0;&#x4E3A;&#x8981;&#x6574;&#x7406;&#x7684;&#x4E1C;&#x897F;&#x592A;&#x591A;&#x3002;&#x8BF4;&#x51E0;&#x53E5;&#x9898;&#x5916;&#x8BDD;&#xFF0C;&#x5173;&#x4E8E;&#x4E3A;&#x5565;&#x8981;&#x5199;&#x8FD9;&#x4E2A;resources.arsc&#x6587;&#x4EF6;&#x7684;&#x89E3;&#x6790;&#x3002;&#x672C;&#x6765;&#x554A;&#xFF0C;&#x60F3;&#x6309;&#x7167;&#x6211;&#x4E4B;&#x524D;&#x5199;&#x7684;&#x4E00;&#x6B65;&#x6B65;&#x5199;&#x4E0B;&#x53BB;&#xFF0C;&#x7ED3;&#x679C;&#x4E00;&#x5929;&#x65E0;&#x804A;&#x770B;&#x6587;&#x7AE0;&#xFF0C;&#x53D1;&#x73B0;&#x4E86;&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x7684;&#x89E3;&#x6790;&#x8FC7;&#x7A0B;&#x3002;&#x60F3;&#x8D77;&#x6211;&#x7684;&#x820D;&#x53CB;&#xFF08;&#x6280;&#x672F;&#x5927;&#x4F6C;&#xFF09;&#x5199;&#x8FC7;&#x4E00;&#x7BC7;&#x5173;&#x4E8E;.class&#x6587;&#x4EF6;&#x7684;&#x89E3;&#x6790;&#xFF08;&#x5F88;&#x60ED;&#x6127;&#xFF0C;&#x6211;&#x4E5F;&#x7167;&#x7740;&#x5199;&#x4E86;&#x4E00;&#x904D;&#xFF0C;&#x8FD8;&#x53D1;&#x73B0;&#x4E86;&#x70B9;&#x5C0F;&#x95EE;&#x9898;&#xFF09;&#xFF0C;&#x6240;&#x4EE5;&#x770B;&#x5230;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#x53C8;&#x52FE;&#x8D77;&#x6211;&#x5BF9;&#x4E8C;&#x8FDB;&#x5236;&#x6587;&#x4EF6;&#x89E3;&#x6790;&#x7684;&#x5174;&#x8DA3;&#xFF08;&#x75DB;&#x82E6;&#x554A;&#xFF01;&#xFF01;&#xFF09;&#x3002;&#x5199;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6211;&#x5DF2;&#x7ECF;&#x57FA;&#x672C;&#x5B9E;&#x73B0;&#x4E86;&#x6574;&#x4E2A;&#x89E3;&#x6790;&#x8FC7;&#x7A0B;&#xFF0C;&#x4F46;&#x662F;&#x5176;&#x4E2D;&#x6211;&#x6D4B;&#x8BD5;&#x4E86;&#x4E03;&#x4E2A;&#x4E0D;&#x540C;&#x7684;resources.arsc&#xFF0C;&#x53EA;&#x6709;&#x652F;&#x4ED8;&#x5B9D;&#x7684;&#x89E3;&#x6790;&#x4F1A;&#x6709;&#x95EE;&#x9898;&#xFF0C;wtf&#xFF01;&#xFF01;&#x6CA1;&#x529E;&#x6CD5;&#xFF0C;&#x6700;&#x540E;&#x6253;&#x5F00;&#x4E8C;&#x8FDB;&#x5236;&#x6587;&#x4EF6;&#xFF0C;&#x4E00;&#x70B9;&#x70B9;&#x627E;&#x95EE;&#x9898;&#xFF0C;&#x6700;&#x540E;&#x901A;&#x8FC7;&#x6211;&#x5F3A;&#x5927;&#x7684;&#x586B;&#x5751;&#x6280;&#x672F;&#xFF0C;&#x7EC8;&#x4E8E;&#x5B8C;&#x6210;&#x3002;&#x4E0D;&#x8FC7;&#x5462;&#xFF0C;&#x8FD9;&#x6B21;&#x4E0D;&#x6253;&#x7B97;&#x901A;&#x8FC7;FileInputStream&#x4E00;&#x70B9;&#x70B9;&#x53BB;read&#x5B9E;&#x73B0;&#xFF0C;&#x6211;&#x4F1A;&#x4F7F;&#x7528;ByteArray&#x6765;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x89E3;&#x6790;&#x8FC7;&#x7A0B;&#xFF0C;&#x6574;&#x4E2A;&#x5B9E;&#x73B0;&#x8FC7;&#x7A0B;&#x662F;kotlin&#x8BED;&#x8A00;&#xFF0C;&#x5F88;&#x591A;&#x4E0D;&#x719F;&#x6089;&#x7684;&#x5730;&#x65B9;&#xFF0C;&#x8FD8;&#x6709;&#x5F88;&#x591A;&#x9AD8;&#x7EA7;&#x7528;&#x6CD5;&#x6CA1;&#x6709;&#x4F7F;&#x7528;&#x3002; 1. &#x5173;&#x4E8E;resources.arsc&#x7684;&#x7F51;&#x4F20;&#x795E;&#x56FE; &#x7F51;&#x4E0A;&#x641C;&#x7D22;&#x5173;&#x4E8E;resources.arsc&#x6587;&#x4EF6;&#xFF0C;&#x4E00;&#x822C;&#x4F1A;&#x51FA;&#x73B0;&#x8001;&#x7F57;&#x7684;&#x6253;&#x5305;&#x8FC7;&#x7A0B;&#x4EE5;&#x53CA;&#x5C3C;&#x53E4;&#x62C9;&#x65AF;_&#x8D75;&#x56DB;&#x8FD9;&#x4E24;&#x4F4D;&#x771F;&#x795E;&#x7684;&#x8BB2;&#x89E3;&#x3002;&#x5176;&#x4E2D;&#x8001;&#x7F57;&#x7684;&#x8BB2;&#x89E3;&#x4E2D;&#x51FA;&#x73B0;&#x4E86;&#x4E00;&#x5E45;&#x56FE;&#x7247;&#xFF0C;&#x5173;&#x4E8E;resources.arsc&#x7684;&#x683C;&#x5F0F;&#x3002;&#x56FE;&#x7247;&#x5982;&#x4E0B;&#xFF1A; 2. resources.arsc&#x683C;&#x5F0F;&#x8BE6;&#x7EC6;&#x5206;&#x6790; &#x6309;&#x7167;&#x4E0A;&#x9762;&#x7684;&#x56FE;&#x7247;&#x6765;&#x8BF4;&#xFF0C;&#x6574;&#x4E2A;resources.arsc&#x6587;&#x4EF6;&#x5206;&#x4E3A;&#x4E86;&#x516D;&#x4E2A;&#x90E8;&#x5206;&#xFF08;&#x6682;&#x65F6;&#x6309;&#x7167;&#x989C;&#x8272;&#x5206;&#x5427;&#xFF09;&#xFF0C;&#x8FD9;&#x51E0;&#x4E2A;&#x90E8;&#x5206;&#x53EF;&#x80FD;&#x5C31;&#x662F;&#x4ED6;&#x4EEC;&#x6240;&#x8BF4;&#x7684;chunk&#x628A;&#xFF0C;&#x4ECE;&#x4E0A;&#x5230;&#x4E0B;&#x4F9D;&#x6B21;&#x662F;&#xFF1A; package&#x6570;&#x91CF; String Pool&#xFF0C;&#x5B57;&#x7B26;&#x4E32;&#x6C60; Package &#x4FE1;&#x606F; &#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x548C;&#x8D44;&#x6E90;&#x9879;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32;&#x6C60; &#x7C7B;&#x578B;&#x89C4;&#x8303;&#x6570;&#x636E;&#x5757; &#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x9879;&#x6570;&#x636E;&#x5757; 3. &#x5148;&#x8BF4;&#x8BF4;&#x5934;&#x90E8;&#x4FE1;&#x606F; &#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4ECE;&#x56FE;&#x4E2D;&#x770B;&#x5230;&#xFF0C;&#x6BCF;&#x5757;&#x7ED3;&#x6784;&#x90FD;&#x662F;&#x4EE5;TYPE&#x3001;&#x5934;&#x5927;&#x5C0F;&#x3001;&#x6587;&#x4EF6;&#x5927;&#x5C0F;&#x5F00;&#x5934;&#xFF0C;&#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x7EC4;&#x6210;&#x4E86;&#x5934;&#x90E8;&#x7684;&#x4FE1;&#x606F;&#x6839;&#x636E;ResourceTypes.h&#x7684;&#x8BF4;&#x660E;&#x53EF;&#x4EE5;&#x77E5;&#x9053;&#xFF0C;&#x8FD9;&#x90E8;&#x5206;&#x662F;chunk&#x7684;&#x5934;&#x90E8;&#xFF0C;&#x5148;&#x770B;&#x4E0B;&#x5B9A;&#x4E49;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172ResourceTypes.h &#x5B9A;&#x4E49;/** * Header that appears at the front of every data chunk in a resource. */struct ResChunk_header{ // Type identifier for this chunk. The meaning of this value depends // on the containing chunk. uint16_t type; // Size of the chunk header (in bytes). Adding this value to // the address of the chunk allows you to find its associated data // (if any). uint16_t headerSize; // Total size of this chunk (in bytes). This is the chunkSize plus // the size of any data associated with the chunk. Adding this value // to the chunk allows you to completely skip its contents (including // any child chunks). If this value is the same as chunkSize, there is // no data associated with the chunk. uint32_t size;};ResChunk_header&#x5B9A;&#x4E49;class ResChunk_header(var type: uint16_t, //&#x5F53;&#x524D;&#x8FD9;&#x4E2A;chunk&#x7684;&#x7C7B;&#x578B; var headerSize: uint16_t, //&#x5F53;&#x524D;&#x8FD9;&#x4E2A;chunk&#x7684;&#x5934;&#x90E8;&#x5927;&#x5C0F; var size: uint32_t) { //&#x5F53;&#x524D;&#x8FD9;&#x4E2A;chunk&#x7684;&#x5927;&#x5C0F; //&#x8FD9;&#x5730;&#x65B9;&#x53EF;&#x4EE5;&#x6539;&#x6210;companion object&#xFF0C;&#x61D2;&#x5F97;&#x6539;&#x4E86; enum class ChunkType(var type: Int) { RES_NULL_TYPE(0x0000), RES_STRING_POOL_TYPE(0x0001), RES_TABLE_TYPE(0x0002), RES_XML_TYPE(0x0003), RES_XML_FIRST_CHUNK_TYPE(0x0100), RES_XML_START_NAMESPACE_TYPE(0x0100), RES_XML_END_NAMESPACE_TYPE(0x0101), RES_XML_START_ELEMENT_TYPE(0x0102), RES_XML_END_ELEMENT_TYPE(0x0103), RES_XML_CDATA_TYPE(0x0104), RES_XML_LAST_CHUNK_TYPE(0x017f), RES_XML_RESOURCE_MAP_TYPE(0x0180), RES_TABLE_PACKAGE_TYPE(0x0200), RES_TABLE_TYPE_TYPE(0x0201), RES_TABLE_TYPE_SPEC_TYPE(0x0202) } // &#x8F93;&#x51FA;&#x5934;&#x90E8;&#x4FE1;&#x606F; override fun toString(): String { return &quot;type = ${getType(type)}, typeHexValue = ${type.getHexValue()}, headerSize = ${headerSize.getValue()}, headerHexValue = ${headerSize.getHexValue()}, size = ${size.getValue()}, sizeHexValue = ${size.getHexValue()}&quot; } // &#x83B7;&#x5F97;&#x7C7B;&#x578B; fun getType(type: uint16_t): String { when (type.getValue().toInt()) { ResChunk_header.ChunkType.RES_NULL_TYPE.type -&gt; return &quot;RES_NULL_TYPE&quot; ResChunk_header.ChunkType.RES_STRING_POOL_TYPE.type -&gt; return &quot;RES_STRING_POOL_TYPE&quot; ResChunk_header.ChunkType.RES_TABLE_TYPE.type -&gt; return &quot;RES_TABLE_TYPE&quot; ResChunk_header.ChunkType.RES_XML_TYPE.type -&gt; return &quot;RES_XML_TYPE&quot; ResChunk_header.ChunkType.RES_XML_FIRST_CHUNK_TYPE.type -&gt; return &quot;RES_XML_FIRST_CHUNK_TYPE&quot; ResChunk_header.ChunkType.RES_XML_START_NAMESPACE_TYPE.type -&gt; return &quot;RES_XML_START_NAMESPACE_TYPE&quot; ResChunk_header.ChunkType.RES_XML_END_NAMESPACE_TYPE.type -&gt; return &quot;RES_XML_END_NAMESPACE_TYPE&quot; ResChunk_header.ChunkType.RES_XML_START_ELEMENT_TYPE.type -&gt; return &quot;RES_XML_START_ELEMENT_TYPE&quot; ResChunk_header.ChunkType.RES_XML_END_ELEMENT_TYPE.type -&gt; return &quot;RES_XML_END_ELEMENT_TYPE&quot; ResChunk_header.ChunkType.RES_XML_CDATA_TYPE.type -&gt; return &quot;RES_XML_CDATA_TYPE&quot; ResChunk_header.ChunkType.RES_XML_LAST_CHUNK_TYPE.type -&gt; return &quot;RES_XML_LAST_CHUNK_TYPE&quot; ResChunk_header.ChunkType.RES_XML_RESOURCE_MAP_TYPE.type -&gt; return &quot;RES_XML_RESOURCE_MAP_TYPE&quot; ResChunk_header.ChunkType.RES_TABLE_PACKAGE_TYPE.type -&gt; return &quot;RES_TABLE_PACKAGE_TYPE&quot; ResChunk_header.ChunkType.RES_TABLE_TYPE_TYPE.type -&gt; return &quot;RES_TABLE_TYPE_TYPE&quot; ResChunk_header.ChunkType.RES_TABLE_TYPE_SPEC_TYPE.type -&gt; return &quot;RES_TABLE_TYPE_SPEC_TYPE&quot; } return &quot;&quot; }} &#x4E0A;&#x9762;&#x7684;&#x5B9A;&#x4E49;&#x5C31;&#x662F;&#x5173;&#x4E8E;chunk&#x7684;&#x5934;&#x90E8;&#x4FE1;&#x606F;&#x7684;&#x5B9A;&#x4E49;&#xFF1A; type&#xFF1A;&#x5F53;&#x524D;&#x8FD9;&#x4E2A;chunk&#x7684;&#x7C7B;&#x578B; headerSize&#xFF1A;&#x5F53;&#x524D;&#x8FD9;&#x4E2A;chunk&#x7684;&#x5934;&#x90E8;&#x5927;&#x5C0F; size&#xFF1A;&#x5F53;&#x524D;&#x8FD9;&#x4E2A;chunk&#x7684;&#x5927;&#x5C0F; 4. package&#x6570;&#x91CF;&#x683C;&#x5F0F; ResTable_header&#x662F;&#x5173;&#x4E8E;&#x8FD9;&#x4E2A;&#x683C;&#x5F0F;&#x7684;&#x5B9A;&#x4E49;&#xFF0C;&#x5176;&#x5B9E;&#x91CC;&#x9762;&#x53EA;&#x6709;&#x4E00;&#x4E2A;uint32_t&#x7684;packageCount&#xFF0C;&#x7528;&#x4E8E;&#x5B58;&#x50A8;package&#x7684;&#x6570;&#x91CF;1234567891011121314151617181920212223242526ResourceTypes.h&#x5B9A;&#x4E49;/** * Header for a resource table. Its data contains a series of * additional chunks: * * A ResStringPool_header containing all table values. This string pool * contains all of the string values in the entire resource table (not * the names of entries or type identifiers however). * * One or more ResTable_package chunks. * * Specific entries within a resource table can be uniquely identified * with a single integer as defined by the ResTable_ref structure. */struct ResTable_header{ struct ResChunk_header header; // The number of ResTable_package structures. uint32_t packageCount;};ResTable_header&#x5B9A;&#x4E49;class ResTable_header(var header: ResChunk_header, var packageCount: uint32_t) { override fun toString(): String { return header.toString() + &quot;, packagerCount = ${packageCount.getValue()}, packagerCountHexValue = ${packageCount.getHexValue()}&quot; }} Android&#x4E2D;&#x4E00;&#x4E2A;apk&#x53EF;&#x80FD;&#x5305;&#x542B;&#x591A;&#x4E2A;&#x8D44;&#x6E90;&#x5305;&#xFF0C;&#x9ED8;&#x8BA4;&#x60C5;&#x51B5;&#x4E0B;&#x90FD;&#x53EA;&#x6709;&#x4E00;&#x4E2A;&#x5C31;&#x662F;&#x5E94;&#x7528;&#x7684;&#x5305;&#x540D;&#x6240;&#x5728;&#x7684;&#x8D44;&#x6E90;&#x5305; packageCount&#xFF1A;&#x88AB;&#x7F16;&#x8BD1;&#x7684;&#x8D44;&#x6E90;&#x5305;&#x7684;&#x4E2A;&#x6570;&#x4E0B;&#x56FE;&#x662F;&#x6211;&#x4F7F;&#x7528;&#x7684;arsc&#x6587;&#x4EF6;&#x7684;ResTable_header&#x7684;&#x4FE1;&#x606F;&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x7684;TYPE&#x662F;0x0002&#xFF0C;&#x5BF9;&#x5E94;&#x4E86;RES_TABLE_TYPE&#xFF0C;&#x5E76;&#x4E14;&#x5176;headerSize&#x662F;0x000C&#xFF0C;&#x4E5F;&#x5C31;&#x662F;12&#xFF0C;&#x6574;&#x4E2A;chunk&#x7684;&#x5927;&#x5C0F;&#x662F;377904&#xFF08;0x0005C430&#xFF09;&#xFF0C;packag&#x7684;&#x6570;&#x91CF;&#x662F;1&#xFF08;0x00000001&#xFF09;&#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x603B;&#x4F53;&#x6765;&#x8BF4;&#x89E3;&#x6790;&#x5F88;&#x7B80;&#x5355;&#xFF0C;&#x524D;&#x9762;&#x7684;&#x4E24;&#x4E2A;&#x5B57;&#x8282;&#x5BF9;&#x5E94;&#x4E86;&#x7C7B;&#x578B;&#xFF0C;&#x63A5;&#x7740;&#x4E24;&#x4E2A;&#x5B57;&#x8282;&#x5BF9;&#x5E94;&#x4E86;headerSize&#xFF0C;&#x540E;&#x9762;&#x56DB;&#x4E2A;&#x5B57;&#x8282;&#x5BF9;&#x5E94;&#x4E86;&#x6574;&#x4E2A;&#x5927;&#x5C0F;size&#xFF0C;&#x6700;&#x540E;&#x7684;&#x56DB;&#x4E2A;&#x5B57;&#x8282;&#x5BF9;&#x5E94;&#x4E86;package&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x8FD9;&#x4E2A;&#x6570;&#x91CF;&#x662F;1&#x3002; 5. String Pool &#x5148;&#x770B;&#x4E0B;ResourceTypes.h&#x5BF9;String Pool&#x7684;&#x5B9A;&#x4E49;&#xFF1A;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162ResourceTypes.h&#x5B9A;&#x4E49;struct ResStringPool_header{ struct ResChunk_header header; // Number of strings in this pool (number of uint32_t indices that follow // in the data). uint32_t stringCount; // Number of style span arrays in the pool (number of uint32_t indices // follow the string indices). uint32_t styleCount; // Flags. enum { // If set, the string index is sorted by the string values (based // on strcmp16()). SORTED_FLAG = 1&lt;&lt;0, // String pool is encoded in UTF-8 UTF8_FLAG = 1&lt;&lt;8 }; uint32_t flags; // Index from header of the string data. uint32_t stringsStart; // Index from header of the style data. uint32_t stylesStart;};ResTable_header&#x5B9A;&#x4E49;class ResStringPool_header(var header: ResChunk_header, var stringCount: uint32_t, //&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6570;&#x91CF; var styleCount: uint32_t, //&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x7684;&#x6570;&#x91CF; var flags: uint32_t, //&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x5C5E;&#x6027;,&#x53EF;&#x53D6;&#x503C;&#x5305;&#x62EC;0x000(UTF-16),0x001(&#x5B57;&#x7B26;&#x4E32;&#x7ECF;&#x8FC7;&#x6392;&#x5E8F;)&#x3001;0X100(UTF-8)&#x548C;&#x4ED6;&#x4EEC;&#x7684;&#x7EC4;&#x5408;&#x503C; var stringsStart: uint32_t, //&#x5B57;&#x7B26;&#x4E32;&#x5185;&#x5BB9;&#x5757;&#x76F8;&#x5BF9;&#x4E8E;&#x5176;&#x5934;&#x90E8;&#x7684;&#x8DDD;&#x79BB; var stylesStart: uint32_t, //&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x5757;&#x76F8;&#x5BF9;&#x4E8E;&#x5176;&#x5934;&#x90E8;&#x7684;&#x8DDD;&#x79BB; var stringOffsetArray: ResString_offset_array?,//&#x5B57;&#x7B26;&#x4E32;&#x504F;&#x79FB;&#x6570;&#x7EC4; var styleOffsetArray: ResStyle_offset_array?,//&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x504F;&#x79FB;&#x6570;&#x7EC4; var stringStringArray: ResString_string_array?,//&#x5B57;&#x7B26;&#x4E32;&#x6570;&#x7EC4; var styleStringArray: ResStyle_string_array?//&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x6570;&#x7EC4;) { // Flags. enum class FLAGS(var flag: Int) { // If set, the string index is sorted by the string values (based // on strcmp16()). SORTED_FLAG(1 shl 0), // String pool is encoded in UTF-8 UTF8_FLAG(1 shl 8) } override fun toString(): String { val result = &quot;&quot;&quot;$header, |stringCount = ${stringCount.getValue()}, stringCountHexValue = ${stringCount.getHexValue()}, |styleCount = ${styleCount.getValue()}, styleCountHexValue = ${styleCount.getHexValue()}, |flags = ${flags.getValue()}, flagsHexValue = ${flags.getHexValue()}, |stringsStart = ${stringsStart.getValue()}, stringsStartCountHexValue = ${stringsStart.getHexValue()}, |stylesStart = ${stylesStart.getValue()}, stylesStartHexValue = ${stylesStart.getHexValue()},&quot;&quot;&quot;.trimMargin() return result }} &#x4ECE;&#x5B9A;&#x4E49;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x5185;&#x5BB9;&#x633A;&#x591A;&#xFF1A; header&#xFF1A;&#x5934;&#x90E8;&#x4FE1;&#x606F;&#xFF0C;ResChunk_header&#x683C;&#x5F0F; stringCount&#xFF1A;&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x6570;&#x91CF;&#xFF0C;uint32_t&#x683C;&#x5F0F; styleCount&#xFF1A;&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x7684;&#x6570;&#x91CF;&#xFF0C;uint32_t&#x683C;&#x5F0F; flags&#xFF1A;&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x5C5E;&#x6027;,&#x53EF;&#x53D6;&#x503C;&#x5305;&#x62EC;0x000(UTF-16),0x001(&#x5B57;&#x7B26;&#x4E32;&#x7ECF;&#x8FC7;&#x6392;&#x5E8F;)&#x3001;0X100(UTF-8)&#x548C;&#x4ED6;&#x4EEC;&#x7684;&#x7EC4;&#x5408;&#x503C;&#xFF0C;uint32_t&#x683C;&#x5F0F; stringsStart&#xFF1A;&#x5B57;&#x7B26;&#x4E32;&#x5F00;&#x59CB;&#x4F4D;&#x7F6E;&#xFF0C;&#x76F8;&#x5BF9;&#x4E8E;&#x5934;&#x90E8;&#xFF0C;uint32_t&#x683C;&#x5F0F; stylesStart&#xFF1A;&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x5F00;&#x59CB;&#x4F4D;&#x7F6E;&#xFF0C;&#x76F8;&#x5BF9;&#x4E8E;&#x5934;&#x90E8;&#xFF0C;uint32_t&#x683C;&#x5F0F; &#x56DB;&#x4E2A;&#x6570;&#x7EC4;&#xFF1A;&#x81EA;&#x5DF1;&#x5B9A;&#x4E49;&#xFF0C;&#x7528;&#x4E8E;&#x5B58;&#x50A8;&#x504F;&#x79FB;&#x91CF;&#x4EE5;&#x53CA;string&#x7684;&#x503C;&#x4E0B;&#x56FE;&#x662F;&#x6211;&#x4F7F;&#x7528;&#x7684;arsc&#x6587;&#x4EF6;&#x7684;ResStringPool_header&#x4FE1;&#x606F;&#xFF08;&#x4E0D;&#x5305;&#x62EC;&#x6570;&#x7EC4;&#x5185;&#x5BB9;&#xFF09;&#xFF1A;&#x4ECE;&#x56FE;&#x4E2D;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF1A; headerSize&#x662F;28&#xFF08;0x001c&#xFF09; size&#x662F;142676&#xFF08;0x00022d54&#xFF09; stringCount&#x662F;2882&#xFF08;0x00000b42&#xFF09; styleCount&#x662F;1&#xFF08;0x00000001&#xFF09; flags&#x662F;256&#xFF08;0x00000100&#xFF09;&#x4EE3;&#x8868;&#x4E86;&#x7F16;&#x7801;&#x662F;UTF-8 stringsStart&#x662F;11560&#xFF08;0x00002d28&#xFF09; stylesStart&#x662F;142652&#xFF08;0x00022d3c&#xFF09;&#x4E0A;&#x9762;&#x7684;&#x4FE1;&#x606F;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x63A5;&#x7740;&#x4FBF;&#x662F;&#x4E24;&#x4E2A;&#x504F;&#x79FB;&#x6570;&#x7EC4;&#xFF08;&#x5B57;&#x7B26;&#x4E32;&#x504F;&#x79FB;&#x6570;&#x7EC4;&#x548C;&#x5B57;&#x7B26;&#x4E32;&#x6837;&#x5F0F;&#x504F;&#x79FB;&#x6570;&#x7EC4;&#xFF09;&#xFF0C;&#x504F;&#x79FB;&#x6570;&#x7EC4;&#x7ED3;&#x675F;&#x540E;&#x5C31;&#x662F;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x3002;&#x5B57;&#x7B26;&#x4E32;&#x8D44;&#x6E90;&#x6C60;&#x4E2D;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x524D;&#x4E24;&#x4E2A;&#x5B57;&#x8282;&#x4E3A;&#x5B57;&#x7B26;&#x4E32;&#x957F;&#x5EA6;,&#x957F;&#x5EA6;&#x8BA1;&#x7B97;&#x65B9;&#x6CD5;&#x5982;&#x4E0B;&#x3002;&#x53E6;&#x5916;&#x5982;&#x679C;&#x5B57;&#x7B26;&#x4E32;&#x7F16;&#x7801;&#x683C;&#x5F0F;&#x4E3A;UTF-8&#x5219;&#x5B57;&#x7B26;&#x4E32;&#x4EE5;0X00&#x4F5C;&#x4E3A;&#x7ED3;&#x675F;&#x7B26;&#xFF0C;UTF-16&#x5219;&#x4EE5;0X0000&#x4F5C;&#x4E3A;&#x7ED3;&#x675F;&#x7B26;&#xFF0C;&#x6211;&#x8FD9;&#x91CC;&#x9ED8;&#x8BA4;&#x8BA4;&#x4E3A;&#x662F;UTF-8&#x7F16;&#x7801;&#xFF0C;&#x89E3;&#x6790;&#x8FC7;&#x7A0B;&#x5B8C;&#x5168;&#x6309;&#x7167;UTF-8&#x7F16;&#x7801;&#x6765;&#x89E3;&#x6790;&#x3002;&#x5728;&#x957F;&#x5EA6;&#x8BA1;&#x7B97;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6211;&#x53D1;&#x73B0;&#x7F51;&#x4E0A;&#x5F88;&#x591A;&#x4EBA;&#x5199;&#x7684;&#x90FD;&#x4E0D;&#x662F;&#x5F88;&#x5BF9;&#xFF0C;&#x8D77;&#x7801;&#x5F53;&#x957F;&#x5EA6;&#x8D85;&#x8FC7;128&#xFF08;&#x4E00;&#x4E2A;&#x5B57;&#x8282;&#xFF09;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x4F1A;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x8FD9;&#x4E2A;&#x957F;&#x5EA6;&#x8BA1;&#x7B97;&#x53EF;&#x662F;&#x8D39;&#x4E86;&#x597D;&#x591A;&#x8111;&#x5B50;&#xFF0C;&#x5199;&#x5199;&#x753B;&#x753B;&#x597D;&#x51E0;&#x5929;&#xFF0C;&#x7EC8;&#x4E8E;&#x5F04;&#x51FA;&#x4E00;&#x4E2A;&#x6211;&#x8BA4;&#x4E3A;&#x662F;&#x6B63;&#x786E;&#x7684;&#x8BA1;&#x7B97;&#x65B9;&#x6CD5;&#xFF08;&#x6211;&#x4E0D;&#x4FDD;&#x8BC1;&#x6B63;&#x786E;&#xFF0C;&#x4F46;&#x81F3;&#x5C11;&#x6211;&#x89E3;&#x6790;&#x7684;&#x8FC7;&#x7A0B;&#x662F;&#x6B63;&#x786E;&#x7684;&#xFF0C;&#x59D1;&#x4E14;&#x8BA4;&#x4E3A;&#x662F;&#x5BF9;&#x7684;&#x5427;&#xFF09;:1234567var i = 0 while (realSize and (0x80 shl i) != 0) { c++ byteArray[0] = stream[index + c] realSize = ((realSize and 0x7f) shl 8) or (byteArray[0].toInt() and 0xff) i += 4 } 6. Package&#x4FE1;&#x606F; &#x7EE7;String Pool&#x4FE1;&#x606F;&#x4E4B;&#x540E;&#xFF0C;&#x5C31;&#x662F;Package&#x4FE1;&#x606F;&#x5757;&#x3002;&#x5176;&#x5B9A;&#x4E49;&#x5982;&#x4E0B;&#xFF1A;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465ResourceTypes.h&#x5B9A;&#x4E49;struct ResTable_package{ struct ResChunk_header header; // If this is a base package, its ID. Package IDs start // at 1 (corresponding to the value of the package bits in a // resource identifier). 0 means this is not a base package. uint32_t id; // Actual name of this package, \\0-terminated. uint16_t name[128]; // Offset to a ResStringPool_header defining the resource // type symbol table. If zero, this package is inheriting from // another base package (overriding specific values in it). uint32_t typeStrings; // Last index into typeStrings that is for public use by others. uint32_t lastPublicType; // Offset to a ResStringPool_header defining the resource // key symbol table. If zero, this package is inheriting from // another base package (overriding specific values in it). uint32_t keyStrings; // Last index into keyStrings that is for public use by others. uint32_t lastPublicKey; uint32_t typeIdOffset;};ResTable_package&#x5B9A;&#x4E49;class ResTable_package( var header: ResChunk_header, // If this is a base package, its ID. Package IDs start // at 1 (corresponding to the value of the package bits in a // resource identifier). 0 means this is not a base package. var id: uint32_t, // Actual name of this package, \\0-terminated. var name: String, // Offset to a ResStringPool_header defining the resource // type symbol table. If zero, this package is inheriting from // another base package (overriding specific values in it). var typeStrings: uint32_t, // Last index into typeStrings that is for public use by others. var lastPublicType: uint32_t, // Offset to a ResStringPool_header defining the resource // key symbol table. If zero, this package is inheriting from // another base package (overriding specific values in it). var keyStrings: uint32_t, // Last index into keyStrings that is for public use by others. var lastPublicKey: uint32_t) { override fun toString(): String { val result = &quot;&quot;&quot;$header, |id = ${id.getValue()}, idHexValue = ${id.getHexValue()} |name = $name |typeStrings = ${typeStrings.getValue()}, typeStringsHexValue = ${typeStrings.getHexValue()} |lastPublicType = ${lastPublicType.getValue()}, lastPublicTypeHexValue = ${lastPublicType.getHexValue()} |keyStrings = ${keyStrings.getValue()}, keyStringsHexValue = ${keyStrings.getHexValue()} |lastPublicKey = ${lastPublicKey.getValue()}, lastPublicKeyHexValue = ${lastPublicKey.getHexValue()}&quot;&quot;&quot;.trimMargin() return result }} &#x6BCF;&#x4E2A;&#x5B57;&#x6BB5;&#x5BF9;&#x5E94;&#x7684;&#x542B;&#x4E49;&#x5982;&#x4E0B;&#xFF1A; header&#xFF1A;Chunk&#x7684;&#x5934;&#x90E8;&#x4FE1;&#x606F;&#x6570;&#x636E;&#x7ED3;&#x6784; id&#xFF1A;&#x5305;&#x7684;ID&#xFF0C;&#x7B49;&#x4E8E;Package Id,&#x4E00;&#x822C;&#x7528;&#x6237;&#x5305;&#x7684;&#x503C;Package Id&#x4E3A;0X7F&#xFF0C;&#x7CFB;&#x7EDF;&#x8D44;&#x6E90;&#x5305;&#x7684;Package Id&#x4E3A;0X01&#xFF0C;uint32_t&#x683C;&#x5F0F; name&#xFF1A;&#x5305;&#x540D;&#xFF0C;String&#xFF0C;256&#x5B57;&#x8282; typeString&#xFF1A;&#x7C7B;&#x578B;&#x5B57;&#x7B26;&#x4E32;&#x8D44;&#x6E90;&#x6C60;&#x76F8;&#x5BF9;&#x5934;&#x90E8;&#x7684;&#x504F;&#x79FB;&#xFF0C;uint32_t&#x683C;&#x5F0F; lastPublicType&#xFF1A;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5BFC;&#x51FA;&#x7684;Public&#x7C7B;&#x578B;&#x5B57;&#x7B26;&#x4E32;&#x5728;&#x7C7B;&#x578B;&#x5B57;&#x7B26;&#x4E32;&#x8D44;&#x6E90;&#x6C60;&#x4E2D;&#x7684;&#x7D22;&#x5F15;&#xFF0C;uint32_t&#x683C;&#x5F0F; keyStrings&#xFF1A;&#x8D44;&#x6E90;&#x9879;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32;&#x76F8;&#x5BF9;&#x5934;&#x90E8;&#x7684;&#x504F;&#x79FB;&#xFF0C;uint32_t&#x683C;&#x5F0F; lastPublicKey&#xFF1A;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x5BFC;&#x51FA;&#x7684;Public&#x8D44;&#x6E90;&#x9879;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32;&#x5728;&#x8D44;&#x6E90;&#x9879;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32;&#x8D44;&#x6E90;&#x6C60;&#x4E2D;&#x7684;&#x7D22;&#x5F15;&#xFF0C;uint32_t&#x683C;&#x5F0F;&#x793A;&#x4F8B;&#x5982;&#x4E0B;&#x56FE;&#xFF1A;&#x4ECE;&#x56FE;&#x4E2D;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF1A; headerSize = 288&#xFF08;0x0120&#xFF09; size = 235216&#xFF08; 0x000396d0&#xFF09; id = 127&#xFF08; 0x0000007f&#xFF09; name = c o m . n i c k . m y a p p l i c a t i o n typeStrings = 288&#xFF08;0x00000120&#xFF09; lastPublicType = 13&#xFF08;0x0000000d&#xFF09; keyStrings = 480&#xFF08;0x000001e0&#xFF09; lastPublicKey = 1472&#xFF08;0x000005c0&#xFF09; 7. &#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x548C;&#x8D44;&#x6E90;&#x9879;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32;&#x6C60; &#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x662F;&#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x548C;&#x8D44;&#x6E90;&#x9879;&#x540D;&#x79F0;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;Android&#x91CC;&#x9762;&#x7684;attr&#x3001;drawable&#x3001;layout&#x7B49;&#x6587;&#x4EF6;&#xFF0C;&#x5176;&#x683C;&#x5F0F;&#x662F;ResStringPool_header&#x683C;&#x5F0F;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x591A;&#x8D58;&#x8FF0;&#x3002;&#x67E5;&#x627E;&#x8FD9;&#x4E2A;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x4F4D;&#x7F6E;&#x6BD4;&#x8F83;&#x597D;&#x627E;&#xFF0C;&#x901A;&#x8FC7;&#x67E5;&#x627E;attr&#x5C31;&#x53EF;&#x4EE5;&#x627E;&#x5230;&#x5927;&#x6982;&#x4F4D;&#x7F6E;&#x3002; 8. &#x7C7B;&#x578B;&#x89C4;&#x8303;&#x6570;&#x636E;&#x5757; &#x7279;&#x5B9A;&#x7C7B;&#x578B;&#x5B9A;&#x4E49;&#x7684;&#x8D44;&#x6E90;&#x89C4;&#x8303;&#xFF0C;&#x6BCF;&#x79CD;&#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x5E94;&#x8BE5;&#x6709;&#x4E00;&#x4E2A;&#x8FD9;&#x6837;&#x7684;&#x5757;&#x3002;&#x8BE5;&#x7ED3;&#x6784;&#x4E4B;&#x540E;&#x662F;&#x4E00;&#x4E2A;&#x6574;&#x6570;&#x6570;&#x7EC4;&#xFF0C;&#x63D0;&#x4F9B;&#x4E86;&#x4E00;&#x7EC4;&#x914D;&#x7F6E;&#x66F4;&#x6539;&#x6807;&#x5FD7;&#xFF08;ResTableconfig :: CONFIG *&#xFF09;&#xFF0C;&#x8BE5;&#x6807;&#x5FD7;&#x5177;&#x6709;&#x8BE5;&#x914D;&#x7F6E;&#x7684;&#x591A;&#x4E2A;&#x8D44;&#x6E90;&#x3002; &#x53E6;&#x5916;&#xFF0C;&#x5982;&#x679C;&#x8BE5;&#x8D44;&#x6E90;&#x5DF2;&#x88AB;&#x516C;&#x5F00;&#xFF0C;&#x5219;&#x9AD8;&#x4F4D;&#x88AB;&#x8BBE;&#x7F6E;&#x3002;&#x5176;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x5982;&#x4E0B;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142ResourceTypes.h&#x5B9A;&#x4E49;struct ResTable_typeSpec{ struct ResChunk_header header; // The type identifier this chunk is holding. Type IDs start // at 1 (corresponding to the value of the type bits in a // resource identifier). 0 is invalid. uint8_t id; // Must be 0. uint8_t res0; // Must be 0. uint16_t res1; // Number of uint32_t entry configuration masks that follow. uint32_t entryCount; enum { // Additional flag indicating an entry is public. SPEC_PUBLIC = 0x40000000 };};ResTable_typeSpecclass ResTable_typeSpec(var header: ResChunk_header, var id: uint8_t,// id&#xFF0C;&#x6BCF;&#x4E2A;&#x8D44;&#x6E90;&#x72EC;&#x6709;&#x7684;id var res0: uint8_t,// &#x4FDD;&#x7559;&#x5B57;&#x6BB5;&#xFF0C;&#x4E3A;0 var res1: uint16_t, // &#x4FDD;&#x7559;&#x5B57;&#x6BB5;&#xFF0C;&#x4E3A;0 var entryCount: uint32_t) {// &#x8D44;&#x6E90;&#x9879;&#x4E2A;&#x6570; override fun toString(): String { return &quot;&quot;&quot;header = $header , |id = ${id.getValue()}, idHexValue = ${id.getHexValue()}, |res0 =${res0.getValue()} ,res1 = ${res1.getValue()} , |entryCount = ${entryCount.getValue()}, entryCountHexValue = ${entryCount.getHexValue()}&quot;&quot;&quot;.trimMargin() } companion object { val SPEC_PUBLIC = 0x40000000 }} &#x6BCF;&#x4E2A;&#x5B57;&#x6BB5;&#x5BF9;&#x5E94;&#x7684;&#x542B;&#x4E49;&#x5982;&#x4E0B;&#xFF1A; header&#xFF1A;Chunk&#x7684;&#x5934;&#x90E8;&#x4FE1;&#x606F;&#x6570;&#x636E;&#x7ED3;&#x6784; id&#xFF1A;&#x6BCF;&#x4E2A;&#x8D44;&#x6E90;&#x72EC;&#x6709;&#x7684;id&#xFF0C;uint8_t&#x7ED3;&#x6784; res0&#x548C;res1&#xFF1A;&#x4FDD;&#x7559;&#x5B57;&#x6BB5;&#xFF0C;&#x90FD;&#x4E3A;0&#xFF0C;uint8_t&#x548C;uint16_t&#x7ED3;&#x6784; entryCount&#xFF1A;&#x5F53;&#x524D;&#x7C7B;&#x578B;&#x7684;&#x8D44;&#x6E90;&#x9879;&#x7684;&#x4E2A;&#x6570;&#xFF0C;uint32_t&#x7ED3;&#x6784;&#x793A;&#x4F8B;&#x5982;&#x4E0B;&#x56FE;&#xFF1A;&#x5176;&#x8868;&#x793A;&#x7684;&#x4FE1;&#x606F;&#x4E3A;&#xFF1A; type = RES_TABLE_TYPE_SPEC_TYPE&#xFF08;0x0202&#xFF09; headerSize = 16&#xFF08;0x0010&#xFF09; size = 1472&#xFF08;0x000005c0 &#xFF09; id = 1&#xFF08;0x01&#xFF09; res0 =0&#xFF0C;res1 = 0 entryCount = 364&#xFF08;0x0000016c&#xFF09; id&#x5BF9;&#x5E94;&#x7684;&#x8D44;&#x6E90;&#x9879;&#x503C;attr 9. &#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x9879;&#x6570;&#x636E;&#x5757; &#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x6211;&#x7684;&#x7406;&#x89E3;&#x5C31;&#x662F;attr&#x3001;drawable&#x7B49;&#x6587;&#x4EF6;&#x7684;&#x5177;&#x4F53;&#x9879;&#xFF0C;&#x6BCF;&#x4E2A;&#x8D44;&#x6E90;&#x9879;&#x90FD;&#x5BF9;&#x5E94;&#x4E86;&#x591A;&#x4E2A;&#x503C;&#xFF0C;&#x8FD9;&#x4E9B;&#x503C;&#x5728;&#x4E4B;&#x524D;&#x89E3;&#x6790;&#x4E2D;&#x5DF2;&#x7ECF;&#x51FA;&#x73B0;&#xFF0C;&#x8FD9;&#x91CC;&#x53EA;&#x901A;&#x8FC7;&#x4F4D;&#x7F6E;&#x6765;&#x786E;&#x5B9A;&#x5177;&#x4F53;&#x503C;&#x3002;&#x8FD9;&#x8FB9;&#x7684;&#x7ED3;&#x6784;&#x6709;&#x70B9;&#x591A;&#xFF0C;&#x8FD9;&#x91CC;&#x8FD8;&#x662F;&#x53EA;&#x5C55;&#x793A;&#x4E00;&#x90E8;&#x5206;&#x5427;&#xFF0C;&#x771F;&#x5FC3;&#x6709;&#x70B9;&#x591A;&#x3002;&#x5177;&#x4F53;&#x5B9A;&#x4E49;&#x5982;&#x4E0B;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318ResourceTypes.h&#x5B9A;&#x4E49;&#xFF1A;struct ResTable_type{ struct ResChunk_header header; enum { NO_ENTRY = 0xFFFFFFFF }; // The type identifier this chunk is holding. Type IDs start // at 1 (corresponding to the value of the type bits in a // resource identifier). 0 is invalid. uint8_t id; // Must be 0. uint8_t res0; // Must be 0. uint16_t res1; // Number of uint32_t entry indices that follow. uint32_t entryCount; // Offset from header where ResTable_entry data starts. uint32_t entriesStart; // Configuration this collection of entries is designed for. //&#x8FD9;&#x4E2A;&#x4E0D;&#x5C55;&#x5F00;&#x4E86;&#xFF0C;&#x5185;&#x5BB9;&#x6709;&#x70B9;&#x591A; ResTable_config config; };// entrystruct ResTable_entry{ // Number of bytes in this structure. uint16_t size; enum { // If set, this is a complex entry, holding a set of name/value // mappings. It is followed by an array of ResTable_map structures. FLAG_COMPLEX = 0x0001, // If set, this resource has been declared public, so libraries // are allowed to reference it. FLAG_PUBLIC = 0x0002 }; uint16_t flags; // Reference into ResTable_package::keyStrings identifying this entry. struct ResStringPool_ref key;};// map entrystruct ResTable_map_entry : public ResTable_entry{ // Resource identifier of the parent mapping, or 0 if there is none. // This is always treated as a TYPE_DYNAMIC_REFERENCE. ResTable_ref parent; // Number of name/value pairs that follow for FLAG_COMPLEX. uint32_t count;};// mapstruct ResTable_map{ // The resource identifier defining this mapping&apos;s name. For attribute // resources, &apos;name&apos; can be one of the following special resource types // to supply meta-data about the attribute; for all other resource types // it must be an attribute resource. ResTable_ref name; ...... // This mapping&apos;s value. Res_value value;};// &#x771F;&#x6B63;&#x7684;valuestruct Res_value{ // Number of bytes in this structure. uint16_t size; // Always set to 0. uint8_t res0; // Type of the data value. enum { // The &apos;data&apos; is either 0 or 1, specifying this resource is either // undefined or empty, respectively. TYPE_NULL = 0x00, // The &apos;data&apos; holds a ResTable_ref, a reference to another resource // table entry. TYPE_REFERENCE = 0x01, // The &apos;data&apos; holds an attribute resource identifier. TYPE_ATTRIBUTE = 0x02, // The &apos;data&apos; holds an index into the containing resource table&apos;s // global value string pool. TYPE_STRING = 0x03, // The &apos;data&apos; holds a single-precision floating point number. TYPE_FLOAT = 0x04, // The &apos;data&apos; holds a complex number encoding a dimension value, // such as &quot;100in&quot;. TYPE_DIMENSION = 0x05, // The &apos;data&apos; holds a complex number encoding a fraction of a // container. TYPE_FRACTION = 0x06, // The &apos;data&apos; holds a dynamic ResTable_ref, which needs to be // resolved before it can be used like a TYPE_REFERENCE. TYPE_DYNAMIC_REFERENCE = 0x07, // Beginning of integer flavors... TYPE_FIRST_INT = 0x10, // The &apos;data&apos; is a raw integer value of the form n..n. TYPE_INT_DEC = 0x10, // The &apos;data&apos; is a raw integer value of the form 0xn..n. TYPE_INT_HEX = 0x11, // The &apos;data&apos; is either 0 or 1, for input &quot;false&quot; or &quot;true&quot; respectively. TYPE_INT_BOOLEAN = 0x12, // Beginning of color integer flavors... TYPE_FIRST_COLOR_INT = 0x1c, // The &apos;data&apos; is a raw integer value of the form #aarrggbb. TYPE_INT_COLOR_ARGB8 = 0x1c, // The &apos;data&apos; is a raw integer value of the form #rrggbb. TYPE_INT_COLOR_RGB8 = 0x1d, // The &apos;data&apos; is a raw integer value of the form #argb. TYPE_INT_COLOR_ARGB4 = 0x1e, // The &apos;data&apos; is a raw integer value of the form #rgb. TYPE_INT_COLOR_RGB4 = 0x1f, // ...end of integer flavors. TYPE_LAST_COLOR_INT = 0x1f, // ...end of integer flavors. TYPE_LAST_INT = 0x1f }; uint8_t dataType; ...... // The data for this item, as interpreted according to dataType. uint32_t data;};&#x4EE3;&#x7801;&#x4E2D;&#x5B9A;&#x4E49;&#xFF1A;class ResTable_type(var header: ResChunk_header, var id: uint8_t,// &#x6807;&#x8BC6;&#x8D44;&#x6E90;&#x7684;type id var res0: uint8_t,// &#x4FDD;&#x7559;&#xFF0C;0 var res1: uint16_t,// &#x4FDD;&#x7559;&#xFF0C;0 var entryCount: uint32_t,// &#x603B;&#x4E2A;&#x6570; var entriesStart: uint32_t,// &#x504F;&#x79FB;&#x91CF; var resConfig: ResTable_config) {// &#x914D;&#x7F6E;&#x4FE1;&#x606F; override fun toString(): String { return &quot;&quot;&quot;header: $header , |id = ${id.getValue()}, idHexValue = ${id.getHexValue()}, |res0 = ${res0.getValue()},res1 = ${res1.getValue()}, |entryCount = ${entryCount.getValue()}, entryCountHexValue = ${entryCount.getHexValue()}, |entriesStart = ${entriesStart.getValue()}, entriesStartHexValue = ${entriesStart.getHexValue()} |resConfig = $resConfig&quot;&quot;&quot;.trimMargin() } companion object { val NO_ENTRY = 0xFFFFFFFF.toInt() }}open class ResTable_entry(var size: uint16_t,// &#x5927;&#x5C0F; var flags: uint16_t,// flag&#xFF0C;&#x4E3A;1&#x662F;ResTable_map_entry var key: ResStringPool_ref?) {// &#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x5F15;&#x7528;&#x4FE1;&#x606F; var dataStr: String? = &quot;&quot; override fun toString(): String { return &quot;size = &quot; + size.getValue() + &quot;,flags = &quot; + flags.getValue() + &quot;,key = &quot; + key!!.index.getValue() + &quot;,str = &quot; + dataStr } companion object { val FLAG_COMPLEX = 0x0001 val FLAG_PUBLIC = 0x0002 }}class ResTable_map_entry(size: uint16_t, flags: uint16_t, key: ResStringPool_ref?, var parent: ResTable_ref, // &#x6307;&#x5411;&#x7236;ResTable_map_entry&#x7684;&#x8D44;&#x6E90;ID&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x7236;ResTable_map_entry&#xFF0C;&#x5219;&#x7B49;&#x4E8E;0 var count: uint32_t // ResTable_map&#x7684;&#x6570;&#x91CF;) : ResTable_entry(size, flags, key) { override fun toString(): String { return super.toString() + &quot;parent:&quot; + parent.toString() + &quot;,count:&quot; + count.getValue() }}// bag&#x8D44;&#x6E90;&#xFF1A;&#x901A;&#x4FD7;&#x7684;&#x8BF4;&#xFF0C;&#x5C31;&#x662F;&#x8FD9;&#x7C7B;&#x8D44;&#x6E90;&#x5728;&#x8D4B;&#x503C;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x4E0D;&#x80FD;&#x968F;&#x4FBF;&#x8D4B;&#x503C;&#xFF0C;&#x53EA;&#x80FD;&#x4ECE;&#x4E8B;&#x5148;&#x5B9A;&#x4E49;&#x597D;&#x7684;&#x503C;&#x4E2D;&#x9009;&#x53D6;&#x4E00;&#x4E2A;&#x8D4B;&#x503C;&#x3002;// &#x7C7B;&#x578B;&#x4E3A;values&#x7684;&#x8D44;&#x6E90;&#x9664;&#x4E86;&#x662F;string&#x4E4B;&#x5916;&#xFF0C;&#x8FD8;&#x6709;&#x5176;&#x5B83;&#x5F88;&#x591A;&#x7C7B;&#x578B;&#x7684;&#x8D44;&#x6E90;&#xFF0C;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x4E9B;&#x6BD4;&#x8F83;&#x7279;&#x6B8A;&#xFF0C;&#x5982;bag&#x3001;style&#x3001;plurals&#x548C;array&#x7C7B;&#x7684;&#x8D44;&#x6E90;&#x3002;// &#x8FD9;&#x4E9B;&#x8D44;&#x6E90;&#x4F1A;&#x7ED9;&#x81EA;&#x5DF1;&#x5B9A;&#x4E49;&#x4E00;&#x4E9B;&#x4E13;&#x7528;&#x7684;&#x503C;&#xFF0C;&#x8FD9;&#x4E9B;&#x5E26;&#x6709;&#x4E13;&#x7528;&#x503C;&#x7684;&#x8D44;&#x6E90;&#x5C31;&#x7EDF;&#x79F0;&#x4E3A;Bag&#x8D44;&#x6E90;&#x3002;class ResTable_map(var name: ResTable_ref, // bag&#x8D44;&#x6E90;&#x9879;ID, var value: Res_value) { //bag&#x8D44;&#x6E90;&#x9879;&#x503C; override fun toString(): String { return &quot;mapEntry: &quot; + name.toString() + &quot;,value = &quot; + value.toString() }}class Res_value(var size: uint16_t, // &#x5927;&#x5C0F; var res0: uint8_t, // &#x4FDD;&#x7559;&#xFF0C;0 var dataType: uint8_t, // &#x7C7B;&#x578B; var data: uint32_t) { // &#x6570;&#x636E;,&#x6839;&#x636E;&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x6765;&#x5C55;&#x793A;&#x4E0D;&#x540C;&#x6570;&#x636E;&#xFF0C;&#x8FD9;&#x90E8;&#x5206;&#x57FA;&#x672C;&#x4E0A;&#x662F;&#x7F51;&#x4E0A;&#x62FF;&#x6765;&#x7684; val typeStr: String get() { when (dataType.getValue().toInt()) { TYPE_NULL -&gt; return &quot;TYPE_NULL&quot; TYPE_REFERENCE -&gt; return &quot;TYPE_REFERENCE&quot; TYPE_ATTRIBUTE -&gt; return &quot;TYPE_ATTRIBUTE&quot; TYPE_STRING -&gt; return &quot;TYPE_STRING&quot; TYPE_FLOAT -&gt; return &quot;TYPE_FLOAT&quot; TYPE_DIMENSION -&gt; return &quot;TYPE_DIMENSION&quot; TYPE_FRACTION -&gt; return &quot;TYPE_FRACTION&quot; TYPE_FIRST_INT -&gt; return &quot;TYPE_FIRST_INT&quot; TYPE_INT_HEX -&gt; return &quot;TYPE_INT_HEX&quot; TYPE_INT_BOOLEAN -&gt; return &quot;TYPE_INT_BOOLEAN&quot; TYPE_FIRST_COLOR_INT -&gt; return &quot;TYPE_FIRST_COLOR_INT&quot; TYPE_INT_COLOR_RGB8 -&gt; return &quot;TYPE_INT_COLOR_RGB8&quot; TYPE_INT_COLOR_ARGB4 -&gt; return &quot;TYPE_INT_COLOR_ARGB4&quot; TYPE_INT_COLOR_RGB4 -&gt; return &quot;TYPE_INT_COLOR_RGB4&quot; } return &quot;&quot; } val dataStr: String get() { if (dataType.getValue().toInt() == TYPE_STRING) { return getStringPoolStr(data.getValue())!! } if (dataType.getValue().toInt() == TYPE_ATTRIBUTE) { return String.format(&quot;?%s%08X&quot;, getPackage(data.getValue()), data.getValue()) } if (dataType.getValue().toInt() == TYPE_REFERENCE) { return String.format(&quot;@%s%08X&quot;, getPackage(data.getValue()), data.getValue()) } if (dataType.getValue().toInt() == TYPE_FLOAT) { return java.lang.Float.intBitsToFloat(data.getValue()).toString() } if (dataType.getValue().toInt() == TYPE_INT_HEX) { return String.format(&quot;0x%08X&quot;, data.getValue()) } if (dataType.getValue().toInt() == TYPE_INT_BOOLEAN) { return if (data.getValue() != 0) &quot;true&quot; else &quot;false&quot; } if (dataType.getValue().toInt() == TYPE_DIMENSION) { return java.lang.Float.toString(complexToFloat(data.getValue())) + DIMENSION_UNITS[data.getValue() and COMPLEX_UNIT_MASK] } if (dataType.getValue().toInt() == TYPE_FRACTION) { return java.lang.Float.toString(complexToFloat(data.getValue())) + FRACTION_UNITS[data.getValue() and COMPLEX_UNIT_MASK] } if (dataType.getValue() in TYPE_FIRST_COLOR_INT..TYPE_LAST_COLOR_INT) { return String.format(&quot;#%08X&quot;, data.getValue()) } if (dataType.getValue() in TYPE_FIRST_INT..TYPE_LAST_INT) { return data.getValue().toString() } return String.format(&quot;&lt;0x%X, type 0x%02X&gt;&quot;, data.getValue(), dataType.getValue()) } override fun toString(): String { return &quot;&quot;&quot;size = ${size.getValue()}, sizeHexValue = ${size.getHexValue()} |res0 = ${res0.getValue()}, res0HexValue = ${res0.getHexValue()} |dataType = ${dataType.getValue()}, dataTypeHexValue = ${dataType.getHexValue()}, typeStr = $typeStr |data = ${data.getValue()}, dataHexValue = ${data.getHexValue()}, dataStr = $dataStr&quot;&quot;&quot;.trimMargin() } companion object { val TYPE_NULL = 0x00 val TYPE_REFERENCE = 0x01 val TYPE_ATTRIBUTE = 0x02 val TYPE_STRING = 0x03 val TYPE_FLOAT = 0x04 val TYPE_DIMENSION = 0x05 val TYPE_FRACTION = 0x06 val TYPE_FIRST_INT = 0x10 val TYPE_INT_DEC = 0x10 val TYPE_INT_HEX = 0x11 val TYPE_INT_BOOLEAN = 0x12 val TYPE_FIRST_COLOR_INT = 0x1c val TYPE_INT_COLOR_ARGB8 = 0x1c val TYPE_INT_COLOR_RGB8 = 0x1d val TYPE_INT_COLOR_ARGB4 = 0x1e val TYPE_INT_COLOR_RGB4 = 0x1f val TYPE_LAST_COLOR_INT = 0x1f val TYPE_LAST_INT = 0x1f val COMPLEX_UNIT_PX = 0 val COMPLEX_UNIT_DIP = 1 val COMPLEX_UNIT_SP = 2 val COMPLEX_UNIT_PT = 3 val COMPLEX_UNIT_IN = 4 val COMPLEX_UNIT_MM = 5 val COMPLEX_UNIT_SHIFT = 0 val COMPLEX_UNIT_MASK = 15 val COMPLEX_UNIT_FRACTION = 0 val COMPLEX_UNIT_FRACTION_PARENT = 1 val COMPLEX_RADIX_23p0 = 0 val COMPLEX_RADIX_16p7 = 1 val COMPLEX_RADIX_8p15 = 2 val COMPLEX_RADIX_0p23 = 3 val COMPLEX_RADIX_SHIFT = 4 val COMPLEX_RADIX_MASK = 3 val COMPLEX_MANTISSA_SHIFT = 8 val COMPLEX_MANTISSA_MASK = 0xFFFFFF private fun getPackage(id: Int): String { if (id.ushr(24) == 1) { return &quot;android:&quot; } return &quot;&quot; } fun complexToFloat(complex: Int): Float { return (complex and 0xFFFFFF00.toInt()).toFloat() * RADIX_MULTS[complex shr 4 and 3] } private val RADIX_MULTS = floatArrayOf(0.00390625f, 3.051758E-005f, 1.192093E-007f, 4.656613E-010f) private val DIMENSION_UNITS = arrayOf(&quot;px&quot;, &quot;dip&quot;, &quot;sp&quot;, &quot;pt&quot;, &quot;in&quot;, &quot;mm&quot;, &quot;&quot;, &quot;&quot;) private val FRACTION_UNITS = arrayOf(&quot;%&quot;, &quot;%p&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;, &quot;&quot;) }} &#x4E0A;&#x9762;&#x7684;&#x7ED3;&#x6784;&#x5B9A;&#x4E49;&#x786E;&#x5B9E;&#x5F88;&#x591A;&#xFF0C;&#x6709;&#x4E00;&#x90E8;&#x5206;&#x662F;&#x4ECE;&#x5148;&#x4EBA;&#x7684;&#x535A;&#x5BA2;&#x4E2D;&#x6458;&#x6284;&#x7684;&#xFF0C;&#x4F46;&#x6211;&#x5E76;&#x4E0D;&#x8BA4;&#x4E3A;&#x4ED6;&#x4EEC;&#x7684;&#x5168;&#x662F;&#x6B63;&#x786E;&#x7684;&#xFF0C;&#x56E0;&#x4E3A;&#x5728;&#x6211;&#x81EA;&#x5DF1;&#x89E3;&#x6790;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x4E00;&#x6B21;&#x6B21;&#x80AF;&#x5B9A;&#x53C8;&#x4E00;&#x6B21;&#x6B21;&#x5426;&#x5B9A;&#xFF0C;&#x6162;&#x6162;&#x81EA;&#x5DF1;&#x53D1;&#x73B0;&#x89C4;&#x5F8B;&#x5E76;&#x5B8C;&#x6210;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x3002;&#x4E0A;&#x9762;&#x7ED3;&#x6784;&#x4F53;ResTable_type&#x5B9A;&#x4E49;&#x4E86;&#x8BE5;&#x8D44;&#x6E90;&#x9879;&#x7684;&#x8D44;&#x6E90;id&#x3001;&#x603B;&#x4E2A;&#x6570;&#x3001;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x4EE5;&#x53CA;&#x504F;&#x79FB;&#x91CF;&#xFF0C;&#x63A5;&#x7740;&#x6839;&#x636E;ResTable_entry&#x7684;flags&#x6765;&#x5224;&#x65AD;&#x5177;&#x4F53;&#x662F;ResTable_map_entry&#x8FD8;&#x662F;ResTable_entry&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x5B9A;&#x4E49;&#x4E86;size&#xFF0C;&#x5373;&#x5927;&#x5C0F;&#x3002;&#x5982;&#x679C;&#x7C7B;&#x578B;&#x662F;ResTable_map_entry&#xFF0C;&#x5219;&#x6839;&#x636E;ResTable_map_entry&#x7684;count&#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x7684;ResTable_map&#xFF0C;ResTable_map&#x4E2D;&#x5305;&#x62EC;&#x4E86;&#x8D44;&#x6E90;&#x9879;&#x7684;id&#x548C;&#x503C;&#xFF08;Res_value&#xFF09;&#x3002;&#x5982;&#x679C;&#x7C7B;&#x578B;&#x662F;ResTable_entry&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x91CC;&#x4F1A;&#x6709;&#x4E00;&#x4E2A;&#x8D44;&#x6E90;&#x9879;&#x7684;&#x503C;Res_value&#x3002;Res_value&#x4E2D;&#x6839;&#x636E;&#x7C7B;&#x578B;&#xFF08;dataType&#xFF09;&#x6765;&#x5224;&#x65AD;&#x5177;&#x4F53;&#x5C5E;&#x4E8E;&#x4EC0;&#x4E48;&#x7C7B;&#x578B;&#xFF0C;&#x5E76;&#x6839;&#x636E;&#x7C7B;&#x578B;&#x548C;&#x6570;&#x636E;&#xFF08;data&#xFF09;&#x6765;&#x83B7;&#x5F97;&#x5177;&#x4F53;&#x7684;&#x503C;&#x3002; 10. &#x89E3;&#x6790;&#x8FC7;&#x7A0B; &#x4E86;&#x89E3;&#x4E86;resources.arsc&#x7684;&#x6587;&#x4EF6;&#x7ED3;&#x6784;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x7ED3;&#x6784;&#x548C;&#x4E8C;&#x8FDB;&#x5236;&#x6587;&#x4EF6;&#x67E5;&#x770B;&#x5668;&#x6765;&#x8FDB;&#x884C;&#x6587;&#x4EF6;&#x7684;&#x89E3;&#x6790;&#x3002; 10.1 &#x5DE5;&#x5177;&#x7C7B;&#x548C;&#x7C7B;&#x578B;&#x5B9A;&#x4E49;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231ibasic_unit:&#x57FA;&#x7840;&#x7684;&#x63A5;&#x53E3;interface ibasic_unit&lt;T&gt; { fun getValue(): T //value fun getHexValue(): String // &#x8FD4;&#x56DE;16&#x8FDB;&#x5236;&#x683C;&#x5F0F;&#x5316;&#x5B57;&#x7B26;&#x4E32;}basic_unit:&#x57FA;&#x7840;&#x7684;&#x62BD;&#x8C61;&#x5B9E;&#x73B0;&#x7C7B;abstract class basic_unit&lt;T&gt;(protected var relValue: T) : ibasic_unit&lt;T&gt; { override fun getValue(): T { return relValue }}uint8_t:&#x8BFB;&#x53D6;&#x4E00;&#x4E2A;&#x5B57;&#x8282;&#xFF0C;&#x5BF9;&#x5E94;&#x7C7B;&#x578B;&#x662F;Byteclass uint8_t(value: Byte) : basic_unit&lt;Byte&gt;(value) { override fun getHexValue(): String { var toHexString = Integer.toHexString(getValue().toInt()) if (toHexString.length &lt; 2) { for (i in 1..2 - toHexString.length) { toHexString = &quot;0&quot; + toHexString } } return &quot;0x&quot; + toHexString }}uint16_t:&#x8BFB;&#x53D6;&#x4E24;&#x4E2A;&#x5B57;&#x8282;&#xFF0C;&#x5BF9;&#x5E94;&#x7684;&#x503C;&#x7684;&#x7C7B;&#x578B;&#x662F;Shortclass uint16_t(value: Short) : basic_unit&lt;Short&gt;(value) { override fun getValue(): Short { return getShortValue(relValue) } override fun getHexValue(): String { var toHexString = Integer.toHexString(com.nick.model.type.getShortValue(relValue).toInt()) if (toHexString.length &lt; 4) { for (i in 1..4 - toHexString.length) { toHexString = &quot;0&quot; + toHexString } } return &quot;0x&quot; + toHexString }}uint32_t:&#x8BFB;&#x53D6;&#x56DB;&#x4E2A;&#x5B57;&#x8282;&#x7684;&#x503C;&#xFF0C;&#x5BF9;&#x5E94;&#x7C7B;&#x578B;&#x662F;Intclass uint32_t(var value: Int) : basic_unit&lt;Int&gt;(value) { override fun getValue(): Int { return getIntValue(relValue) } override fun getHexValue(): String { var toHexString = Integer.toHexString(getValue()) if (toHexString.length &lt; 8) { for (i in 1..(8 - toHexString.length)) { toHexString = &quot;0&quot; + toHexString } } return &quot;0x&quot; + toHexString }}Config:&#x914D;&#x7F6E;&#x4FE1;&#x606F;class Config { companion object { val RESCHUNK_HEADER_SIZE = 8 //chunk&#x5934;&#x90E8;&#x5927;&#x5C0F; val RESTABLE_MAP_SIZE = 12 //res table map&#x5927;&#x5C0F; val RES_VALUE_SIZE = 8 //res value&#x5927;&#x5C0F; }}ReadUtils.kt:var stringList: Array&lt;String&gt;? = null //&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x6570;&#x7EC4;//&#x8BFB;&#x53D6;uint8_tfun read_uint8_t(byteArray: ByteArray, offset: Int): uint8_t { return uint8_t(byteArray[offset])}fun byte22Uint16_t(byteArray: ByteArray): uint16_t { var value: Short = 0 for (i in 0..1) { value = (value.toInt() shl 8).toShort() value = value or (byteArray[i].toInt() and 0xFF).toShort() } return uint16_t(value)}//&#x8BFB;&#x53D6;uint16_tfun read_uint16_t(stream: ByteArray, index: Int): uint16_t { val byte = ByteArray(2) byte[0] = stream[index] byte[1] = stream[index + 1] var value: Short = 0 for (i in 0..1) { value = (value.toInt() shl 8).toShort() value = value or (byte[i].toInt() and 0xFF).toShort() } return uint16_t(value)}//&#x8BFB;&#x53D6;uint32_tfun read_uint32_t(stream: ByteArray, index: Int): uint32_t { val byte = ByteArray(4) for (i in 0..byte.size - 1) { byte[i] = stream[index + i] } var value: Int = 0 for (i in 0..3) { value = value shl 8 value = value or (byte[i].toInt() and 0xFF) } return uint32_t(value)}//&#x8BFB;&#x53D6;uint64_tfun read_uint64_t(stream: ByteArray, index: Int): uint64_t { val byte = ByteArray(8) for (i in 0..byte.size - 1) { byte[i] = stream[index + i] } var value: Long = 0 for (i in 0..7) { value = value shl 8 value = value or (byte[i].toLong() and 0xFF) } return uint64_t(value)}//&#x8BFB;&#x53D6;&#x5B57;&#x7B26;&#x4E32;fun readString2(stream: ByteArray, size: Int, index: Int): Pair&lt;String, Int&gt; { val bytes = ByteArray(1) val byteArray = ByteArray(1) var realSize = 0 bytes[0] = stream[index] byteArray[0] = stream[index + 1] var c = 1 if (bytes[0].toInt() and 0x80 != 0) { c++ byteArray[0] = stream[index + c] } var result = &quot;&quot; realSize = byteArray[0].toInt() var i = 0 while (realSize and (0x80 shl i) != 0) { c++ byteArray[0] = stream[index + c] realSize = ((realSize and 0x7f) shl 8) or (byteArray[0].toInt() and 0xff) i += 4 } if (realSize &gt; 0) { val tempBytes = ByteArray(realSize) for (j in 0..tempBytes.size - 1) { tempBytes[j] = stream[index + c + 1 + j] } result += &quot;${String(tempBytes)} realSize = $realSize size = $size c = $c&quot; } val resultPair = Pair(result, realSize + c + i + 1) return resultPair}//&#x6839;&#x636E;&#x5B57;&#x7B26;&#x4E32;size&#x8BFB;&#x53D6;&#x5B57;&#x7B26;&#x4E32;fun readStringWithSize(stream: ByteArray, offset: Int, size: Int): String { var result = &quot;&quot; if (size &gt; 0) { val tempBytes = ByteArray(size) for (i in 0..tempBytes.size - 1) { tempBytes[i] = stream[offset + i] } result = String(tempBytes) } return result}//&#x8BFB;&#x53D6;chunk&#x7684;&#x5934;&#x90E8;fun getResChunk_header(stream: ByteArray, index: Int): ResChunk_header { return ResChunk_header(read_uint16_t(stream, index), read_uint16_t(stream, index + 2), read_uint32_t(stream, index + 4))}//&#x5F97;&#x5230;int&#x503C;fun getIntValue(value: Int): Int { val bytes = ByteArray(4) bytes[0] = (value and 0x000000ff).toByte() bytes[1] = ((value ushr 8) and 0x000000ff).toByte() bytes[2] = ((value ushr 16) and 0x000000ff).toByte() bytes[3] = ((value ushr 24) and 0x000000ff).toByte() var result: Int = 0 for (i in 0..3) { result = result shl 8 result = result or (bytes[i].toInt() and 0xFF) } return result}//&#x5F97;&#x5230;long&#x503C;fun getLongValue(value: Long): Long { val bytes = ByteArray(8) bytes[0] = (value and 0x000000ff).toByte() bytes[1] = ((value ushr 8) and 0x000000ff).toByte() bytes[2] = ((value ushr 16) and 0x000000ff).toByte() bytes[3] = ((value ushr 24) and 0x000000ff).toByte() bytes[0] = ((value ushr 32) and 0x000000ff).toByte() bytes[1] = ((value ushr 40) and 0x000000ff).toByte() bytes[2] = ((value ushr 48) and 0x000000ff).toByte() bytes[3] = ((value ushr 56) and 0x000000ff).toByte() var result: Long = 0 for (i in 0..bytes.size - 1) { result = result shl 8 result = result or (bytes[i].toLong() and 0xFF) } return result}//&#x5F97;&#x5230;short&#x503C;fun getShortValue(value: Short): Short { val bytes = ByteArray(2) bytes[0] = (value and 0x00ff).toByte() bytes[1] = ((value.toInt() shr 8) and 0x00ff).toByte() var result: Short = 0 for (i in 0..1) { result = (result.toInt() shl 8).toShort() result = result or (bytes[i].toInt() and 0xFF).toShort() } return result}//&#x5F97;&#x5230;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x4E2D;&#x5177;&#x4F53;&#x7684;&#x503C;fun getStringPoolStr(index: Int): String? { if (stringList == null || stringList?.get(index).isNullOrEmpty()) { return &quot;&quot; } return stringList?.get(index)} &#x5DE5;&#x5177;&#x7C7B;&#x91CC;&#x9762;&#x4E3B;&#x8981;&#x5305;&#x62EC;&#x4E86;&#x6240;&#x6709;&#x7C7B;&#x578B;&#x7684;&#x8BFB;&#x53D6;&#xFF0C;chunk&#x5934;&#x90E8;&#x4FE1;&#x606F;&#x7684;&#x8BFB;&#x53D6;&#xFF0C;&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x8BFB;&#x53D6;&#x4EE5;&#x53CA;&#x771F;&#x6B63;&#x503C;&#x7684;&#x8F6C;&#x6362;&#x3002; 10.2 &#x6587;&#x4EF6;&#x8BFB;&#x53D6;&#x548C;&#x5B57;&#x8282;&#x6570;&#x7EC4;&#x8F6C;&#x6362;12345678val stream = File(&quot;H:\\\\javaworkpace\\\\idea\\\\resourcesAnalyzer\\\\src\\\\com\\\\nick\\\\resources.arsc&quot;).inputStream()val os = ByteArrayOutputStream()val bytes = ByteArray(1024)var len = stream.read(bytes)while (len != -1) { os.write(bytes, 0, len) len = stream.read(bytes)} 10.3 &#x89E3;&#x6790;ResTable_header&#x4FE1;&#x606F;1234println(&quot;---------------------&#x89E3;&#x6790;ResTable_header&#x4FE1;&#x606F;&#x5F00;&#x59CB;---------------------&quot;)val resTable_header = ResTable_header(getResChunk_header(streamByte, 0), read_uint32_t(streamByte, Config.RESCHUNK_HEADER_SIZE))println(resTable_header)println(&quot;---------------------&#x89E3;&#x6790;ResTable_header&#x4FE1;&#x606F;&#x5B8C;&#x6BD5;---------------------&quot;) &#x6709;&#x4E86;&#x7C7B;&#x7684;&#x5B9A;&#x4E49;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5F88;&#x7B80;&#x5355;&#x7684;&#x53BB;&#x89E3;&#x6790;&#x5934;&#x90E8;&#x7684;&#x4FE1;&#x606F;&#x3002;&#x8F93;&#x51FA;&#x5982;&#x4E0B;&#xFF1A; 10.4 &#x89E3;&#x6790;&#x5B57;&#x7B26;&#x4E32;&#x8D44;&#x6E90;&#x6C60;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 // &#x504F;&#x79FB;&#x91CF;&#x5373;headerSize offset = resTable_header.header.headerSize.getValue().toInt() //&#x8BFB;&#x53D6;&#x5B57;&#x7B26;&#x4E32;&#x6C60; val resStringPool_header = resStringPool_header(streamByte, offset) //&#x5168;&#x5C40;&#x7684;&#x5B57;&#x7B26;&#x4E32;&#x6C60;&#x6570;&#x7EC4;&#x4FDD;&#x5B58; stringList = resStringPool_header.stringStringArray!!.stringArrayprivate fun resStringPool_header(streamByte: ByteArray, offset: Int): ResStringPool_header { println(&quot;---------------------&#x89E3;&#x6790;ResStringPool_header&#x4FE1;&#x606F;&#x5F00;&#x59CB;---------------------&quot;) val resStringPool_header = ResStringPool_header(getResChunk_header(streamByte, offset), read_uint32_t(streamByte, offset + Config.RESCHUNK_HEADER_SIZE), read_uint32_t(streamByte, offset + Config.RESCHUNK_HEADER_SIZE + 4), read_uint32_t(streamByte, offset + Config.RESCHUNK_HEADER_SIZE + 8), read_uint32_t(streamByte, offset + Config.RESCHUNK_HEADER_SIZE + 12), read_uint32_t(streamByte, offset + Config.RESCHUNK_HEADER_SIZE + 16), null, null, null, null) println(resStringPool_header) println(&quot;---------------------&#x89E3;&#x6790;ResStringPool_header&#x4FE1;&#x606F;&#x5B8C;&#x6BD5;---------------------&quot;) //&#x89E3;&#x6790;&#x5B8C;&#x6210;&#x540E;&#x4F1A;&#x6709;&#x4E24;&#x4E2A;&#x504F;&#x79FB;&#x6570;&#x7EC4;&#xFF0C;&#x4E00;&#x4E2A;&#x662F;string&#x504F;&#x79FB;&#x6570;&#x7EC4;&#xFF0C;&#x53E6;&#x4E00;&#x4E2A;&#x662F;style&#x504F;&#x79FB;&#x6570;&#x7EC4; // string&#x504F;&#x79FB;&#x6570;&#x7EC4; val stringCount = resStringPool_header.stringCount.getValue() val resString_offset_array = ResString_offset_array(Array(stringCount, { uint32_t(0) })) for (i in 0..stringCount - 1) { resString_offset_array.offset_array[i] = read_uint32_t(streamByte, resStringPool_header.header.headerSize.getValue() + offset + i * 4) } // style&#x504F;&#x79FB;&#x6570;&#x7EC4; val styleCount = resStringPool_header.styleCount.getValue() val resStyle_offset_array = ResStyle_offset_array(Array(styleCount, { uint32_t(0) })) for (i in 0..styleCount - 1) { resStyle_offset_array.offset_array[i] = read_uint32_t(streamByte, resStringPool_header.header.headerSize.getValue() + stringCount * 4 + offset + i * 4) } //&#x89E3;&#x6790;&#x5B57;&#x7B26;&#x4E32;&#x6C60; val stringStartOffset = offset + resStringPool_header.stringsStart.getValue() val stringArray: Array&lt;String&gt; = Array(resStringPool_header.stringCount.getValue(), { &quot;&quot; }) for (i in 0..resStringPool_header.stringCount.getValue() - 1) { var size: Int if (i + 1 &lt;= resStringPool_header.stringCount.getValue() - 1) { size = resString_offset_array.offset_array[i + 1].getValue() - resString_offset_array.offset_array[i].getValue() } else { size = resStringPool_header.header.size.getValue() - resString_offset_array.offset_array[i].getValue() - resStringPool_header.stringCount.getValue() * 4 - 28 } val resultPair = readString2(streamByte, size, stringStartOffset + resString_offset_array.offset_array[i].getValue()) stringArray[i] = resultPair.first } //&#x8D44;&#x6E90;&#x5B57;&#x7B26;&#x4E32;&#x503C; val resString_string_array = ResString_string_array(stringArray) resString_string_array.stringArray.forEachIndexed { index, s -&gt; println(&quot;$index : $s&quot;) } println(&quot;----------------------&#x8BFB;&#x53D6;style----------------------&quot;) val styleStartOffset = offset + resStringPool_header.stylesStart.getValue() val styleStringArray: Array&lt;ResStringPool_span&gt; = Array(resStringPool_header.styleCount.getValue(), { ResStringPool_span( ResStringPool_ref(uint32_t(0)), uint32_t(0), uint32_t(0) ) }) for (i in 0..resStringPool_header.styleCount.getValue() - 1) { styleStringArray[i] = ResStringPool_span( ResStringPool_ref(read_uint32_t(streamByte, styleStartOffset + resStyle_offset_array.offset_array[i].getValue())), read_uint32_t(streamByte, styleStartOffset + resStyle_offset_array.offset_array[i].getValue() + 4), read_uint32_t(streamByte, styleStartOffset + resStyle_offset_array.offset_array[i].getValue() + 8) ) } for (i in 0..resStringPool_header.styleCount.getValue() - 1) { println(styleStringArray[i]) } resStringPool_header.stringOffsetArray = resString_offset_array resStringPool_header.styleOffsetArray = resStyle_offset_array resStringPool_header.stringStringArray = resString_string_array resStringPool_header.styleStringArray = ResStyle_string_array(styleStringArray) return resStringPool_header} &#x8FD9;&#x4E00;&#x90E8;&#x5206;&#x5176;&#x5B9E;&#x89E3;&#x6790;&#x5E76;&#x4E0D;&#x96BE;&#xFF0C;&#x96BE;&#x7684;&#x662F;&#x5173;&#x4E8E;&#x5B57;&#x7B26;&#x4E32;&#x957F;&#x5EA6;&#x7684;&#x8BA1;&#x7B97;&#x3002;&#x6B63;&#x5982;&#x6211;&#x4E4B;&#x524D;&#x8BF4;&#x7684;&#xFF0C;&#x957F;&#x5EA6;&#x8BA1;&#x7B97;&#x6211;&#x5728;&#x7F51;&#x4E0A;&#x67E5;&#x4E86;&#x4E0D;&#x5C11;&#x8D44;&#x6599;&#xFF0C;&#x4F46;&#x662F;&#x5B9E;&#x9645;&#x64CD;&#x4F5C;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x603B;&#x4F1A;&#x51FA;&#x73B0;&#x4E71;&#x7801;&#xFF08;&#x957F;&#x5EA6;&#x8BA1;&#x7B97;&#x9519;&#x8BEF;&#xFF09;&#x7684;&#x73B0;&#x8C61;&#x3002;&#x8BF4;&#x5B9E;&#x8BDD;&#xFF0C;&#x8FD9;&#x4E2A;&#x95EE;&#x9898;&#x6211;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x5176;&#x4ED6;&#x65B9;&#x6CD5;&#x6765;&#x8DF3;&#x8FC7;&#xFF0C;&#x5C31;&#x5982;&#x4EE3;&#x7801;&#x91CC;&#x5199;&#x7684;&#xFF0C;&#x901A;&#x8FC7;&#x504F;&#x79FB;&#x6570;&#x7EC4;&#x6765;&#x5224;&#x65AD;&#x5177;&#x4F53;&#x957F;&#x5EA6;&#xFF0C;&#x89E3;&#x6790;&#x7684;&#x65F6;&#x5019;&#x6839;&#x636E;&#x957F;&#x5EA6;&#x6765;&#x89E3;&#x6790;&#x3002;&#x4F46;&#x662F;&#x8FD9;&#x4E48;&#x505A;&#x660E;&#x663E;&#x662F;&#x4E2A;&#x9519;&#x8BEF;&#x7684;&#x505A;&#x6CD5;&#x3002;&#x7ECF;&#x8FC7;&#x51E0;&#x5929;&#x7684;&#x63A2;&#x7D22;&#xFF0C;&#x627E;&#x51FA;&#x4E86;&#x81EA;&#x8BA4;&#x4E3A;&#x662F;&#x6B63;&#x786E;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x540E;&#x5B8C;&#x6210;&#x4E86;&#x8FD9;&#x90E8;&#x5206;&#x7684;&#x89E3;&#x6790;&#x3002;&#x89E3;&#x6790;&#x7ED3;&#x679C;&#xFF08;&#x90E8;&#x5206;&#xFF09;&#xFF1A; 10.5 Package&#x4FE1;&#x606F;&#x89E3;&#x6790;1234567891011121314151617181920212223242526println(&quot;&#x8BFB;&#x53D6;Package&#x4FE1;&#x606F;&quot;)// package&#x7684;&#x504F;&#x79FB;&#x91CF;val packageOffset = resStringPool_header.header.size.getValue() + offset// &#x89E3;&#x6790;Package&#x6570;&#x636E;&#x5757;val resTable_package = ResTable_package( getResChunk_header(streamByte, packageOffset), read_uint32_t(streamByte, packageOffset + Config.RESCHUNK_HEADER_SIZE), readStringWithSize(streamByte, packageOffset + Config.RESCHUNK_HEADER_SIZE + 4, 256), read_uint32_t(streamByte, packageOffset + Config.RESCHUNK_HEADER_SIZE + 4 + 256), read_uint32_t(streamByte, packageOffset + Config.RESCHUNK_HEADER_SIZE + 4 + 256 + 4), read_uint32_t(streamByte, packageOffset + Config.RESCHUNK_HEADER_SIZE + 4 + 256 + 4 + 4), read_uint32_t(streamByte, packageOffset + Config.RESCHUNK_HEADER_SIZE + 4 + 256 + 4 + 4 + 4))println(resTable_package)println(&quot;&#x8BFB;&#x53D6;Package&#x4FE1;&#x606F;&#x5B8C;&#x6BD5;&quot;)// &#x89E3;&#x6790;&#x8D44;&#x6E90;&#x7C7B;&#x578B;// &#x504F;&#x79FB;&#x91CF;&#x8BBE;&#x7F6E;&#xFF0C;val resTypePoolOffset = resTable_package.header.headerSize.getValue().toInt() + packageOffsetval resTypeStringPool_header = resStringPool_header(streamByte, resTypePoolOffset)// &#x89E3;&#x6790;&#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x503C;val resInTypeStringPoolOffset = resTypePoolOffset + resTypeStringPool_header.header.size.getValue()val resInTypeStringPool_header = resStringPool_header(streamByte, resInTypeStringPoolOffset)var resTableTypeSpecOffset = resInTypeStringPoolOffset + resInTypeStringPool_header.header.size.getValue()var resTypeSpecOffset = resTableTypeSpecOffset &#x8FD9;&#x91CC;&#x9762;&#x89E3;&#x6790;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#xFF0C;&#x5148;&#x89E3;&#x6790;Package&#x6570;&#x636E;&#xFF0C;&#x63A5;&#x7740;&#x89E3;&#x6790;&#x4E86;&#x8D44;&#x6E90;&#x9879;&#x4EE5;&#x53CA;&#x8D44;&#x6E90;&#x9879;&#x7684;&#x503C;&#x3002;&#x7ED3;&#x679C;&#x5982;&#x4E0B;&#xFF1A; 10.6 &#x7C7B;&#x578B;&#x89C4;&#x8303;&#x6570;&#x636E;&#x5757;&#x548C;&#x8D44;&#x6E90;&#x7C7B;&#x578B;&#x9879;&#x6570;&#x636E;&#x5757;&#x89E3;&#x6790;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117while (resTypeSpecOffset &lt; streamByte.size) { if (read_uint16_t(streamByte, resTypeSpecOffset).getValue().toInt() == ResChunk_header.ChunkType.RES_TABLE_TYPE_SPEC_TYPE.type) { val resTable_typeSpec = ResTable_typeSpec(getResChunk_header(streamByte, resTypeSpecOffset), read_uint8_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE), read_uint8_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1), read_uint16_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2)) println(&quot;$resTable_typeSpec, idValue = ${resTypeStringPool_header.stringStringArray!!.stringArray[resTable_typeSpec.id.getValue().toInt() - 1]}&quot;) val arrayOfUint32_ts = Array(resTable_typeSpec.entryCount.getValue(), { uint32_t(0) }) (0..resTable_typeSpec.entryCount.getValue() - 1).forEachIndexed { index, i -&gt; arrayOfUint32_ts[index] = read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 + 4 * index) } val res_entry_array = Res_entry_array(arrayOfUint32_ts) println(res_entry_array) resTypeSpecOffset += resTable_typeSpec.header.size.getValue() println(&quot;===========================================&quot;) } else { val resTable_type = ResTable_type( getResChunk_header(streamByte, resTypeSpecOffset), read_uint8_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE), read_uint8_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1), read_uint16_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4), ResTable_config( read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 2), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 3), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 4), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 5), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 6), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 7), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 8), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 9), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 10), read_uint32_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 11), read_uint64_t(streamByte, resTypeSpecOffset + Config.RESCHUNK_HEADER_SIZE + 1 + 1 + 2 + 4 * 12) )) println(resTable_type) var tempOffset = resTypeSpecOffset + resTable_type.header.headerSize.getValue().toInt() val arrayOfUint32_ts = Array(resTable_type.entryCount.getValue(), { uint32_t(0) }) (0..resTable_type.entryCount.getValue() - 1).forEachIndexed { index, i -&gt; arrayOfUint32_ts[index] = read_uint32_t(streamByte, tempOffset + 4 * index) } val res_entry_array2 = Res_entry_array(arrayOfUint32_ts) println(res_entry_array2) tempOffset += resTable_type.entriesStart.getValue() - resTable_type.header.headerSize.getValue().toInt() val resString_string_array = resInTypeStringPool_header.stringStringArray var count = 0 var resId = 0 while (count &lt; resTable_type.header.size.getValue() - resTable_type.entriesStart.getValue()) { println(&quot;resId = ${Integer.toHexString(resId)}&quot;) val size = read_uint16_t(streamByte, tempOffset + count) val flags = read_uint16_t(streamByte, tempOffset + count + 2) if (flags.getValue().toInt() == 1) { val resTable_map_entry = ResTable_map_entry(size, flags, ResStringPool_ref(read_uint32_t(streamByte, tempOffset + count + 2 + 2)), ResTable_ref(read_uint32_t(streamByte, tempOffset + count + 2 + 2 + 4)), read_uint32_t(streamByte, tempOffset + count + 2 + 2 + 4 + 4)) val mapStr = resTable_map_entry.key!!.index.getValue() resTable_map_entry.dataStr = resInTypeStringPool_header.stringStringArray!!.stringArray[mapStr] println(resTable_map_entry) count += resTable_map_entry.size.getValue().toInt() println(resString_string_array!!.stringArray[mapStr]) println(&quot;--------------------------resTable_map start------------------------------&quot;) for (index in 0..resTable_map_entry.count.getValue() - 1) { val resTable_map = ResTable_map( ResTable_ref( read_uint32_t(streamByte, tempOffset)), Res_value( read_uint16_t(streamByte, tempOffset + 4), read_uint8_t(streamByte, tempOffset + 4 + 2), read_uint8_t(streamByte, tempOffset + 4 + 2 + 1), read_uint32_t(streamByte, tempOffset + 4 + 2 + 1 + 1))) println(resTable_map) count += Config.RESTABLE_MAP_SIZE } println(&quot;--------------------------resTable_map end------------------------------&quot;) } else { val resTable_entry = ResTable_entry(size, flags, ResStringPool_ref(read_uint32_t(streamByte, tempOffset + count + 2 + 2))) val index = resTable_entry.key!!.index.getValue() if (index &gt; 0 &amp;&amp; index &lt;= resInTypeStringPool_header.stringStringArray!!.stringArray.size - 1) { resTable_entry.dataStr = resInTypeStringPool_header.stringStringArray!!.stringArray[index] } count += 8 val res_value = Res_value(read_uint16_t(streamByte, tempOffset + count), read_uint8_t(streamByte, tempOffset + count + 2) , read_uint8_t(streamByte, tempOffset + count + 2 + 1), read_uint32_t(streamByte, tempOffset + count + 2 + 1 + 1)) println(&quot;--------------------------resTable_entry start------------------------------&quot;) println(resTable_entry) println(&quot;--------------------------resTable_entry end------------------------------&quot;) println(&quot;--------------------------res_value start------------------------------&quot;) println(res_value) println(&quot;--------------------------res_value end------------------------------&quot;) count += Config.RES_VALUE_SIZE } resId++ } resTypeSpecOffset += resTable_type.header.size.getValue() println(&quot;===========================================&quot;) }} &#x8FD9;&#x90E8;&#x5206;&#x89E3;&#x6790;&#x5176;&#x5B9E;&#x5F88;&#x7E41;&#x7410;&#xFF0C;&#x9996;&#x5148;ResTable_typeSpec&#x548C;ResTable_type&#x662F;&#x6210;&#x5BF9;&#x51FA;&#x73B0;&#xFF08;&#x901A;&#x8FC7;&#x73B0;&#x8C61;&#x5F97;&#x51FA;&#x7ED3;&#x8BBA;&#x3002;&#x3002;&#xFF09;&#xFF0C;ResTable_typeSpec&#x91CC;&#x9762;&#x5305;&#x62EC;&#x4E86;&#x8BE5;&#x8D44;&#x6E90;&#x9879;&#x5BF9;&#x5E94;&#x7684;id&#xFF08;&#x8FD9;&#x4E2A;id&#x5BF9;&#x5E94;&#x7684;&#x662F;&#x89E3;&#x6790;&#x8D44;&#x6E90;&#x9879;&#x7ED3;&#x679C;&#x7684;&#x7D22;&#x5F15;+1&#xFF09;&#x4EE5;&#x53CA;&#x8D44;&#x6E90;&#x9879;&#x4E2A;&#x6570;&#xFF0C;&#x63A5;&#x7740;&#x4FBF;&#x662F;&#x4E00;&#x4E2A;&#x6570;&#x7EC4;&#xFF08;&#x5177;&#x4F53;&#x7528;&#x5904;&#x4E0D;&#x8BE6;&#xFF09;&#xFF0C;&#x63A5;&#x7740;&#x4FBF;&#x662F;ResTable_type&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x5B9A;&#x4E49;&#x4E86;&#x8D44;&#x6E90;&#x7684;type id&#xFF0C;&#x8D44;&#x6E90;&#x9879;&#x503C;&#x7684;&#x603B;&#x4E2A;&#x6570;&#xFF0C;&#x5F00;&#x59CB;&#x4F4D;&#x7F6E;&#x7684;&#x504F;&#x79FB;&#x91CF;&#x4EE5;&#x53CA;&#x914D;&#x7F6E;&#x4FE1;&#x606F;&#x3002;&#x987A;&#x4FBF;&#x8BF4;&#x4E00;&#x53E5;&#xFF0C;&#x6211;&#x8FD9;&#x4E2A;&#x89E3;&#x6790;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x901A;&#x8FC7;&#x7684;&#x662F;&#x6574;&#x4F53;&#x7684;size&#x6765;&#x5224;&#x65AD;&#x662F;&#x5426;&#x89E3;&#x6790;&#x5B8C;&#x6210;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x6839;&#x636E;entryCount&#x6765;&#x5224;&#x65AD;&#xFF0C;&#x8FD9;&#x91CC;&#x548C;&#x5176;&#x4ED6;&#x89E3;&#x6790;&#x53EF;&#x80FD;&#x4F1A;&#x6709;&#x4E9B;&#x51FA;&#x5165;&#x3002;&#x89E3;&#x6790;&#x5B8C;ResTable_type&#xFF0C;&#x89E3;&#x6790;&#x5B8C;&#x6210;ResTable_type&#x8FD8;&#x9700;&#x8981;&#x6839;&#x636E;entryCount&#x6765;&#x89E3;&#x6790;&#x4E00;&#x4E2A;&#x4FBF;&#x5B9C;&#x6570;&#x7EC4;&#xFF0C;&#x63A5;&#x7740;&#x53EF;&#x4EE5;&#x6839;&#x636E;&#x540E;&#x9762;&#x89E3;&#x6790;&#x7684;flags&#x6765;&#x5224;&#x65AD;&#x8D44;&#x6E90;&#x9879;&#x7684;&#x503C;&#x662F;ResTable_entry&#x8FD8;&#x662F;ResTable_map_entry&#xFF0C;&#x5982;&#x679C;&#x662F;ResTable_entry&#x7684;&#x8BDD;&#xFF0C;&#x5219;&#x6DFB;&#x52A0;&#x5BF9;Res_value&#x7684;&#x89E3;&#x6790;&#xFF0C;&#x5982;&#x679C;&#x662F;ResTable_map_entry&#xFF0C;&#x5219;&#x6DFB;&#x52A0;&#x5BF9;ResTable_map&#x7684;&#x89E3;&#x6790;&#x3002;&#x90E8;&#x5206;&#x89E3;&#x6790;&#x7ED3;&#x679C;&#xFF1A; &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD; &#x6574;&#x4E2A;&#x89E3;&#x6790;&#x8FC7;&#x7A0B;&#x5DF2;&#x7ECF;&#x5B8C;&#x6210;&#x4E86;&#xFF0C;&#x4EE3;&#x7801;&#x8FD9;&#x91CC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x3002;&#x603B;&#x7ED3;&#x4E0B;&#xFF0C;&#x8FD8;&#x662F;&#x4E0D;&#x8981;&#x778E;&#x641E;&#x4E8B;&#x60C5;&#x554A;&#x3002;&#x672C;&#x6765;&#x81EA;&#x5DF1;&#x6709;&#x6253;&#x7B97;&#x4E00;&#x6B65;&#x6B65;&#x6765;&#x7684;&#xFF0C;&#x7ED3;&#x679C;&#x534A;&#x8DEF;&#x770B;&#x5230;&#x8FD9;&#x4E2A;&#x65AD;&#x65AD;&#x7EED;&#x7EED;&#x641E;&#x4E86;&#x4E24;&#x5468;&#x65F6;&#x95F4;&#xFF0C;&#x5176;&#x4E2D;&#x5FC3;&#x9178;&#x7684;&#x5386;&#x7A0B;&#x4E0D;&#x591A;&#x8BF4;&#x4E86;&#xFF0C;&#x4E0D;&#x65AD;&#x7684;&#x80AF;&#x5B9A;&#x81EA;&#x5DF1;&#x53C8;&#x4E0D;&#x65AD;&#x7684;&#x5426;&#x5B9A;&#x81EA;&#x5DF1;&#x3002;&#x4E0D;&#x8FC7;&#x5462;&#xFF0C;&#x6700;&#x540E;&#x7EC8;&#x4E8E;&#x7B97;&#x662F;&#x5C06;&#x4E1C;&#x897F;&#x5B8C;&#x6210;&#x4E86;&#x3002;&#x4EE5;&#x524D;&#x89C9;&#x5F97;&#x5427;&#xFF0C;&#x7AD9;&#x5728;&#x5DE8;&#x4EBA;&#x7684;&#x80A9;&#x8180;&#x4E0A;&#x770B;&#x4E16;&#x754C;&#xFF0C;&#x5F88;&#x8F7B;&#x677E;&#x3002;&#x540E;&#x6765;&#x53D1;&#x73B0;&#xFF0C;&#x5DE8;&#x4EBA;&#x7684;&#x80A9;&#x8180;&#x53EF;&#x80FD;&#x4E5F;&#x6709;&#x6F0F;&#x6D1E;&#x3002;","tags":[]},{"title":"View的测量、布局和绘制过程","date":"2017-12-13T15:58:50.542Z","path":"2017/12/13/View的测量、布局和绘制过程/","text":"&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x6309;&#x7167;&#x4E4B;&#x524D;&#x5199;&#x7684;&#x8282;&#x594F;&#x6765;&#x7684;&#x8BDD;&#xFF0C;&#x8FD9;&#x7BC7;&#x6539;&#x5BF9;View&#x7684;&#x6574;&#x4E2A;&#x6D4B;&#x91CF;&#x3001;&#x5E03;&#x5C40;&#x548C;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#x8FDB;&#x884C;&#x5206;&#x6790;&#x4E86;&#x3002;&#x5728;&#x4E4B;&#x524D;&#x7684;Activity&#x663E;&#x793A;&#x5230;Window&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x4E86;&#x89E3;&#x5230;performTraversals()&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4F1A;&#x6267;&#x884C;performMeasure()&#x53BB;&#x6D4B;&#x91CF;View&#x7684;&#x5927;&#x5C0F;&#xFF0C;performLayout()&#x53BB;&#x5C06;&#x5B50;View&#x653E;&#x5230;&#x5408;&#x9002;&#x7684;&#x4F4D;&#x7F6E;&#x4E0A;&#xFF0C;performDraw()&#x5C06;View&#x771F;&#x6B63;&#x7ED8;&#x5236;&#x51FA;&#x6765;&#x3002; 1. measure&#x7684;&#x8FC7;&#x7A0B;1.1 &#x5728;&#x6D4B;&#x91CF;&#x524D;&#xFF0C;&#x5148;&#x770B;&#x4E0B;MeasureSpecMeasureSpec&#x7406;&#x89E3;&#x4E3A;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#xFF0C;&#x4ECE;&#x6E90;&#x7801;&#x4E2D;&#x53EF;&#x4EE5;&#x77E5;&#x9053;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x5305;&#x62EC;&#x4E86;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#xFF08;SpecMode&#xFF09;&#x548C;&#x5927;&#x5C0F;&#xFF08;SpecSize&#xFF09;&#xFF0C;&#x8FD9;&#x4E2A;&#x89C4;&#x683C;&#x901A;&#x8FC7;&#x4E00;&#x4E2A;int&#x578B;&#x6765;&#x8868;&#x793A;&#x3002;&#x5176;&#x4E2D;int&#x7684;&#x9AD8;2&#x4F4D;&#x4EE3;&#x8868;&#x4E86;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#xFF0C;&#x4F4E;30&#x4F4D;&#x4EE3;&#x8868;&#x4E86;&#x5927;&#x5C0F;&#x3002;&#x6211;&#x4EEC;&#x90FD;&#x77E5;&#x9053;&#x4E24;&#x4F4D;&#x53EF;&#x4EE5;&#x6709;&#x56DB;&#x79CD;&#x7EC4;&#x5408;&#x60C5;&#x51B5;&#xFF0C;&#x800C;Android&#x4E2D;View&#x6709;&#x4E09;&#x79CD;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#xFF0C;&#x5206;&#x522B;&#x662F;&#xFF1A; UNSPECIFIED&#xFF08;0 &lt;&lt; 30&#xFF09;&#xFF1A;&#x5B50;View&#x53EF;&#x4EE5;&#x60F3;&#x8981;&#x4EFB;&#x610F;&#x5927;&#x5C0F; EXACTLY&#xFF08;1 &lt;&lt; 30&#xFF09;&#xFF1A;&#x7236;&#x5BB9;&#x5668;&#x5DF2;&#x7ECF;&#x68C0;&#x6D4B;&#x51FA;&#x5B50;View&#x6240;&#x9700;&#x8981;&#x7684;&#x7CBE;&#x786E;&#x5927;&#x5C0F;&#xFF0C;View&#x7684;&#x5927;&#x5C0F;&#x5373;&#x4E3A;SpecSize&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x4ED6;&#x5BF9;&#x5E94;&#x4E8E;&#x5E03;&#x5C40;&#x53C2;&#x6570;&#x4E2D;&#x7684;MATCH_PARENT&#xFF0C;&#x6216;&#x8005;&#x7CBE;&#x786E;&#x503C; AT_MOST&#xFF08;2 &lt;&lt; 30&#xFF09;&#xFF1A;&#x7236;&#x5BB9;&#x5668;&#x6307;&#x5B9A;&#x4E86;&#x4E00;&#x4E2A;&#x5927;&#x5C0F;&#xFF0C;&#x5373;SpecSize&#xFF0C;&#x5B50;View&#x7684;&#x5927;&#x5C0F;&#x4E0D;&#x80FD;&#x8D85;&#x8FC7;&#x8FD9;&#x4E2A;SpecSize&#x7684;&#x5927;&#x5C0F;&#x901A;&#x8FC7;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x83B7;&#x53D6;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x548C;&#x5927;&#x5C0F;&#xFF1A;123456789101112private static final int MODE_SHIFT = 30;private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;// &#x83B7;&#x5F97;SpecMode@MeasureSpecModepublic static int getMode(int measureSpec) { return (measureSpec &amp; MODE_MASK);}// &#x83B7;&#x5F97;SpecSizepublic static int getSize(int measureSpec) { return (measureSpec &amp; ~MODE_MASK);} &#x4ECE;&#x4E0A;&#x9762;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x83B7;&#x5F97;SpecMode&#x65F6;&#xFF0C;&#x9700;&#x8981;&#x548C;MODE_MASK&#xFF08;0x30000000&#xFF09;&#x8FDB;&#x884C;&#x4E0E;&#x8FD0;&#x7B97;&#xFF0C;&#x56E0;&#x4E3A;&#x4F4E;30&#x4F4D;&#x5168;&#x4E3A;0&#xFF0C;&#x9AD8;2&#x4F4D;&#x90FD;&#x4E3A;1&#xFF0C;&#x6240;&#x4EE5;&#x6700;&#x7EC8;&#x7684;&#x7ED3;&#x679C;&#x5C31;&#x662F;&#x9AD8;2&#x4F4D;&lt;&lt;30&#x7684;&#x503C;&#xFF0C;&#x4E5F;&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x4E09;&#x4E2A;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x4E2D;&#x7684;&#x4E00;&#x4E2A;&#x3002;&#x540C;&#x7406;&#xFF0C;&#x5728;&#x83B7;&#x5F97;SpecSize&#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5C06;SpecMode&#x53BB;&#x9664;&#xFF0C;&#x83B7;&#x5F97;&#x4F4E;30&#x4F4D;&#x7684;&#x503C;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x91CC;&#x8FDB;&#x884C;&#x7684;&#x662F;&#x4E0E;&#x4E0A;&#x975E;MODE_MASK&#x8FD0;&#x7B97;&#xFF0C;&#x5373;&#x83B7;&#x53D6;&#x4F4E;30&#x4F4D;&#x7684;&#x503C;&#xFF08;SpecSize&#xFF09;&#x3002; 1.2 getRootMeasureSpec&#x65B9;&#x6CD5;&#x5728;&#x6267;&#x884C;performMeasure()&#x65B9;&#x6CD5;&#x524D;&#xFF0C;&#x4F1A;&#x6267;&#x884C;ViewRootImpl&#x4E2D;&#x7684;getRootMeasureSpec&#x65B9;&#x6CD5;&#xFF0C;&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x6765;&#x83B7;&#x5F97;&#x8DDF;&#x5E03;&#x5C40;&#x7684;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x3002;123456789101112131415161718192021222324252627// mWidth&#x548C;mHeight&#x7684;&#x503C;&#x662F;&#x901A;&#x8FC7;//if (mWidth != frame.width() || mHeight != frame.height()) {//mWidth = frame.width();//mHeight = frame.height();//}//&#x8D4B;&#x503C;&#xFF0C;&#x8FD9;&#x91CC;&#x7B49;&#x4E8E;Window&#x7A97;&#x53E3;&#x7684;&#x5BBD;&#x9AD8;int childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);int childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);private static int getRootMeasureSpec(int windowSize, int rootDimension) { int measureSpec; switch (rootDimension) { //rootDimension&#x662F;decorView&#x7684;params&#x7684;&#x53C2;&#x6570;&#xFF0C;&#x8FD9;&#x91CC;&#x4E3A;MATCH_PARENT&#xFF0C;&#x6240;&#x4EE5;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x662F;EXACTLY case ViewGroup.LayoutParams.MATCH_PARENT: // Window can&apos;t resize. Force root view to be windowSize. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY); break; case ViewGroup.LayoutParams.WRAP_CONTENT: // Window can resize. Set max size for root view. measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST); break; default: // Window wants to be an exact size. Force root view to be that size. measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY); break; } return measureSpec;} 1.3 View&#x7684;measure&#x65B9;&#x6CD5;&#x5728;&#x83B7;&#x5F97;&#x4E86;&#x5BBD;&#x9AD8;&#x7684;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x540E;&#xFF0C;&#x5C06;&#x4F1A;&#x6267;&#x884C;performMeasure()&#x65B9;&#x6CD5;&#xFF0C;performMeasure()&#x65B9;&#x6CD5;&#x4F1A;&#x8C03;&#x7528;DecorView&#x7684;measure()&#x65B9;&#x6CD5;&#xFF0C;DecorView&#x548C;&#x5176;&#x7236;&#x7C7B;&#x5E76;&#x6CA1;&#x6709;&#x91CD;&#x5199;&#x8FD9;&#x4E2A;measure&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x7EC8;&#x4F1A;&#x8C03;&#x7528;View&#x7684;measure&#x65B9;&#x6CD5;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public final void measure(int widthMeasureSpec, int heightMeasureSpec) { //&#x5224;&#x65AD;&#x5F53;&#x524D;View&#x7684;layoutMode&#x662F;&#x4E0D;&#x662F;LAYOUT_MODE_OPTICAL_BOUNDS&#xFF0C;&#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x5F88;&#x5C11; boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int oWidth = insets.left + insets.right; int oHeight = insets.top + insets.bottom; widthMeasureSpec = MeasureSpec.adjust(widthMeasureSpec, optical ? -oWidth : oWidth); heightMeasureSpec = MeasureSpec.adjust(heightMeasureSpec, optical ? -oHeight : oHeight); } // &#x4F5C;&#x4E3A;&#x7F13;&#x5B58;&#x7684;key // Suppress sign extension for the low bytes long key = (long) widthMeasureSpec &lt;&lt; 32 | (long) heightMeasureSpec &amp; 0xffffffffL; if (mMeasureCache == null) mMeasureCache = new LongSparseLongArray(2); final boolean forceLayout = (mPrivateFlags &amp; PFLAG_FORCE_LAYOUT) == PFLAG_FORCE_LAYOUT; // Optimize layout by avoiding an extra EXACTLY pass when the view is // already measured as the correct size. In API 23 and below, this // extra pass is required to make LinearLayout re-distribute weight. final boolean specChanged = widthMeasureSpec != mOldWidthMeasureSpec || heightMeasureSpec != mOldHeightMeasureSpec; final boolean isSpecExactly = MeasureSpec.getMode(widthMeasureSpec) == MeasureSpec.EXACTLY &amp;&amp; MeasureSpec.getMode(heightMeasureSpec) == MeasureSpec.EXACTLY; final boolean matchesSpecSize = getMeasuredWidth() == MeasureSpec.getSize(widthMeasureSpec) &amp;&amp; getMeasuredHeight() == MeasureSpec.getSize(heightMeasureSpec); final boolean needsLayout = specChanged &amp;&amp; (sAlwaysRemeasureExactly || !isSpecExactly || !matchesSpecSize); // &#x9700;&#x8981;&#x5E03;&#x5C40; if (forceLayout || needsLayout) { // first clears the measured dimension flag mPrivateFlags &amp;= ~PFLAG_MEASURED_DIMENSION_SET; resolveRtlPropertiesIfNeeded(); // &#x5982;&#x679C;&#x662F;&#x5F3A;&#x5236;&#x5E03;&#x5C40;&#x7684;&#x8BDD;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x53BB;&#x8C03;&#x7528;onMeasure&#x65B9;&#x6CD5;&#xFF0C;&#x5426;&#x5219;&#x53BB;&#x7F13;&#x5B58;&#x4E2D;&#x83B7;&#x53D6; int cacheIndex = forceLayout ? -1 : mMeasureCache.indexOfKey(key); if (cacheIndex &lt; 0 || sIgnoreMeasureCache) { // measure ourselves, this should set the measured dimension flag back onMeasure(widthMeasureSpec, heightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } else { long value = mMeasureCache.valueAt(cacheIndex); // Casting a long to int drops the high 32 bits, no mask needed setMeasuredDimensionRaw((int) (value &gt;&gt; 32), (int) value); mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } // flag not set, setMeasuredDimension() was not invoked, we raise // an exception to warn the developer if ((mPrivateFlags &amp; PFLAG_MEASURED_DIMENSION_SET) != PFLAG_MEASURED_DIMENSION_SET) { throw new IllegalStateException(&quot;View with id &quot; + getId() + &quot;: &quot; + getClass().getName() + &quot;#onMeasure() did not set the&quot; + &quot; measured dimension by calling&quot; + &quot; setMeasuredDimension()&quot;); } mPrivateFlags |= PFLAG_LAYOUT_REQUIRED; } mOldWidthMeasureSpec = widthMeasureSpec; mOldHeightMeasureSpec = heightMeasureSpec; // &#x653E;&#x5230;&#x7F13;&#x5B58;&#x4E2D; mMeasureCache.put(key, ((long) mMeasuredWidth) &lt;&lt; 32 | (long) mMeasuredHeight &amp; 0xffffffffL); // suppress sign extension}// onMeasure&#x4E2D;&#x9700;&#x8981;&#x53BB;&#x8BBE;&#x7F6E;&#x6D4B;&#x91CF;&#x7684;&#x7ED3;&#x679C;&#xFF0C;View&#x7684;&#x9ED8;&#x8BA4;&#x5B9E;&#x73B0;&#x662F;&#x8BBE;&#x7F6E;&#x9ED8;&#x8BA4;&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x8FD9;&#x4E2A;&#x5927;&#x5C0F;&#x6839;&#x636E;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x6765;&#x786E;&#x5B9A;// &#x5982;&#x679C;&#x662F;UNSPECIFIED&#xFF1A;&#x672A;&#x6307;&#x5B9A;&#x7684;&#x8BDD;&#x5219;&#x5927;&#x5C0F;&#x4E3A;&#x5EFA;&#x8BAE;&#x7684;&#x6700;&#x5C0F;&#x503C;// &#x5982;&#x679C;&#x662F;AT_MOST||EXACTLY&#xFF0C;&#x90A3;&#x4E48;&#x8FD4;&#x56DE;&#x503C;&#x4E3A;SpecSizeprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));}protected final void setMeasuredDimension(int measuredWidth, int measuredHeight) { boolean optical = isLayoutModeOptical(this); if (optical != isLayoutModeOptical(mParent)) { Insets insets = getOpticalInsets(); int opticalWidth = insets.left + insets.right; int opticalHeight = insets.top + insets.bottom; measuredWidth += optical ? opticalWidth : -opticalWidth; measuredHeight += optical ? opticalHeight : -opticalHeight; } // &#x771F;&#x6B63;&#x4E3A;mMeasuredWidth&#x548C;mMeasuredHeight&#x8D4B;&#x503C; setMeasuredDimensionRaw(measuredWidth, measuredHeight);}// &#x4E3A;mMeasuredWidth&#x548C;mMeasuredHeight&#x8D4B;&#x503C;private void setMeasuredDimensionRaw(int measuredWidth, int measuredHeight) { mMeasuredWidth = measuredWidth; mMeasuredHeight = measuredHeight; mPrivateFlags |= PFLAG_MEASURED_DIMENSION_SET;} &#x4ECE;&#x4EE3;&#x7801;&#x4E2D;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x5E03;&#x5C40;&#x7684;&#x8BDD;&#xFF0C;&#x9996;&#x5148;&#x5224;&#x65AD;&#x662F;&#x5426;&#x4E3A;&#x5F3A;&#x5236;&#x5E03;&#x5C40;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;&#x7684;&#x8BDD;&#x83B7;&#x5F97;mMeasureCache&#x4E2D;&#x5F53;&#x524D;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x7684;&#x4F4D;&#x7F6E;&#x3002;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x8FD9;&#x4E2A;&#x7F13;&#x5B58;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x9700;&#x8981;&#x53BB;&#x8FDB;&#x884C;onMeasure&#x65B9;&#x6CD5;&#x53BB;&#x6D4B;&#x91CF;&#x771F;&#x6B63;&#x7684;&#x5BBD;&#x9AD8;&#xFF0C;&#x6700;&#x540E;&#x5C06;&#x5F53;&#x524D;&#x5BBD;&#x9AD8;&#x7684;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x4FDD;&#x5B58;&#x5230;&#x7F13;&#x5B58;&#x4E2D;&#x3002;&#x5728;&#x8C03;&#x7528;View&#x7684;onMeasure&#x65B9;&#x6CD5;&#x65F6;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x8C03;&#x7528;setMeasuredDimension&#x65B9;&#x6CD5;&#x6765;&#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x7684;&#x5BBD;&#x9AD8;&#xFF0C;&#x5F53;&#x8C03;&#x7528;&#x4E86;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x540E;&#xFF0C;&#x4F1A;&#x901A;&#x8FC7;setMeasuredDimensionRaw&#x65B9;&#x6CD5;&#x6765;&#x7ED9;mMeasuredWidth&#x548C;mMeasuredHeight&#x8D4B;&#x503C;&#xFF0C;&#x8FD9;&#x6837;&#x6211;&#x4EEC;&#x901A;&#x8FC7;getMeasuredWidthAndState()&#x83B7;&#x53D6;mMeasuredWidth&#x503C;&#x6216;&#x8005;&#x901A;&#x8FC7;getMeasuredWidth()&#x6765;&#x83B7;&#x53D6;mMeasuredWidth &amp; MEASURED_SIZE_MASK(0x00ffffff)&#x503C;&#x3002;&#x4E0A;&#x9762;&#x5199;&#x5230;&#x7684;&#x90FD;&#x662F;View&#x91CC;&#x9762;&#x5173;&#x4E8E;&#x6D4B;&#x91CF;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x4ECE;&#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x5C31;&#x770B;&#x51FA;&#x6765;&#x4E86;&#xFF0C;View&#x7684;&#x6D4B;&#x91CF;&#x786E;&#x5B9A;&#x4E86;View&#x7684;&#x56DB;&#x4E2A;&#x70B9;&#x7684;&#x4F4D;&#x7F6E;&#x4EE5;&#x53CA;&#x6D4B;&#x91CF;&#x7684;&#x5BBD;&#x9AD8;&#x3002;ViewGroup&#x4F5C;&#x4E3A;View&#x7684;&#x5B50;&#x7C7B;&#xFF0C;&#x5176;&#x5E76;&#x6CA1;&#x6709;&#x91CD;&#x5199;onMeasure&#x65B9;&#x6CD5;&#xFF0C;&#x4F5C;&#x4E3A;ViewGroup&#x7684;&#x5B50;&#x7C7B;&#x57FA;&#x672C;&#x4E0A;&#x90FD;&#x4F1A;&#x91CD;&#x5199;onMeasure&#x65B9;&#x6CD5;&#xFF0C;&#x901A;&#x8FC7;onMeasure&#x65B9;&#x6CD5;&#x6765;&#x6D4B;&#x91CF;&#x5B50;View&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x901A;&#x8FC7;&#x5B50;View&#x7684;&#x5927;&#x5C0F;&#x6700;&#x7EC8;&#x6765;&#x786E;&#x5B9A;&#x81EA;&#x5DF1;&#x7684;&#x5927;&#x5C0F;&#x3002;&#x4E0B;&#x9762;&#x662F;FrameLayout&#x7684;&#x6D4B;&#x91CF;&#x8FC7;&#x7A0B;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219FrameLayout.java@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { int count = getChildCount(); // &#x5982;&#x679C;&#x5F53;&#x524D;&#x7684;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x4E0D;&#x662F;EXACTLY&#xFF0C;&#x5219;&#x9700;&#x8981;&#x7EDF;&#x8BA1;&#x62E5;&#x6709;MATCH_PARENT&#x5C5E;&#x6027;&#x7684;&#x5B50;View // &#x5728;&#x8BBE;&#x7F6E;&#x5B8C;&#x6210;&#x5F53;&#x524D;layout&#x7684;&#x5BBD;&#x9AD8;&#x540E;&#xFF0C;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x6D4B;&#x91CF;&#x62E5;&#x6709;MATCH_PARENT&#x5C5E;&#x6027;&#x7684;&#x5B50;View final boolean measureMatchParentChildren = MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY || MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY; mMatchParentChildren.clear(); int maxHeight = 0; int maxWidth = 0; int childState = 0; for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); // &#x5982;&#x679C;&#x5B50;View&#x4E0D;&#x662F;&#x9690;&#x85CF;&#x72B6;&#x6001;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x6D4B;&#x91CF; if (mMeasureAllChildren || child.getVisibility() != GONE) { // &#x6D4B;&#x91CF;&#x5B50;View measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0); final LayoutParams lp = (LayoutParams) child.getLayoutParams(); // &#x8BBE;&#x7F6E;&#x6700;&#x5927;&#x5BBD;&#x5EA6;&#xFF0C;&#x6BCF;&#x4E2A;&#x5B50;View&#x548C;&#x5F53;&#x524D;&#x7684;&#x6700;&#x5927;&#x5BBD;&#x5EA6;&#x8FDB;&#x884C;&#x6BD4;&#x8F83; maxWidth = Math.max(maxWidth, child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin); maxHeight = Math.max(maxHeight, child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin); childState = combineMeasuredStates(childState, child.getMeasuredState()); if (measureMatchParentChildren) { if (lp.width == LayoutParams.MATCH_PARENT || lp.height == LayoutParams.MATCH_PARENT) { mMatchParentChildren.add(child); } } } } // Account for padding too maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground(); maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground(); // Check against our minimum height and width maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight()); maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth()); // Check against our foreground&apos;s minimum height and width final Drawable drawable = getForeground(); if (drawable != null) { maxHeight = Math.max(maxHeight, drawable.getMinimumHeight()); maxWidth = Math.max(maxWidth, drawable.getMinimumWidth()); } // &#x4E3A;&#x5F53;&#x524D;layout&#x8BBE;&#x7F6E;&#x5BBD;&#x9AD8; setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState), resolveSizeAndState(maxHeight, heightMeasureSpec, childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT)); // &#x5982;&#x679C;&#x6709;MATCH_PARENT&#x5C5E;&#x6027;&#x7684;&#x5B50;View&#x5927;&#x4E8E;1&#x7684;&#x8BDD;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x53BB;&#x6D4B;&#x91CF;&#x8FD9;&#x4E9B;&#x5B50;View count = mMatchParentChildren.size(); if (count &gt; 1) { for (int i = 0; i &lt; count; i++) { final View child = mMatchParentChildren.get(i); final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec; if (lp.width == LayoutParams.MATCH_PARENT) { final int width = Math.max(0, getMeasuredWidth() - getPaddingLeftWithForeground() - getPaddingRightWithForeground() - lp.leftMargin - lp.rightMargin); childWidthMeasureSpec = MeasureSpec.makeMeasureSpec( width, MeasureSpec.EXACTLY); } else { childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec, getPaddingLeftWithForeground() + getPaddingRightWithForeground() + lp.leftMargin + lp.rightMargin, lp.width); } final int childHeightMeasureSpec; if (lp.height == LayoutParams.MATCH_PARENT) { final int height = Math.max(0, getMeasuredHeight() - getPaddingTopWithForeground() - getPaddingBottomWithForeground() - lp.topMargin - lp.bottomMargin); childHeightMeasureSpec = MeasureSpec.makeMeasureSpec( height, MeasureSpec.EXACTLY); } else { childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec, getPaddingTopWithForeground() + getPaddingBottomWithForeground() + lp.topMargin + lp.bottomMargin, lp.height); } child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } }}ViewGroup.javaprotected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); // &#x4E24;&#x4E2A;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x90FD;&#x6709;&#x4E86;&#xFF0C;&#x63A5;&#x7740;&#x901A;&#x8FC7;child.measure&#x53BB;&#x6D4B;&#x91CF;&#x81EA;&#x8EAB;&#x5927;&#x5C0F; child.measure(childWidthMeasureSpec, childHeightMeasureSpec);}ViewGroup.javapublic static int getChildMeasureSpec(int spec, int padding, int childDimension) { int specMode = MeasureSpec.getMode(spec); int specSize = MeasureSpec.getSize(spec); int size = Math.max(0, specSize - padding); int resultSize = 0; int resultMode = 0; switch (specMode) { // EXACTLY&#x5982;&#x679C;&#x662F;&#x7CBE;&#x786E;&#x5927;&#x5C0F;&#x7684;&#x8BDD;&#xFF0C;&#x5219;&#x6839;&#x636E;child&#x7684;&#x5927;&#x5C0F;&#x6765;&#x8BA1;&#x7B97;&#x5177;&#x4F53;&#x5927;&#x5C0F; // Parent has imposed an exact size on us case MeasureSpec.EXACTLY: if (childDimension &gt;= 0) { // &#x5982;&#x679C;&#x8BBE;&#x7F6E;&#x6709;&#x5177;&#x4F53;&#x503C;&#xFF0C;&#x5219;&#x7ED3;&#x679C;&#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x503C;&#xFF0C;&#x6A21;&#x5F0F;&#x4E3A;EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size. So be it. // MATCH_PARENT&#x5219;&#x8BBE;&#x7F6E;&#x7236;View&#x7684;&#x5927;&#x5C0F;&#xFF0C;&#x6A21;&#x5F0F;&#x4E3A;EXACTLY resultSize = size; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&apos;t be // bigger than us. // &#x7ED3;&#x679C;&#x8BBE;&#x7F6E;&#x6210;&#x7236;View&#x5927;&#x5C0F;&#xFF0C;&#x5E76;&#x4E14;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x8BBE;&#x7F6E;&#x6210;AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // AT_MOST&#x6A21;&#x5F0F; // Parent has imposed a maximum size on us case MeasureSpec.AT_MOST: if (childDimension &gt;= 0) { // Child wants a specific size... so be it // &#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x5927;&#x5C0F;&#xFF0C;&#x5E76;&#x4E14;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x662F;EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size, but our size is not fixed. // Constrain child to not be bigger than us. // &#x8BBE;&#x7F6E;&#x6210;&#x7236;View&#x5927;&#x5C0F;&#xFF0C;&#x5E76;&#x4E14;&#x6A21;&#x5F0F;&#x662F;AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size. It can&apos;t be // bigger than us. // &#x8BBE;&#x7F6E;&#x6210;&#x7236;View&#x5927;&#x5C0F;&#xFF0C;&#x5E76;&#x4E14;&#x6A21;&#x5F0F;&#x662F;AT_MOST resultSize = size; resultMode = MeasureSpec.AT_MOST; } break; // UNSPECIFIED&#x6A21;&#x5F0F; // Parent asked to see how big we want to be case MeasureSpec.UNSPECIFIED: if (childDimension &gt;= 0) { // Child wants a specific size... let him have it // &#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x5927;&#x5C0F;&#xFF0C;&#x5E76;&#x4E14;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x662F;EXACTLY resultSize = childDimension; resultMode = MeasureSpec.EXACTLY; } else if (childDimension == LayoutParams.MATCH_PARENT) { // Child wants to be our size... find out how big it should // be // sUseZeroUnspecifiedMeasureSpec = targetSdkVersion &lt; M // &#x901A;&#x8FC7;targetSdkVersion&#x6765;&#x5224;&#x65AD;size&#x8BBE;&#x7F6E;&#x4E3A;0&#x8FD8;&#x662F;&#x7236;View&#x7684;size&#xFF0C;&#x5E76;&#x4E14;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x8BBE;&#x7F6E;UNSPECIFIED resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } else if (childDimension == LayoutParams.WRAP_CONTENT) { // Child wants to determine its own size.... find out how // big it should be // &#x901A;&#x8FC7;targetSdkVersion&#x6765;&#x5224;&#x65AD;size&#x8BBE;&#x7F6E;&#x4E3A;0&#x8FD8;&#x662F;&#x7236;View&#x7684;size&#xFF0C;&#x5E76;&#x4E14;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x8BBE;&#x7F6E;UNSPECIFIED resultSize = View.sUseZeroUnspecifiedMeasureSpec ? 0 : size; resultMode = MeasureSpec.UNSPECIFIED; } break; } //noinspection ResourceType return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}View.java// &#x8FD9;&#x4E2A;&#x6211;&#x7684;&#x7406;&#x89E3;&#x662F;&#x89E3;&#x6790;size&#x5E76;&#x4F7F;&#x8FD9;&#x4E2A;size&#x62E5;&#x6709;&#x4E00;&#x4E2A;&#x72B6;&#x6001;public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) { final int specMode = MeasureSpec.getMode(measureSpec); final int specSize = MeasureSpec.getSize(measureSpec); final int result; switch (specMode) { // &#x5982;&#x679C;&#x662F;AT_MOST&#x6A21;&#x5F0F;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x5224;&#x65AD;&#x9700;&#x8981;&#x7684;size&#x548C;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x7684;SpecSize&#x7684;&#x5927;&#x5C0F; // &#x5982;&#x679C;&#x9700;&#x8981;&#x7684;size&gt;SpecSize&#xFF0C;&#x90A3;&#x4E48;&#x4F7F;&#x7528;SpecSize&#xFF0C;&#x5E76;&#x4E14;&#x8BBE;&#x7F6E;&#x6807;&#x5FD7;&#x4F4D;&#x4E3A;MEASURED_STATE_TOO_SMALL = 0x01000000 // &#x8FD9;&#x4E2A;&#x6807;&#x5FD7;&#x4E3A;&#x4EE3;&#x8868;&#x4E86;&#x5F53;&#x524D;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x7684;&#x5927;&#x5C0F;&#x5C0F;&#x4E8E;&#x6240;&#x9700;&#x5927;&#x5C0F; case MeasureSpec.AT_MOST: if (specSize &lt; size) { result = specSize | MEASURED_STATE_TOO_SMALL; } else { result = size; } break; // &#x5982;&#x679C;&#x6D4B;&#x91CF;&#x6A21;&#x5F0F;&#x662F;EXACTLY&#xFF0C;&#x90A3;&#x4E48;&#x8FD9;&#x4E2A;&#x7ED3;&#x679C;&#x5C31;&#x662F;specSize case MeasureSpec.EXACTLY: result = specSize; break; // &#x5176;&#x4ED6;&#x60C5;&#x51B5;&#x90FD;&#x662F;&#x6240;&#x9700;&#x7684;size case MeasureSpec.UNSPECIFIED: default: result = size; } //MEASURED_STATE_MASK = 0xff000000&#xFF0C;&#x8FD9;&#x91CC;&#x7684;&#x7ED3;&#x679C;&#x90FD;&#x5E26;&#x6709;&#x4E00;&#x4E2A;&#x72B6;&#x6001;&#xFF0C;&#x8FD9;&#x4E2A;&#x72B6;&#x6001;&#x7684;&#x7528;&#x5904;&#x4E0D;&#x8BE6;&#x3002;&#x3002;&#x3002; return result | (childMeasuredState &amp; MEASURED_STATE_MASK);} &#x4ECE;&#x4E0A;&#x9762;FrameLayout&#x7684;&#x6D4B;&#x91CF;&#x8FC7;&#x7A0B;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x6574;&#x4E2A;&#x6D41;&#x7A0B;&#x5982;&#x4E0B;&#xFF1A;&#x6D4B;&#x91CF;&#x8FC7;&#x7A0B;&#xFF1A; FrameLayout&#x8C03;&#x7528;onMeasure&#x65B9;&#x6CD5;&#xFF0C;&#x5F00;&#x59CB;&#x6D4B;&#x91CF; FrameLayout&#x7684;onMeasure&#x65B9;&#x6CD5;&#x4E2D;&#x8C03;&#x7528;&#x4E86;&#x5176;&#x7236;&#x7C7B;&#x7684;measureChildWithMargins&#x65B9;&#x6CD5;&#x53BB;&#x6D4B;&#x91CF;&#x5B50;View&#x7684;&#x5927;&#x5C0F; measureChildWithMargins&#x901A;&#x8FC7;getChildMeasureSpec&#x65B9;&#x6CD5;&#x83B7;&#x5F97;&#x5B50;View&#x7684;&#x6D4B;&#x91CF;&#x89C4;&#x683C;&#x540E;&#x8C03;&#x7528;&#x5B50;View&#x7684;measure&#x65B9;&#x6CD5; &#x5B50;View&#x901A;&#x8FC7;&#x8C03;&#x7528;onMeasure&#x65B9;&#x6CD5;&#x6700;&#x7EC8;&#x901A;&#x8FC7;setMeasuredDimension&#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x7684;&#x6D4B;&#x91CF;&#x540E;&#x7684;&#x5BBD;&#x9AD8; FrameLayout&#x5728;&#x83B7;&#x5F97;&#x6240;&#x6709;&#x5B50;View&#x7684;&#x7ED3;&#x679C;&#x540E;&#xFF0C;&#x83B7;&#x53D6;&#x5176;&#x4E2D;&#x7684;&#x6700;&#x5927;&#x503C;&#xFF0C;&#x5E76;&#x4E14;&#x5982;&#x679C;&#x6709;&#x80CC;&#x666F;&#x56FE;&#x7684;&#x8BDD;&#xFF0C;&#x83B7;&#x53D6;&#x5B50;View&#x548C;&#x80CC;&#x666F;&#x56FE;&#x7684;&#x6700;&#x5927;&#x503C;&#xFF0C;&#x540C;&#x6837;&#x901A;&#x8FC7;setMeasuredDimension&#x8BBE;&#x7F6E;FrameLayout&#x7684;&#x5927;&#x5C0F; 2. layout&#x8FC7;&#x7A0B;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;measure&#x4E4B;&#x540E;&#x5C31;&#x4F1A;&#x8FDB;&#x884C;layout&#x8FC7;&#x7A0B;&#x3002;layout&#x5176;&#x5B9E;&#x5C31;&#x662F;&#x5BF9;View&#x7684;left&#x3001;top&#x3001;right&#x3001;bottom&#x8FD9;&#x56DB;&#x4E2A;&#x70B9;&#x4F4D;&#x7F6E;&#x7684;&#x786E;&#x5B9A;&#x7684;&#x8FC7;&#x7A0B;&#x3002;&#x4ECE;&#x6E90;&#x7801;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;View&#x4E2D;&#x5B9E;&#x73B0;&#x4E86;layout&#x65B9;&#x6CD5;&#xFF0C;ViewGroup&#x5BF9;&#x5176;&#x8FDB;&#x884C;&#x4E86;Override&#xFF0C;&#x4F46;&#x662F;ViewGroup&#x4F1A;&#x8C03;&#x7528;super.layout(l, t, r, b)&#xFF0C;&#x6240;&#x4EE5;&#x6700;&#x7EC8;&#x8FD8;&#x662F;&#x8FDB;&#x5165;View&#x7684;layout&#x65B9;&#x6CD5;&#x3002;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x5728;ViewGroup&#x4E2D;onLayout&#x662F;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x5C31;&#x610F;&#x5473;&#x7740;&#x6240;&#x6709;&#x7684;&#x5B50;&#x7C7B;&#x9700;&#x8981;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x62BD;&#x8C61;&#x65B9;&#x6CD5;&#x3002;&#x4E00;&#x822C;&#x6765;&#x8BF4;&#xFF0C;&#x6BCF;&#x4E2A;&#x4E0D;&#x540C;&#x7684;layout&#x90FD;&#x6709;&#x4E0D;&#x540C;&#x7684;&#x5B9E;&#x73B0;&#xFF0C;&#x8FD9;&#x6837;&#x5C31;&#x6784;&#x6210;&#x4E86;&#x6211;&#x4EEC;Android&#x5404;&#x79CD;&#x5E03;&#x5C40;&#x3002;&#x5F53;&#x7136;&#x4E86;&#xFF0C;&#x81EA;&#x5B9A;&#x4E49;&#x63A7;&#x4EF6;&#x4E2D;&#x5173;&#x4E8E;onLayout&#x7684;&#x5B9E;&#x73B0;&#x4E5F;&#x662F;&#x5F88;&#x91CD;&#x8981;&#x7684;&#x3002;&#x4E0B;&#x9762;&#x8FD8;&#x662F;&#x5173;&#x4E8E;FrameLayout&#x7684;layout&#x7684;&#x5B9E;&#x73B0;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184View.javapublic void layout(int l, int t, int r, int b) { // mPrivateFlags3&#x7684;&#x8D4B;&#x503C;&#x662F;&#x5728;measure&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x591A;&#x6B21;&#x6D4B;&#x91CF;&#x662F;&#x5728;&#x4E0D;&#x662F;&#x5F3A;&#x5236;layout&#x5E76;&#x4E14;&#x6709;&#x7F13;&#x5B58;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x8FDB;&#x884C;&#x8D4B;&#x503C;&#x7684; // &#x8FD9;&#x79CD;&#x60C5;&#x51B5;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x8C03;&#x7528;onMeasure&#x65B9;&#x6CD5;&#xFF0C;&#x5BF9;View&#x91CD;&#x65B0;&#x8BBE;&#x7F6E;&#x5927;&#x5C0F; if ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != 0) { onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec); mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT; } int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; // &#x662F;&#x5426;&#x4F7F;&#x7528;&#x89C6;&#x89C9;&#x8FB9;&#x754C;&#x5E03;&#x5C40;&#x6548;&#x679C;&#xFF0C;&#x8FD9;&#x4E2A;&#x5E76;&#x4E0D;&#x5F71;&#x54CD;&#x8FD9;&#x4E2A;&#x6D41;&#x7A0B;&#xFF0C;&#x56E0;&#x4E3A;setOpticalFrame&#x4E5F;&#x4F1A;&#x8C03;&#x7528;setFrame&#x65B9;&#x6CD5; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); // &#x5982;&#x679C;&#x6709;&#x6539;&#x53D8;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x5E03;&#x5C40; if (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { // &#x8C03;&#x7528;onLayout&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x5E03;&#x5C40; onLayout(changed, l, t, r, b); if (shouldDrawRoundScrollbar()) { if(mRoundScrollbarRenderer == null) { mRoundScrollbarRenderer = new RoundScrollbarRenderer(this); } } else { mRoundScrollbarRenderer = null; } mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED; // &#x8C03;&#x7528;OnLayoutChangeListener&#x7684;onLayoutChange&#x65B9;&#x6CD5; ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnLayoutChangeListeners != null) { ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy = (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone(); int numListeners = listenersCopy.size(); for (int i = 0; i &lt; numListeners; ++i) { listenersCopy.get(i).onLayoutChange(this, l, t, r, b, oldL, oldT, oldR, oldB); } } } mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT; mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;}View.java// &#x8FD4;&#x56DE;&#x503C;&#x662F;boolean&#xFF0C;&#x4EE3;&#x8868;&#x662F;&#x5426;&#x4F4D;&#x7F6E;&#x6539;&#x53D8;&#x4E86;&#xFF0C;&#x5982;&#x679C;&#x548C;&#x4EE5;&#x524D;&#x7684;&#x4F4D;&#x7F6E;&#x4E0D;&#x540C;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x6539;&#x53D8;&#x4E86;&#xFF0C;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x5E03;&#x5C40;protected boolean setFrame(int left, int top, int right, int bottom) { boolean changed = false; // &#x5982;&#x679C;&#x548C;&#x4EE5;&#x524D;&#x7684;&#x4F4D;&#x7F6E;&#x4E0D;&#x540C;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x6539;&#x53D8;&#x4E86;&#xFF0C;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x5E03;&#x5C40; if (mLeft != left || mRight != right || mTop != top || mBottom != bottom) { changed = true; // Remember our drawn bit int drawn = mPrivateFlags &amp; PFLAG_DRAWN; int oldWidth = mRight - mLeft; int oldHeight = mBottom - mTop; int newWidth = right - left; int newHeight = bottom - top; // &#x539F;&#x5BBD;&#x9AD8;&#x548C;&#x65B0;&#x5BBD;&#x9AD8;&#x5982;&#x679C;&#x4E0D;&#x4E00;&#x81F4;&#xFF0C;&#x5219;&#x8BF4;&#x660E;&#x5C3A;&#x5BF8;&#x6539;&#x53D8;&#x4E86; boolean sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight); // &#x4F7F;&#x6211;&#x4EEC;&#x65E7;&#x7684;&#x4F4D;&#x7F6E;&#x65E0;&#x6548; // Invalidate our old position invalidate(sizeChanged); mLeft = left; mTop = top; mRight = right; mBottom = bottom; mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom); mPrivateFlags |= PFLAG_HAS_BOUNDS; // &#x5982;&#x679C;&#x5C3A;&#x5BF8;&#x6539;&#x53D8;&#x4E86;&#xFF0C;&#x8C03;&#x7528;sizeChange&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x4F1A;&#x8C03;&#x7528;onSizeChanged&#x65B9;&#x6CD5; if (sizeChanged) { sizeChange(newWidth, newHeight, oldWidth, oldHeight); } if ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != null) { // If we are visible, force the DRAWN bit to on so that // this invalidate will go through (at least to our parent). // This is because someone may have invalidated this view // before this call to setFrame came in, thereby clearing // the DRAWN bit. mPrivateFlags |= PFLAG_DRAWN; invalidate(sizeChanged); // parent display list may need to be recreated based on a change in the bounds // of any child invalidateParentCaches(); } // Reset drawn bit to original value (invalidate turns it off) mPrivateFlags |= drawn; mBackgroundSizeChanged = true; if (mForegroundInfo != null) { mForegroundInfo.mBoundsChanged = true; } notifySubtreeAccessibilityStateChangedIfNeeded(); } return changed;}FrameLayout.java@Overrideprotected void onLayout(boolean changed, int left, int top, int right, int bottom) { layoutChildren(left, top, right, bottom, false /* no force left gravity */);}FrameLayout.javavoid layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity) { final int count = getChildCount(); // &#x83B7;&#x5F97;&#x5F53;&#x524D;View&#x7684;&#x56DB;&#x4E2A;&#x53EF;&#x5E03;&#x5C40;&#x7684;&#x70B9; final int parentLeft = getPaddingLeftWithForeground(); final int parentRight = right - left - getPaddingRightWithForeground(); final int parentTop = getPaddingTopWithForeground(); final int parentBottom = bottom - top - getPaddingBottomWithForeground(); for (int i = 0; i &lt; count; i++) { final View child = getChildAt(i); if (child.getVisibility() != GONE) { final LayoutParams lp = (LayoutParams) child.getLayoutParams(); final int width = child.getMeasuredWidth(); final int height = child.getMeasuredHeight(); int childLeft; int childTop; int gravity = lp.gravity; if (gravity == -1) { gravity = DEFAULT_CHILD_GRAVITY; } // &#x83B7;&#x5F97;&#x5E03;&#x5C40;&#x7684;&#x65B9;&#x5411;&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x8BBE;&#x7F6E;flag PFLAG2_LAYOUT_DIRECTION_RESOLVED_RTL&#xFF0C;&#x5219;&#x4E3A;&#x4ECE;&#x5DE6;&#x5230;&#x53F3;&#x5E03;&#x5C40; // &#x53F3;&#x5230;&#x5DE6;&#x5E03;&#x5C40;&#x5728;&#x6709;&#x4E9B;&#x56FD;&#x5BB6;&#x4F1A;&#x51FA;&#x73B0;&#x8FD9;&#x79CD;&#x60C5;&#x51B5; final int layoutDirection = getLayoutDirection(); // &#x83B7;&#x5F97;&#x5F53;&#x524D;&#x5E03;&#x5C40;&#x7684;&#x7EDD;&#x5BF9;&#x663E;&#x793A;&#x4F4D;&#x7F6E;&#xFF0C;&#x8FD9;&#x91CC;&#x4F1A;&#x6839;&#x636E;&#x5E03;&#x5C40;&#x65B9;&#x5411;&#x6765;&#x8BBE;&#x7F6E;&#x5177;&#x4F53;&#x662F;&#x4ECE;&#x5DE6;&#x8FB9;&#x5F00;&#x59CB;&#x8FD8;&#x662F;&#x53F3;&#x8FB9;&#x5F00;&#x59CB; final int absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection); // &#x5782;&#x76F4;&#x65B9;&#x6CD5;&#x7684;&#x663E;&#x793A;&#x4F4D;&#x7F6E; final int verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK; // &#x6C34;&#x5E73;&#x65B9;&#x5411;&#x663E;&#x793A;&#x4F4D;&#x7F6E;&#x7684;&#x8BBE;&#x7F6E; switch (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) { // &#x6C34;&#x5E73;&#x5C45;&#x4E2D; case Gravity.CENTER_HORIZONTAL: childLeft = parentLeft + (parentRight - parentLeft - width) / 2 + lp.leftMargin - lp.rightMargin; break; // &#x4ECE;&#x53F3;&#x8FB9;&#x5F00;&#x59CB; case Gravity.RIGHT: if (!forceLeftGravity) { childLeft = parentRight - width - lp.rightMargin; break; } // &#x5DE6;&#x8FB9;&#x548C;&#x9ED8;&#x8BA4;&#x7684;&#x60C5;&#x51B5;&#x90FD;&#x662F;&#x5DE6;&#x8FB9;&#x5F00;&#x59CB;&#x5E03;&#x5C40; case Gravity.LEFT: default: childLeft = parentLeft + lp.leftMargin; } // &#x5782;&#x76F4;&#x65B9;&#x5411;&#x7684;&#x5E03;&#x5C40; switch (verticalGravity) { // &#x9876;&#x90E8;&#x5F00;&#x59CB; case Gravity.TOP: childTop = parentTop + lp.topMargin; break; // &#x5782;&#x76F4;&#x5C45;&#x4E2D; case Gravity.CENTER_VERTICAL: childTop = parentTop + (parentBottom - parentTop - height) / 2 + lp.topMargin - lp.bottomMargin; break; // &#x5E95;&#x90E8;&#x5F00;&#x59CB; case Gravity.BOTTOM: childTop = parentBottom - height - lp.bottomMargin; break; // &#x9ED8;&#x8BA4;&#x9876;&#x90E8;&#x5F00;&#x59CB; default: childTop = parentTop + lp.topMargin; } // &#x5B50;View&#x5E03;&#x5C40; child.layout(childLeft, childTop, childLeft + width, childTop + height); } }} &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;layout&#x7684;&#x8FC7;&#x7A0B;&#x5C31;&#x662F;&#x786E;&#x5B9A;&#x5F53;&#x524D;View&#x7684;left&#x3001;top&#x3001;right&#x3001;bottom&#x8FD9;&#x56DB;&#x4E2A;&#x70B9;&#x4F4D;&#x7F6E;&#xFF0C;&#x901A;&#x8FC7;&#x8FD9;&#x56DB;&#x4E2A;&#x70B9;&#x53EF;&#x4EE5;&#x786E;&#x5B9A;&#x8FD9;&#x4E2A;View&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x4ECE;&#x800C;&#x5728;&#x7ED8;&#x5236;&#x7684;&#x65F6;&#x5019;&#x6B63;&#x786E;&#x7ED8;&#x5236;&#x3002;layout&#x7684;&#x8FC7;&#x7A0B;&#x548C;measure&#x7684;&#x8FC7;&#x7A0B;&#x4E0D;&#x540C;&#xFF0C;layout&#x7684;&#x8FC7;&#x7A0B;&#x662F;&#x5148;&#x786E;&#x5B9A;&#x81EA;&#x5DF1;&#x7684;&#x4F4D;&#x7F6E;&#x5728;&#x786E;&#x5B9A;&#x5176;&#x5B50;View&#x7684;&#x4F4D;&#x7F6E;&#x3002; 3. drawdraw&#x8FC7;&#x7A0B;&#x5728;&#x4E4B;&#x524D;&#x7684;Activity&#x663E;&#x793A;&#x5230;Window&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x6709;&#x5199;&#x5230;&#x8FC7;&#xFF0C;&#x5728;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x4F1A;&#x8C03;&#x7528;View&#x7684;draw&#x65B9;&#x6CD5;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public void draw(Canvas canvas) { final int privateFlags = mPrivateFlags; final boolean dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp; (mAttachInfo == null || !mAttachInfo.mIgnoreDirtyState); mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN; /* * Draw traversal performs several drawing steps which must be executed * in the appropriate order: * * 1. Draw the background * 2. If necessary, save the canvas&apos; layers to prepare for fading * 3. Draw view&apos;s content * 4. Draw children * 5. If necessary, draw the fading edges and restore layers * 6. Draw decorations (scrollbars for instance) */ // Step 1, draw the background, if needed int saveCount; if (!dirtyOpaque) { // &#x7ED8;&#x5236;&#x80CC;&#x666F; drawBackground(canvas); } // &#x901A;&#x5E38;&#x6765;&#x7B97;&#x662F;&#x8DF3;&#x8FC7;2&#x548C;5&#x90E8;&#x5206;&#x3002;&#x8FD9;&#x91CC;&#x53EA;&#x770B;&#x4E0B;&#x8DF3;&#x8FC7;2&#x548C;5&#x90E8;&#x5206;&#x65F6;&#xFF0C;&#x6574;&#x4E2A;&#x6D41;&#x7A0B; // skip step 2 &amp; 5 if possible (common case) final int viewFlags = mViewFlags; boolean horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != 0; boolean verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != 0; if (!verticalEdges &amp;&amp; !horizontalEdges) { // Step 3, draw the content // &#x8C03;&#x7528;onDraw&#x65B9;&#x6CD5;&#xFF0C;&#x53BB;&#x7ED8;&#x5236;&#x5185;&#x5BB9; if (!dirtyOpaque) onDraw(canvas); // &#x5206;&#x53D1;&#x7ED8;&#x5236;&#x4E8B;&#x4EF6; // Step 4, draw the children dispatchDraw(canvas); // Overlay is part of the content and draws beneath Foreground if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().dispatchDraw(canvas); } // &#x7ED8;&#x5236;&#x88C5;&#x9970;&#x5185;&#x5BB9; // Step 6, draw decorations (foreground, scrollbars) onDrawForeground(canvas); // we&apos;re done... return; } ......} &#x4ECE;&#x4EE3;&#x7801;&#x4E2D;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4E86;&#x89E3;&#x5230;&#xFF0C;&#x6574;&#x4E2A;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#x4E00;&#x5171;&#x6709;6&#x6B65;&#xFF0C;&#x4F46;&#x662F;&#x901A;&#x5E38;&#x6765;&#x8BF4;&#x7B2C;2&#x6B65;&#x548C;&#x7B2C;5&#x6B65;&#x4E0D;&#x4F1A;&#x8C03;&#x7528;&#xFF1A; &#x7ED8;&#x5236;&#x80CC;&#x666F; drawBackground &#x4FDD;&#x5B58;&#x753B;&#x5E03;&#x56FE;&#x5C42; &#x7ED8;&#x5236;&#x5185;&#x5BB9; onDraw &#x5206;&#x53D1;&#x7ED8;&#x5236;&#x4E8B;&#x4EF6;&#xFF08;&#x7ED8;&#x5236;&#x5B50;View&#xFF09; dispatchDraw &#x7ED8;&#x5236;&#x5E76;&#x6062;&#x590D;&#x56FE;&#x5C42; &#x7ED8;&#x5236;&#x88C5;&#x9970; onDrawForeground 3.1 drawBackground1234567891011121314151617181920212223242526272829303132333435363738394041424344private void drawBackground(Canvas canvas) { final Drawable background = mBackground; // &#x80CC;&#x666F;&#x4E3A;&#x7A7A;&#xFF0C;&#x76F4;&#x63A5;&#x8FD4;&#x56DE; if (background == null) { return; } // &#x8BBE;&#x7F6E;&#x80CC;&#x666F;&#x7684;&#x8FB9;&#x754C;&#x503C; setBackgroundBounds(); // Attempt to use a display list if requested. if (canvas.isHardwareAccelerated() &amp;&amp; mAttachInfo != null &amp;&amp; mAttachInfo.mHardwareRenderer != null) { mBackgroundRenderNode = getDrawableRenderNode(background, mBackgroundRenderNode); final RenderNode renderNode = mBackgroundRenderNode; if (renderNode != null &amp;&amp; renderNode.isValid()) { setBackgroundRenderNodeProperties(renderNode); ((DisplayListCanvas) canvas).drawRenderNode(renderNode); return; } } // &#x6EDA;&#x52A8;&#x7684;x&#x548C;y&#x503C; final int scrollX = mScrollX; final int scrollY = mScrollY; // &#x6CA1;&#x6709;&#x6EDA;&#x52A8;&#xFF0C;&#x76F4;&#x63A5;&#x7ED8;&#x5236; if ((scrollX | scrollY) == 0) { background.draw(canvas); } else { // &#x5C06;canvas&#x79FB;&#x52A8;&#x540E;&#x518D;&#x7ED8;&#x5236; canvas.translate(scrollX, scrollY); background.draw(canvas); canvas.translate(-scrollX, -scrollY); }}void setBackgroundBounds() { // &#x5982;&#x679C;&#x80CC;&#x666F;&#x5C3A;&#x5BF8;&#x6539;&#x53D8;&#x5E76;&#x4E14;&#x80CC;&#x666F;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x8FD9;&#x8BBE;&#x7F6E;&#x5176;&#x8FB9;&#x754C;&#x4E3A;0&#xFF0C;0&#xFF0C;width&#xFF0C;height if (mBackgroundSizeChanged &amp;&amp; mBackground != null) { mBackground.setBounds(0, 0, mRight - mLeft, mBottom - mTop); mBackgroundSizeChanged = false; rebuildOutline(); }} &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;drawBackground&#x65B9;&#x6CD5;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#xFF0C;&#x603B;&#x4F53;&#x6765;&#x8BF4;&#x5C31;&#x662F;&#x7ED8;&#x5236;View&#x7684;&#x80CC;&#x666F;&#xFF0C;&#x5F53;&#x7136;&#x6839;&#x636E;&#x80CC;&#x666F;&#x662F;&#x5426;&#x5B58;&#x5728;&#xFF0C;&#x662F;&#x5426;&#x9875;&#x9762;&#x6EDA;&#x52A8;&#x4E86;&#x6765;&#x7ED8;&#x5236;&#x80CC;&#x666F;&#x3002; 3.2 onDraw&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0; onDraw&#x662F;&#x6CA1;&#x6709;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x7684;&#x5185;&#x5BB9;&#xFF0C;&#x4E00;&#x822C;&#x6765;&#x8BF4;&#x5728;&#x81EA;&#x5B9A;&#x4E49;View&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5F88;&#x591A;&#x65F6;&#x5019;&#x4F1A;&#x91CD;&#x5199;onDraw&#x65B9;&#x6CD5;&#x6765;&#x7ED8;&#x5236;&#x771F;&#x6B63;&#x8981;&#x5B9E;&#x73B0;&#x7684;&#x5185;&#x5BB9;&#x3002; 3.3 dispatchDraw&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x4ECE;&#x6CE8;&#x91CA;&#x6765;&#x770B;&#xFF0C;dispatchDraw&#x4F5C;&#x4E3A;&#x7ED8;&#x5236;&#x5B50;View&#x7684;&#x5F00;&#x59CB;&#xFF0C;&#x5176;&#x5728;View&#x4E2D;&#x662F;&#x7A7A;&#x5B9E;&#x73B0;&#x3002;&#x5728;ViewGroup&#x4E2D;&#x6709;dispatchDraw&#x65B9;&#x6CD5;&#x7684;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#xFF1A;1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192ViewGroup.java// &#x6211;&#x4EEC;&#x53EA;&#x5173;&#x6CE8;&#x5982;&#x4F55;&#x7ED8;&#x5236;childView&#xFF0C;&#x5185;&#x5BB9;&#x7701;&#x7565;&#x4E86;&#x4E00;&#x5927;&#x90E8;&#x5206;// &#x8FD9;&#x91CC;&#x9762;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x4F1A;&#x8C03;&#x7528;drawChild&#x53BB;&#x7ED8;&#x5236;&#x5176;&#x5B50;View@Overrideprotected void dispatchDraw(Canvas canvas) { ...... // &#x6211;&#x4EEC;&#x53EA;&#x5173;&#x6CE8;&#x5982;&#x4F55;&#x7ED8;&#x5236;childView for (int i = 0; i &lt; childrenCount; i++) { while (transientIndex &gt;= 0 &amp;&amp; mTransientIndices.get(transientIndex) == i) { ...... final int childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder); final View child = getAndVerifyPreorderedView(preorderedList, children, childIndex); if ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != null) { // &#x7ED8;&#x5236;&#x5176;&#x5B50;View more |= drawChild(canvas, child, drawingTime); } } ......}ViewGroup.java// &#x5B50;View&#x4F1A;&#x8C03;&#x7528;&#x5176;&#x8FD4;&#x56DE;&#x503C;&#x4E3A;boolean&#x7684;draw&#x65B9;&#x6CD5;&#x53BB;&#x7ED8;&#x5236;protected boolean drawChild(Canvas canvas, View child, long drawingTime) { return child.draw(canvas, this, drawingTime);}View.javaboolean draw(Canvas canvas, ViewGroup parent, long drawingTime) { // &#x5173;&#x4E8E;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#x6A21;&#x5F0F; ...... // &#x52A8;&#x753B;&#x76F8;&#x5173; ...... // &#x786C;&#x4EF6;&#x52A0;&#x901F;&#x76F8;&#x5173;&#xFF0C;&#x901A;&#x8FC7;updateDisplayListIfDirty&#x83B7;&#x53D6;&#x663E;&#x793A;&#x5217;&#x8868;&#x7684;renderNode&#x6700;&#x540E;&#x4E0B;&#x9762;&#x7ED8;&#x5236; if (drawingWithRenderNode) { // Delay getting the display list until animation-driven alpha values are // set up and possibly passed on to the view renderNode = updateDisplayListIfDirty(); if (!renderNode.isValid()) { // Uncommon, but possible. If a view is removed from the hierarchy during the call // to getDisplayList(), the display list will be marked invalid and we should not // try to use it again. renderNode = null; drawingWithRenderNode = false; } } ...... // &#x5982;&#x679C;&#x4F7F;&#x7528;&#x7F13;&#x5B58;&#x53BB;&#x7ED8;&#x5236;&#xFF0C;&#x5219;&#x901A;&#x8FC7;cache&#x7ED8;&#x5236;&#xFF0C;&#x5426;&#x5219;&#x8FD8;&#x662F;&#x4F1A;&#x8C03;&#x7528;View&#x7684;draw(canvas)&#x65B9;&#x6CD5;&#x7ED8;&#x5236; if (!drawingWithDrawingCache) { // &#x786C;&#x4EF6;&#x52A0;&#x901F;&#x7684;&#x8BDD;&#x901A;&#x8FC7;drawRenderNode&#x53BB;&#x7ED8;&#x5236;&#xFF0C;&#x5728;&#x4E4B;&#x524D;&#x8BB2;&#x8FC7;&#x4E86;&#x6700;&#x540E;&#x4F1A;&#x8C03;&#x7528;View&#x7684;draw(canvas)&#x65B9;&#x6CD5;&#x7ED8;&#x5236; if (drawingWithRenderNode) { mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; ((DisplayListCanvas) canvas).drawRenderNode(renderNode); } else { // Fast path for layouts with no backgrounds // &#x65E0;&#x80CC;&#x666F;&#x7684;&#x5FEB;&#x901F;&#x7ED8;&#x5236; if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) { mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; // dispatchDraw(canvas); } else { // &#x8C03;&#x7528;View&#x7684;draw(canvas)&#x65B9;&#x6CD5;&#x7ED8;&#x5236; draw(canvas); } } } else if (cache != null) { mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; if (layerType == LAYER_TYPE_NONE || mLayerPaint == null) { // no layer paint, use temporary paint to draw bitmap Paint cachePaint = parent.mCachePaint; if (cachePaint == null) { cachePaint = new Paint(); cachePaint.setDither(false); parent.mCachePaint = cachePaint; } cachePaint.setAlpha((int) (alpha * 255)); canvas.drawBitmap(cache, 0.0f, 0.0f, cachePaint); } else { // use layer paint to draw the bitmap, merging the two alphas, but also restore int layerPaintAlpha = mLayerPaint.getAlpha(); if (alpha &lt; 1) { mLayerPaint.setAlpha((int) (alpha * layerPaintAlpha)); } canvas.drawBitmap(cache, 0.0f, 0.0f, mLayerPaint); if (alpha &lt; 1) { mLayerPaint.setAlpha(layerPaintAlpha); } } } ...... return more;} &#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x7ED8;&#x5236;&#x5B50;View&#x7684;&#x8FC7;&#x7A0B;&#x8981;&#x76F8;&#x5BF9;&#x7E41;&#x7410;&#x4E00;&#x4E9B;&#xFF0C;&#x901A;&#x8FC7;View&#x7684;&#x53E6;&#x4E00;&#x4E2A;draw&#x65B9;&#x6CD5;&#x6765;&#x7ED8;&#x5236;&#x5B50;View&#xFF0C;&#x5E76;&#x4E14;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x5305;&#x62EC;&#x4E86;&#x52A8;&#x753B;&#x76F8;&#x5173;&#xFF0C;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#x76F8;&#x5173;&#x3002;&#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x6709;&#x4E00;&#x90E8;&#x5206;&#x7701;&#x7565;&#x4E86;&#xFF0C;&#x5176;&#x4E2D;&#x6BD4;&#x8F83;&#x91CD;&#x8981;&#x7684;&#x662F;&#x4E24;&#x4E2A;&#x5730;&#x65B9;&#xFF1A; &#x786C;&#x4EF6;&#x52A0;&#x901F;&#x76F8;&#x5173;&#x8FC7;&#x7A0B;&#xFF1A;&#x5728;&#x4E4B;&#x524D;&#x7684;Activity&#x663E;&#x793A;&#x5230;Window&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x6709;&#x5199;&#x5230;&#x8FC7;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x901A;&#x8FC7;updateDisplayListIfDirty&#x65B9;&#x6CD5;&#x83B7;&#x53D6;&#x663E;&#x793A;&#x5217;&#x8868;&#x7684;renderNode&#x6700;&#x540E;&#x901A;&#x8FC7;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#x7ED8;&#x5236;&#x3002; &#x8F6F;&#x4EF6;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#xFF1A;&#x9700;&#x8981;&#x5224;&#x65AD;&#x662F;&#x5426;&#x4F7F;&#x7528;&#x7F13;&#x5B58;&#xFF0C;&#x5982;&#x679C;&#x4F7F;&#x7528;&#x7F13;&#x5B58;&#x7684;&#x8BDD;&#xFF0C;&#x76F4;&#x63A5;&#x7ED8;&#x5236;&#x7F13;&#x5B58;&#xFF0C;&#x5426;&#x5219;&#x7684;&#x8BDD;&#x8FD8;&#x9700;&#x8981;&#x6309;&#x7167;&#x4E0A;&#x9762;&#x7684;&#x7ED8;&#x5236;&#x6D41;&#x7A0B;&#x4E00;&#x6B65;&#x6B65;&#x8FDB;&#x884C;&#x3002; 3.4 onDrawForeground&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x770B;&#x8FD9;&#x4E2A;&#x540D;&#x79F0;&#x53EF;&#x4EE5;&#x8BA4;&#x4E3A;&#x662F;&#x7ED8;&#x5236;&#x524D;&#x666F;&#xFF0C;&#x5176;&#x4E2D;&#x5305;&#x62EC;&#x4E86;&#x6EDA;&#x52A8;&#x6761;&#x3001;&#x6EDA;&#x52A8;&#x6307;&#x793A;&#x5668;&#x7B49;&#x3002;&#x5F53;&#x7136;&#x4E86;&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x91CD;&#x5199;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53BB;&#x7ED8;&#x5236;&#x4EFB;&#x4F55;&#x60F3;&#x8981;&#x7684;&#x524D;&#x666F;&#x3002;123456789101112131415161718192021222324252627282930public void onDrawForeground(Canvas canvas) { // &#x6EDA;&#x52A8;&#x6307;&#x793A;&#x5668;&#x7ED8;&#x5236; onDrawScrollIndicators(canvas); // &#x6EDA;&#x52A8;&#x6761;&#x7ED8;&#x5236; onDrawScrollBars(canvas); // &#x524D;&#x666F; final Drawable foreground = mForegroundInfo != null ? mForegroundInfo.mDrawable : null; if (foreground != null) { if (mForegroundInfo.mBoundsChanged) { mForegroundInfo.mBoundsChanged = false; final Rect selfBounds = mForegroundInfo.mSelfBounds; final Rect overlayBounds = mForegroundInfo.mOverlayBounds; if (mForegroundInfo.mInsidePadding) { selfBounds.set(0, 0, getWidth(), getHeight()); } else { selfBounds.set(getPaddingLeft(), getPaddingTop(), getWidth() - getPaddingRight(), getHeight() - getPaddingBottom()); } final int ld = getLayoutDirection(); Gravity.apply(mForegroundInfo.mGravity, foreground.getIntrinsicWidth(), foreground.getIntrinsicHeight(), selfBounds, overlayBounds, ld); foreground.setBounds(overlayBounds); } // &#x524D;&#x666F;&#x7684;&#x7ED8;&#x5236; foreground.draw(canvas); }} 3.5 &#x7ED8;&#x5236;&#x987A;&#x5E8F;&#x8FD9;&#x91CC;&#x8FD8;&#x662F;&#x4F7F;&#x7528;&#x6254;&#x7269;&#x7EBF;&#x5927;&#x795E;&#x7684;&#x4E00;&#x5F20;&#x56FE;&#x6765;&#x8868;&#x793A;&#x7ED8;&#x5236;&#x987A;&#x5E8F;&#x5427;&#x3002; 3.6 draw&#x7684;&#x603B;&#x7ED3;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x6574;&#x4E2A;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#x662F;&#x4E00;&#x4E2A;&#x81EA;&#x4E0A;&#x5411;&#x4E0B;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5728;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E2D;&#x5148;&#x7ED8;&#x5236;&#x81EA;&#x8EAB;&#x7684;&#x80CC;&#x666F;&#xFF08;drawBackground&#xFF09;&#x3001;&#x5185;&#x5BB9;&#xFF08;onDraw&#xFF09;&#xFF0C;&#x63A5;&#x7740;&#x7ED8;&#x5236;&#x5B50;View&#xFF08;dispatchDraw&#xFF09;&#x3002;&#x5B50;View&#x7684;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#x53C8;&#x548C;&#x4E0A;&#x9762;&#x7684;&#x8FC7;&#x7A0B;&#x4E00;&#x6837;&#xFF0C;&#x5F53;&#x6240;&#x6709;&#x7684;&#x5B50;View&#x7ED8;&#x5236;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x4F1A;&#x6267;&#x884C;&#x88C5;&#x9970;&#x7684;&#x7ED8;&#x5236;&#xFF08;onDrawForeground&#xFF09; &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#xA0;&#x8FD8;&#x662F;&#x6309;&#x7167;&#x8BA1;&#x5212;&#x6765;&#x7684;&#xFF0C;&#x6574;&#x4E2A;&#x6D41;&#x7A0B;&#x5DF2;&#x7ECF;&#x5199;&#x5230;&#x4E86;&#x6D4B;&#x91CF;&#x3001;&#x5E03;&#x5C40;&#x548C;&#x7ED8;&#x5236;&#x7684;&#x8FC7;&#x7A0B;&#x3002;&#x603B;&#x4F53;&#x6765;&#x8BF4;&#x611F;&#x89C9;&#x7F51;&#x4E0A;&#x6709;&#x4E9B;&#x8D44;&#x6599;&#x8FD8;&#x662F;&#x4E0D;&#x591F;&#x9760;&#x8C31;&#xFF0C;&#x5982;&#x679C;&#x81EA;&#x5DF1;&#x4E0D;&#x53BB;&#x770B;&#x4E00;&#x904D;&#x7684;&#x8BDD;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x6709;&#x8BB8;&#x591A;&#x5751;&#x7B49;&#x7740;&#x4F60;&#x6765;&#x586B;&#x3002;","tags":[]},{"title":"Activity显示到Window的过程","date":"2017-11-28T13:51:30.795Z","path":"2017/11/28/Activity显示到Window的过程/","text":"&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x4ECA;&#x5929;&#x770B;&#x5230;&#x4E00;&#x4E2A;&#x65B0;&#x95FB;&#xFF0C;&#x5173;&#x4E8E;&#x867E;&#x7C73;&#x97F3;&#x4E50;&#x7684;&#x7A0B;&#x5E8F;&#x5458;&#x5199;&#x7684;&#x6CE8;&#x91CA;&#x3002;&#x597D;&#x50CF;&#x56FE;&#x90FD;&#x7EFF;&#x4E86;&#xFF0C;&#x7A81;&#x7136;&#x95F4;&#x60F3;&#x8D77;&#x5728;&#x6211;&#x66FE;&#x7ECF;&#x8001;&#x5927;&#x7684;&#x5F71;&#x54CD;&#x4E0B;&#xFF0C;&#x6211;&#x7684;Log&#x8F93;&#x51FA;&#x5DF2;&#x7ECF;&#x53D8;&#x6210;&#x4E86;fxxk&#x3002;&#x3002;&#x8FD9;&#x6837;&#x4E0D;&#x597D;&#xFF0C;&#x4E0D;&#x597D;&#x3002;&#x8981;&#x6539;&#x7684;&#xFF0C;&#x6539;&#x6539;&#x6539;&#x3002; 1. &#x4ECE;WindowManager&#x7684;addView&#x8BF4;&#x8D77; &#x4E0A;&#x6B21;&#x6211;&#x4EEC;&#x5927;&#x81F4;&#x5206;&#x6790;&#x4E86;Activity&#x4ECE;&#x521B;&#x5EFA;&#x5230;&#x663E;&#x793A;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x5F53;&#x65F6;&#x53EA;&#x662F;&#x7B80;&#x5355;&#x5206;&#x6790;&#x4E86;&#x4E0B;&#x3002;&#x6700;&#x7EC8;&#x7684;&#x663E;&#x793A;&#x8FC7;&#x7A0B;&#x8FD8;&#x662F;&#x901A;&#x8FC7;WindowManager&#x7684;addView&#x6DFB;&#x52A0;&#x5230;Window&#x4E0A;&#x7684;&#x3002;WindowManager&#x662F;&#x4E2A;&#x63A5;&#x53E3;&#xFF0C;&#x7EE7;&#x627F;&#x4E86;ViewManager&#xFF0C;&#x5176;&#x6700;&#x7EC8;&#x7684;&#x5B9E;&#x73B0;&#x7C7B;&#x662F;WindowManagerImpl&#xFF0C;&#x5148;&#x6765;&#x770B;&#x4E0B;WindowManagerImpl&#x7684;addView&#x65B9;&#x6CD5;&#x3002;12345678910111213141516171819202122232425262728ActivityThread.javaif (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l);}WindowManagerImpl.java@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); //&#x8C03;&#x7528;&#x4E86;WindowManagerGlobal&#x7684;addView&#x65B9;&#x6CD5; mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);}private void applyDefaultToken(@NonNull ViewGroup.LayoutParams params) { // Only use the default token if we don&apos;t have a parent window. if (mDefaultToken != null &amp;&amp; mParentWindow == null) { //&#x5224;&#x65AD;params if (!(params instanceof WindowManager.LayoutParams)) { throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); } // Only use the default token if we don&apos;t already have a token. //&#x7ED9;params&#x8BBE;&#x7F6E;token final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (wparams.token == null) { wparams.token = mDefaultToken; } }} &#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x662F;&#x5148;&#x7ED9;&#x5F53;&#x524D;&#x7684;params&#x8BBE;&#x7F6E;&#x4E86;token&#xFF0C;&#x63A5;&#x7740;&#x8C03;&#x7528;&#x4E86;WindowManagerGlobal&#x7684;addView&#x65B9;&#x6CD5;&#x3002; 2. WindowManagerGlobal&#x7684;addView&#x65B9;&#x6CD5; &#x4E0A;&#x9762;&#x8BF4;&#x5230;&#x6211;&#x4EEC;&#x5BF9;&#x5F53;&#x524D;&#x7684;params&#x8BBE;&#x7F6E;&#x4E86;token&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x8C03;&#x7528;&#x4E86;WindowManagerGlobal&#x7684;addView&#x65B9;&#x6CD5;&#x3002;&#x5728;WindowManagerGlobal&#x7684;addView&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x9996;&#x5148;&#x8FDB;&#x884C;&#x7684;&#x662F;&#x5BF9;&#x53C2;&#x6570;&#x7684;&#x6821;&#x9A8C;&#xFF0C;&#x5305;&#x62EC;&#x4E86;&#x7C7B;&#x578B;&#x4EE5;&#x53CA;null&#x7684;&#x6821;&#x9A8C;&#x3002;&#x5982;&#x679C;&#x4E0D;&#x901A;&#x8FC7;&#xFF0C;&#x5219;throw Exception&#x3002;&#x63A5;&#x7740;&#x5728;&#x7F13;&#x5B58;&#x7684;view&#x4E2D;&#x53BB;&#x5BFB;&#x627E;&#x5F53;&#x524D;&#x7684;decorView&#x662F;&#x5426;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#xFF0C;&#x5982;&#x679C;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x5219;&#x9700;&#x8981;&#x5224;&#x65AD;&#x5176;&#x662F;&#x5426;&#x6B63;&#x5728;&#x201C;&#x6B7B;&#x4EA1;&#x201D;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x662F;&#xFF0C;&#x8FD9;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;&#x63A5;&#x7740;&#x9700;&#x8981;&#x6839;&#x636E;LayoutParams&#x7684;type&#x6765;&#x5224;&#x65AD;&#x7A97;&#x53E3;&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x9ED8;&#x8BA4;&#x7684;&#x662F;TYPE_APPLICATION&#x5373;&#x666E;&#x901A;&#x5E94;&#x7528;&#x7A97;&#x53E3;&#x7C7B;&#x578B;&#x3002;&#x5982;&#x679C;&#x662F;&#x5B50;&#x7A97;&#x53E3;&#x7C7B;&#x578B;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x6839;&#x636E;&#x5176;token&#x6765;&#x67E5;&#x627E;&#x5176;&#x7236;&#x7A97;&#x53E3;&#x3002;&#x63A5;&#x7740;&#x9700;&#x8981;&#x521B;&#x5EFA;ViewRootImpl&#x5BF9;&#x8C61;&#xFF0C;&#x5E76;&#x5C06;decorView&#x3001;root&#x3001;wparams&#x4EE5;&#x53CA;&#x6DFB;&#x52A0;&#x5230;&#x7F13;&#x5B58;&#x4E2D;&#x3002;&#x4E0B;&#x9762;&#x662F;&#x4EE3;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899WindowManagerGlobal.javapublic void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { //&#x53C2;&#x6570;&#x68C0;&#x67E5; if (view == null) { throw new IllegalArgumentException(&quot;view must not be null&quot;); } if (display == null) { throw new IllegalArgumentException(&quot;display must not be null&quot;); } if (!(params instanceof WindowManager.LayoutParams)) { throw new IllegalArgumentException(&quot;Params must be WindowManager.LayoutParams&quot;); } final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params; if (parentWindow != null) { parentWindow.adjustLayoutParamsForSubWindow(wparams); } else { // If there&apos;s no parent, then hardware acceleration for this view is // set from the application&apos;s hardware acceleration setting. final Context context = view.getContext(); if (context != null &amp;&amp; (context.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != 0) { wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED; } } ViewRootImpl root; View panelParentView = null; synchronized (mLock) { //&#x6DFB;&#x52A0;&#x7CFB;&#x7EDF;&#x5C5E;&#x6027;&#x6539;&#x53D8;&#x7684;callback // Start watching for system property changes. if (mSystemPropertyUpdater == null) { mSystemPropertyUpdater = new Runnable() { @Override public void run() { synchronized (mLock) { for (int i = mRoots.size() - 1; i &gt;= 0; --i) { mRoots.get(i).loadSystemProperties(); } } } }; SystemProperties.addChangeCallback(mSystemPropertyUpdater); } //&#x4ECE;&#x7F13;&#x5B58;&#x7684;view&#x4E2D;&#x5BFB;&#x627E;&#x662F;&#x5426;&#x5F53;&#x524D;&#x7684;decorView&#x5DF2;&#x7ECF;&#x5B58;&#x5728; int index = findViewLocked(view, false); //index &gt;= 0 &#x5219;&#x8BF4;&#x660E;&#x5DF2;&#x7ECF;&#x5B58;&#x5728;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x9700;&#x8981;&#x53BB;&#x8BA9;&#x5B83;&#x9500;&#x6BC1; if (index &gt;= 0) { //&#x6B63;&#x5728;&#x9500;&#x6BC1;&#x7684;view&#x4E2D;&#x662F;&#x5426;&#x5305;&#x542B;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;&#xFF0C;&#x8C03;&#x7528;&#x5176;doDie()&#x65B9;&#x6CD5; if (mDyingViews.contains(view)) { // Don&apos;t wait for MSG_DIE to make it&apos;s way through root&apos;s queue. mRoots.get(index).doDie(); } else { //&#x629B;&#x51FA;&#x5F02;&#x5E38; throw new IllegalStateException(&quot;View &quot; + view + &quot; has already been added to the window manager.&quot;); } // The previous removeView() had not completed executing. Now it has. } // If this is a panel window, then find the window it is being // attached to for future reference. // &#x5224;&#x65AD;&#x5F53;&#x524D;&#x7684;LayoutParams&#x7684;type&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x5982;&#x679C;&#x5B83;&#x662F;&#x5B50;&#x7A97;&#x53E3;&#xFF0C;&#x90A3;&#x4E48;&#x9700;&#x8981;&#x53BB;&#x627E;&#x5230;&#x5B83;&#x7684;&#x7236;&#x7A97;&#x53E3; if (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp; wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) { final int count = mViews.size(); for (int i = 0; i &lt; count; i++) { if (mRoots.get(i).mWindow.asBinder() == wparams.token) { panelParentView = mViews.get(i); } } } //&#x521B;&#x5EFA;ViewRootImpl root = new ViewRootImpl(view.getContext(), display); //&#x8BBE;&#x7F6E;LayoutParams view.setLayoutParams(wparams); //&#x6DFB;&#x52A0;&#x5230;&#x7F13;&#x5B58;&#x4E2D; mViews.add(view); mRoots.add(root); mParams.add(wparams); } // do this last because it fires off messages to start doing things try { //&#x901A;&#x8FC7;ViewRootImpl&#x53BB;&#x8BBE;&#x7F6E;view&#xFF0C;&#x4F20;&#x5165;decorView&#xFF0C;LayoutParams&#x4EE5;&#x53CA;&#x7236;&#x7A97;&#x53E3; root.setView(view, wparams, panelParentView); } catch (RuntimeException e) { // BadTokenException or InvalidDisplayException, clean up. synchronized (mLock) { final int index = findViewLocked(view, false); if (index &gt;= 0) { removeViewLocked(index, true); } } throw e; }} 3. ViewRootImpl&#x7684;setView&#x65B9;&#x6CD5; ViewRootImpl&#x7684;setView&#x65B9;&#x6CD5;&#x6BD4;&#x8F83;&#x957F;&#xFF0C;&#x524D;&#x4E00;&#x90E8;&#x5206;&#x4E0D;&#x7528;&#x591A;&#x8BF4;&#xFF0C;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x90E8;&#x5206;&#x6BD4;&#x8F83;&#x91CD;&#x8981;&#x7684;&#x662F;&#x5BF9;mSurfaceHolderCallback&#x7684;&#x8D4B;&#x503C;&#x64CD;&#x4F5C;&#x3002;&#x8FD9;&#x91CC;&#x9762;&#x9700;&#x8981;&#x770B;&#x5230;&#x7684;&#x662F;DecorView extends FrameLayout implements RootViewSurfaceTaker&#xFF0C;&#x4F46;&#x662F;willYouTakeTheSurface&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x8FD4;&#x56DE;&#x7684;&#x9ED8;&#x8BA4;&#x662F;null&#xFF0C;&#x5982;&#x679C;&#x9700;&#x8981;&#x8BBE;&#x7F6E;&#x53EF;&#x4EE5;&#x5728;Activity&#x4E2D;&#x4F7F;&#x7528;getWindow().takeSurface()&#x8BBE;&#x7F6E;&#x3002;&#x63A5;&#x7740;&#x8C03;&#x7528;&#x4E86;requestLayout()&#x65B9;&#x6CD5;&#xFF0C;&#x53BB;&#x8BF7;&#x6C42;&#x5F00;&#x59CB;&#x5E03;&#x5C40;&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x901A;&#x8FC7;&#x7F16;&#x821E;&#x8005;Choreographer&#x6765;&#x8FDB;&#x884C;&#x7684;&#x5F02;&#x6B65;&#x64CD;&#x4F5C;&#xFF0C;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x4E5F;&#x6BD4;&#x8F83;&#x7E41;&#x7410;&#x3002;&#x540E;&#x9762;&#x662F;&#x5BF9;&#x8F93;&#x5165;&#x901A;&#x9053;&#x7684;&#x5EFA;&#x7ACB;&#xFF0C;&#x901A;&#x8FC7;Session&#x5C06;IWindow&#x6DFB;&#x52A0;&#x5230;WMS&#x4E2D;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) { synchronized (this) { if (mView == null) { mView = view; mAttachInfo.mDisplayState = mDisplay.getState(); mDisplayManager.registerDisplayListener(mDisplayListener, mHandler); mViewLayoutDirectionInitial = mView.getRawLayoutDirection(); mFallbackEventHandler.setView(view); mWindowAttributes.copyFrom(attrs); if (mWindowAttributes.packageName == null) { mWindowAttributes.packageName = mBasePackageName; } attrs = mWindowAttributes; setTag(); // Keep track of the actual window flags supplied by the client. mClientWindowLayoutFlags = attrs.flags; setAccessibilityFocus(null, null); //&#x5F53;&#x524D;&#x7684;view&#x662F;decorView&#xFF0C;&#x800C;&#x901A;&#x8FC7;&#x6E90;&#x7801;&#x53EF;&#x4EE5;&#x770B;&#x5230; DecorView extends FrameLayout implements RootViewSurfaceTaker, WindowCallbacks //&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x6761;&#x4EF6;&#x6210;&#x7ACB;&#xFF0C;&#x4E0D;&#x8FC7;willYouTakeTheSurface&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53BB;&#x83B7;&#x5F97;Callback2&#x7684;&#x65F6;&#xFF0C; //&#x5B9E;&#x9645;&#x4E0A;&#x83B7;&#x53D6;&#x7684;&#x662F;PhoneWindow&#x7684;mTakeSurfaceCallback&#xFF0C;&#x8FD9;&#x4E2A;mTakeSurfaceCallback&#x7684;&#x8BBE;&#x7F6E;&#x662F;&#x901A;&#x8FC7;getWindow().takeSurface()&#x8FD9;&#x79CD;&#x65B9;&#x5F0F;&#x8BBE;&#x7F6E;&#x3002; if (view instanceof RootViewSurfaceTaker) { //&#x9ED8;&#x8BA4;&#x7684;&#x4E3A;null mSurfaceHolderCallback = ((RootViewSurfaceTaker)view).willYouTakeTheSurface(); if (mSurfaceHolderCallback != null) { mSurfaceHolder = new TakenSurfaceHolder(); mSurfaceHolder.setFormat(PixelFormat.UNKNOWN); } } // Compute surface insets required to draw at specified Z value. // TODO: Use real shadow insets for a constant max Z. if (!attrs.hasManualSurfaceInsets) { attrs.setSurfaceInsets(view, false /*manual*/, true /*preservePrevious*/); } CompatibilityInfo compatibilityInfo = mDisplay.getDisplayAdjustments().getCompatibilityInfo(); mTranslator = compatibilityInfo.getTranslator(); //&#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x5E94;&#x7528;&#x6CA1;&#x6709;&#x62E5;&#x6709;&#x81EA;&#x5DF1;&#x7684;surface&#xFF0C;&#x90A3;&#x4E48;&#x9700;&#x8981;&#x5F00;&#x542F;&#x786C;&#x4EF6;&#x52A0;&#x901F; // If the application owns the surface, don&apos;t enable hardware acceleration if (mSurfaceHolder == null) { enableHardwareAcceleration(attrs); } ...... //&#x8BBE;&#x7F6E;&#x4E3A;&#x5DF2;&#x7ECF;&#x6DFB;&#x52A0; mAdded = true; int res; /* = WindowManagerImpl.ADD_OKAY; */ // Schedule the first layout -before- adding to the window // manager, to make sure we do the relayout before receiving // any other events from the system. //&#x5F00;&#x59CB;&#x8BF7;&#x6C42;layout&#xFF0C;layout&#x7684;&#x8FC7;&#x7A0B;&#x662F;&#x901A;&#x8FC7;&#x7F16;&#x821E;&#x8005;Choreographer&#x6765;&#x8FDB;&#x884C;&#x7684;&#x5F02;&#x6B65;&#x64CD;&#x4F5C; requestLayout(); // &#x8F93;&#x5165;&#x901A;&#x9053;&#x7684;&#x5EFA;&#x7ACB; if ((mWindowAttributes.inputFeatures &amp; WindowManager.LayoutParams.INPUT_FEATURE_NO_INPUT_CHANNEL) == 0) { mInputChannel = new InputChannel(); } mForceDecorViewVisibility = (mWindowAttributes.privateFlags &amp; PRIVATE_FLAG_FORCE_DECOR_VIEW_VISIBILITY) != 0; try { mOrigWindowType = mWindowAttributes.type; mAttachInfo.mRecomputeGlobalAttributes = true; collectViewAttributes(); //&#x901A;&#x8FC7;windowSession&#x6DFB;&#x52A0;&#x663E;&#x793A;&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x4E3B;&#x8981;&#x662F;&#x521B;&#x5EFA;SurfaceSession&#xFF0C;SurfaceSession&#x7528;&#x6765;&#x8FDE;&#x63A5;surface flinger //&#x540E;&#x9762;&#x4F1A;&#x901A;&#x8FC7;native&#x521B;&#x5EFA;SurfaceControl&#x65F6;&#x5F53;&#x4F5C;&#x53C2;&#x6570;&#x4F20;&#x5165; res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel); } catch (RemoteException e) { mAdded = false; mView = null; mAttachInfo.mRootView = null; mInputChannel = null; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); throw new RuntimeException(&quot;Adding window failed&quot;, e); } finally { if (restore) { attrs.restore(); } } if (mTranslator != null) { mTranslator.translateRectInScreenToAppWindow(mAttachInfo.mContentInsets); } mPendingOverscanInsets.set(0, 0, 0, 0); mPendingContentInsets.set(mAttachInfo.mContentInsets); mPendingStableInsets.set(mAttachInfo.mStableInsets); mPendingVisibleInsets.set(0, 0, 0, 0); mAttachInfo.mAlwaysConsumeNavBar = (res &amp; WindowManagerGlobal.ADD_FLAG_ALWAYS_CONSUME_NAV_BAR) != 0; mPendingAlwaysConsumeNavBar = mAttachInfo.mAlwaysConsumeNavBar; if (DEBUG_LAYOUT) Log.v(mTag, &quot;Added window &quot; + mWindow); // &#x8FD4;&#x56DE;&#x7684;&#x7ED3;&#x679C;&#x4E0D;&#x662F;&#x6210;&#x529F;&#xFF0C;&#x5219;&#x6839;&#x636E;&#x7ED3;&#x679C;&#x629B;&#x51FA;&#x5F02;&#x5E38; if (res &lt; WindowManagerGlobal.ADD_OKAY) { mAttachInfo.mRootView = null; mAdded = false; mFallbackEventHandler.setView(null); unscheduleTraversals(); setAccessibilityFocus(null, null); switch (res) { ...... } throw new RuntimeException( &quot;Unable to add window -- unknown error code &quot; + res); } // &#x8F93;&#x5165;&#x4E8B;&#x4EF6;&#x7684;callback&#xFF0C;&#x4E00;&#x822C;&#x60C5;&#x51B5;&#x4E0B;&#x90FD;&#x4E3A;null if (view instanceof RootViewSurfaceTaker) { mInputQueueCallback = ((RootViewSurfaceTaker)view).willYouTakeTheInputQueue(); } // &#x6CE8;&#x518C;&#x8F93;&#x5165;&#x4E8B;&#x4EF6;&#x7684;&#x76D1;&#x542C; if (mInputChannel != null) { if (mInputQueueCallback != null) { mInputQueue = new InputQueue(); mInputQueueCallback.onInputQueueCreated(mInputQueue); } mInputEventReceiver = new WindowInputEventReceiver(mInputChannel, Looper.myLooper()); } //&#x8BA9;&#x5F53;&#x524D;&#x7684;ViewRootImpl&#x6210;&#x4E3A;view&#x7684;&#x7236;&#x4EB2;&#x3002;&#x3002; view.assignParent(this); mAddedTouchMode = (res &amp; WindowManagerGlobal.ADD_FLAG_IN_TOUCH_MODE) != 0; mAppVisible = (res &amp; WindowManagerGlobal.ADD_FLAG_APP_VISIBLE) != 0; if (mAccessibilityManager.isEnabled()) { mAccessibilityInteractionConnectionManager.ensureConnection(); } if (view.getImportantForAccessibility() == View.IMPORTANT_FOR_ACCESSIBILITY_AUTO) { view.setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES); } // Set up the input pipeline. ...... } }} 4. Session&#x7684;addToDisplay Session&#x7684;addToDisplay&#x65B9;&#x6CD5;&#x8C03;&#x7528;WMS&#x7684;addWindow&#x65B9;&#x6CD5;&#xFF0C;WMS&#x4E2D;&#x7684;addWindow&#x4E3B;&#x8981;&#x662F;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;WindowState&#x5BF9;&#x8C61;&#xFF0C;&#x901A;&#x8FC7;&#x5176;attach&#x65B9;&#x6CD5;&#x8C03;&#x7528;Session&#x4E2D;&#x7684;windowAddedLocked&#x65B9;&#x6CD5;&#x521B;&#x5EFA;SurfaceSession&#xFF0C;&#x901A;&#x8FC7;SurfaceSession&#x53EF;&#x4EE5;&#x548C;surface flinger&#x8FDE;&#x63A5;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116Session.java:@Overridepublic int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) { return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outStableInsets, outOutsets, outInputChannel);}WMS:public int addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel) { int[] appOp = new int[1]; //&#x6743;&#x9650;&#x68C0;&#x67E5;&#x5B9E;&#x73B0;&#x7C7B;WindowManagerPolicy int res = mPolicy.checkAddPermission(attrs, appOp); if (res != WindowManagerGlobal.ADD_OKAY) { return res; } boolean reportNewConfig = false; WindowState parentWindow = null; long origId; final int callingUid = Binder.getCallingUid(); final int type = attrs.type; synchronized(mWindowMap) { //&#x9519;&#x8BEF;&#x5904;&#x7406; ...... AppWindowToken atoken = null; final boolean hasParent = parentWindow != null; // Use existing parent window token for child windows since they go in the same token // as there parent window so we can apply the same policy on them. WindowToken token = displayContent.getWindowToken( hasParent ? parentWindow.mAttrs.token : attrs.token); // If this is a child window, we want to apply the same type checking rules as the // parent window type. final int rootType = hasParent ? parentWindow.mAttrs.type : type; boolean addToastWindowRequiresToken = false; if (token == null) { //&#x9519;&#x8BEF;&#x5904;&#x7406; ...... final IBinder binder = attrs.token != null ? attrs.token : client.asBinder(); token = new WindowToken(this, binder, type, false, displayContent, session.mCanAddInternalSystemWindow); } else if (rootType &gt;= FIRST_APPLICATION_WINDOW &amp;&amp; rootType &lt;= LAST_APPLICATION_WINDOW) { atoken = token.asAppWindowToken(); ...... } ......//&#x9519;&#x8BEF;&#x5904;&#x7406; } else if (token.asAppWindowToken() != null) { attrs.token = null; token = new WindowToken(this, client.asBinder(), type, false, displayContent, session.mCanAddInternalSystemWindow); } //&#x521B;&#x5EFA;WindowState&#xFF0C; final WindowState win = new WindowState(this, session, client, token, parentWindow, appOp[0], seq, attrs, viewVisibility, session.mUid, session.mCanAddInternalSystemWindow); ...... //&#x5F00;&#x542F;&#x8F93;&#x5165;&#x901A;&#x9053; final boolean openInputChannels = (outInputChannel != null &amp;&amp; (attrs.inputFeatures &amp; INPUT_FEATURE_NO_INPUT_CHANNEL) == 0); if (openInputChannels) { win.openInputChannel(outInputChannel); } //&#x5173;&#x4E8E;toast&#x7684;&#x4E00;&#x4E2A;&#x5904;&#x7406; ...... res = WindowManagerGlobal.ADD_OKAY; if (mCurrentFocus == null) { mWinAddedSinceNullFocus.add(win); } if (excludeWindowTypeFromTapOutTask(type)) { displayContent.mTapExcludedWindows.add(win); } origId = Binder.clearCallingIdentity(); //&#x8C03;&#x7528;&#x4E86;WindowState&#x7684;attach&#x65B9;&#x6CD5;&#xFF0C;&#x4E0B;&#x9762;&#x6709;&#x8BB2;&#x89E3; win.attach(); //&#x5C06;WindowState&#x548C;&#x4F20;&#x5165;&#x7684;IWindow&#x4FDD;&#x5B58;&#x5230;mWindowMap&#x4E2D; mWindowMap.put(client.asBinder(), win); ...... return res;}WindowState.java:void attach() { if (localLOGV) Slog.v(TAG, &quot;Attaching &quot; + this + &quot; token=&quot; + mToken); mSession.windowAddedLocked(mAttrs.packageName);}Session.java:void windowAddedLocked(String packageName) { //&#x8BBE;&#x7F6E;&#x5305;&#x540D; mPackageName = packageName; mRelayoutTag = &quot;relayoutWindow: &quot; + mPackageName; if (mSurfaceSession == null) { //&#x521B;&#x5EFA;SurfaceSession&#x4E0E;surface flinger&#x8FDE;&#x63A5; mSurfaceSession = new SurfaceSession(); mService.mSessions.add(this); if (mLastReportedAnimatorScale != mService.getCurrentAnimatorScale()) { mService.dispatchNewAnimatorScaleLocked(this); } } mNumWindow++;} SurfaceSession&#x662F;&#x901A;&#x8FC7;native&#x5C42;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x80FD;&#x529B;&#x4E0D;&#x591F;&#xFF0C;&#x4E0D;&#x505A;&#x5206;&#x6790;&#x3002; 6. Choreographer&#x7684;TraversalRunnable&#x5F02;&#x6B65;&#x65B9;&#x6CD5;&#x6267;&#x884C; ViewRootImpl&#x4E2D;&#x7684;Choreographer&#x901A;&#x8FC7;postCallback&#x65B9;&#x5F0F;&#x5B9E;&#x73B0;&#x5F02;&#x6B65;&#x7684;&#x904D;&#x5386;&#x64CD;&#x4F5C;&#xFF0C;Choreographer&#x4F1A;&#x5728;&#x5E95;&#x5C42;&#x63A5;&#x6536;VSYNC&#xFF08;&#x5782;&#x76F4;&#x540C;&#x6B65;&#xFF09;&#x4FE1;&#x53F7;&#xFF0C;&#x63A5;&#x6536;&#x5782;&#x76F4;&#x540C;&#x6B65;&#x4FE1;&#x53F7;&#x540E;&#x4F1A;&#x6839;&#x636E;&#x7C7B;&#x578B;&#x6765;&#x5224;&#x65AD;&#x5177;&#x4F53;&#x64CD;&#x4F5C;&#x3002;&#x8FD9;&#x91CC;&#x662F;&#x904D;&#x5386;&#x64CD;&#x4F5C;&#xFF0C;&#x4F1A;&#x8C03;&#x7528;TraversalRunnable&#x7684;run&#x65B9;&#x6CD5;&#xFF0C;run&#x65B9;&#x6CD5;&#x4E2D;&#x8C03;&#x7528;&#x4E86;ViewRootImpl&#x7684;doTraversal&#x65B9;&#x6CD5;&#xFF0C;doTraversal&#x65B9;&#x6CD5;&#x8C03;&#x7528;&#x4E86;performTraversals()&#x65B9;&#x6CD5;&#x3002;performTraversals()&#x8FD9;&#x91CC;&#x9762;&#x5C31;&#x662F;&#x771F;&#x6B63;&#x7684;&#x904D;&#x5386;&#x64CD;&#x4F5C;&#x3002;&#x7B80;&#x5316;&#x4E00;&#x4E0B;&#x4EE3;&#x7801;&#xFF08;&#x4EE3;&#x7801;&#x592A;&#x591A;&#x4E86;&#xFF09;&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x4E3B;&#x8981;&#x5206;&#x4E3A;&#x56DB;&#x90E8;&#x5206;&#xFF1A; relayoutWindow&#xFF0C;&#x8FD9;&#x91CC;&#x4F1A;&#x521B;&#x5EFA;SurfaceControl&#xFF0C;&#x5E76;&#x4E14;&#x5C06;&#x4E4B;&#x524D;&#x7684;SurfaceSession&#x5F53;&#x4F5C;&#x53C2;&#x6570;&#x4F20;&#x5165;&#x3002; &#x8C03;&#x7528;performMeasure&#x65B9;&#x6CD5;&#xFF0C;&#x5BF9;View&#x8FDB;&#x884C;&#x6D4B;&#x91CF;&#x3002; &#x8C03;&#x7528;performLayout&#x5BF9;View&#x7684;&#x8FDB;&#x884C;&#x5E03;&#x5C40;&#x3002; &#x8C03;&#x7528;performDraw&#x8FDB;&#x884C;&#x7ED8;&#x5236;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445final class TraversalRunnable implements Runnable { @Override public void run() { doTraversal(); }}void doTraversal() { ...... performTraversals(); ......}private void performTraversals() { // cache mView since it is used so much below... final View host = mView; ...... try { ...... //&#x91CD;&#x65B0;&#x5E03;&#x5C40;window&#xFF0C;&#x4E3B;&#x8981;&#x662F;surface&#x7684;&#x521B;&#x5EFA; relayoutResult = relayoutWindow(params, viewVisibility, insetsPending); ...... } ...... if (!mStopped || mReportNextDraw) { ...... // Ask host how big it wants to be //&#x6D4B;&#x91CF; performMeasure(childWidthMeasureSpec, childHeightMeasureSpec); ...... } ...... if (didLayout) { //&#x5E03;&#x5C40; performLayout(lp, mWidth, mHeight); ...... } ...... if (!cancelDraw &amp;&amp; !newSurface) { //&#x7ED8;&#x5236; performDraw(); } } 6.1 relayoutWindow&#x7684;&#x8FC7;&#x7A0B; &#x8FD9;&#x91CC;&#x7684;&#x8FC7;&#x7A0B;&#x662F;&#x6BD4;&#x8F83;&#x591A;&#x7684;&#xFF0C;&#x5206;&#x6B65;&#x6765;&#x8BF4;&#xFF1A; &#x8C03;&#x7528;Session&#x7684;relayout 12345678910111213141516171819ViewRootImpl.java:private int relayoutWindow(WindowManager.LayoutParams params, int viewVisibility, boolean insetsPending) throws RemoteException { ...... //&#x8FD9;&#x91CC;&#x8FD8;&#x662F;&#x901A;&#x8FC7;Session&#x8FDB;&#x884C;relayout&#xFF0C;&#x53EF;&#x4EE5;&#x731C;&#x60F3;Session&#x4E2D;&#x4F1A;&#x8C03;&#x7528;WMS&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x771F;&#x6B63;relayout //&#x8FD9;&#x91CC;&#x8BF4;&#x4E0B;&#x53C2;&#x6570;mSurface&#x5373;Surface&#x5BF9;&#x8C61;&#xFF0C;&#x8FD9;&#x4E2A;&#x5BF9;&#x8C61;&#x662F;java&#x5C42;&#x76F4;&#x63A5;new&#x51FA;&#x6765;&#x7684;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x5176;&#x4ED6;&#x64CD;&#x4F5C;&#x3002; //&#x540E;&#x9762;&#x901A;&#x8FC7;new SurfaceControl&#x521B;&#x5EFA;Surface&#x5E76;&#x901A;&#x8FC7;surfaceController.getSurface(outSurface)&#x83B7;&#x5F97;&#x771F;&#x6B63;&#x7684;Surface int relayoutResult = mWindowSession.relayout( mWindow, mSeq, params, (int) (mView.getMeasuredWidth() * appScale + 0.5f), (int) (mView.getMeasuredHeight() * appScale + 0.5f), viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : 0, mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets, mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration, mSurface); ...... return relayoutResult;} Sessoin&#x4E2D;&#x7684;relayout&#x53C8;&#x53BB;&#x8C03;&#x7528;WMS&#x4E2D;&#x7684;relayoutWindow&#x65B9;&#x6CD5;&#xFF08;&#x6BCF;&#x6B21;&#x90FD;&#x662F;&#x8FD9;&#x4E2A;&#x5957;&#x8DEF;&#xFF09; 1234567891011121314Session.java:public int relayout(IWindow window, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewFlags, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame, MergedConfiguration mergedConfiguration, Surface outSurface) { //&#x679C;&#x4E0D;&#x5176;&#x7136;&#xFF0C;&#x8C03;&#x7528;&#x4E86;WMS&#x7684;relayoutWindow&#x65B9;&#x6CD5;&#xFF0C; int res = mService.relayoutWindow(this, window, seq, attrs, requestedWidth, requestedHeight, viewFlags, flags, outFrame, outOverscanInsets, outContentInsets, outVisibleInsets, outStableInsets, outsets, outBackdropFrame, mergedConfiguration, outSurface); return res;} WMS&#x7684;relayoutWindow&#x65B9;&#x6CD5;&#x901A;&#x8FC7;createSurfaceControl&#x521B;&#x5EFA;SurfaceControl&#xFF0C;&#x5E76;&#x901A;&#x8FC7;WindowSurfaceController.getSurface&#x5C06;&#x4F20;&#x5165;&#x7684;&#x53C2;&#x6570;Surface&#x771F;&#x6B63;&#x8D4B;&#x503C;&#xFF08;copyFrom&#xFF09; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051WMS:public int relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int requestedWidth, int requestedHeight, int viewVisibility, int flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets, Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame, MergedConfiguration mergedConfiguration, Surface outSurface) { ...... result = win.relayoutVisibleWindow(mergedConfiguration, result, attrChanges, oldVisibility); try { // &#x8FD9;&#x91CC;&#x521B;&#x5EFA;&#x4E86;SurfaceControl result = createSurfaceControl(outSurface, result, win, winAnimator); } catch (Exception e) { mInputMonitor.updateInputWindowsLw(true /*force*/); Slog.w(TAG_WM, &quot;Exception thrown when creating surface for client &quot; + client + &quot; (&quot; + win.mAttrs.getTitle() + &quot;)&quot;, e); Binder.restoreCallingIdentity(origId); return 0; } ...... Binder.restoreCallingIdentity(origId); return result;}WindowStateAnimator.java:WindowSurfaceController createSurfaceLocked(int windowType, int ownerUid) { ...... try { // &#x521B;&#x5EFA;WindowSurfaceController&#xFF0C;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x8FD9;&#x91CC;&#x9762;&#x7684;&#x53C2;&#x6570;&#x6709;Session&#x4E2D;&#x7684;SurfaceSession&#x5BF9;&#x8C61; // &#x4E4B;&#x524D;&#x4E5F;&#x8BF4;&#x8FC7;&#xFF0C;SurfaceSession&#x7528;&#x6765;&#x8FDE;&#x63A5;Surface flingler&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x89C9;&#x5F97;&#x8FD9;&#x91CC;Surface&#x548C;Surface flinger&#x662F;&#x901A;&#x8FC7;SurfaceSession&#x8FDE;&#x63A5;&#x3002; mSurfaceController = new WindowSurfaceController(mSession.mSurfaceSession, attrs.getTitle().toString(), width, height, format, flags, this, windowType, ownerUid); ...... } catch (OutOfResourcesException e) { Slog.w(TAG, &quot;OutOfResourcesException creating surface&quot;); mService.mRoot.reclaimSomeSurfaceMemory(this, &quot;create&quot;, true); mDrawState = NO_SURFACE; return null; } catch (Exception e) { Slog.e(TAG, &quot;Exception creating surface&quot;, e); mDrawState = NO_SURFACE; return null; } ...... return mSurfaceController;} createSurfaceControl&#x65B9;&#x6CD5;&#x901A;&#x8FC7;&#x8C03;&#x7528;WindowStateAnimator&#x7684;createSurfaceLocked&#x65B9;&#x6CD5;&#x53BB;&#x521B;&#x5EFA;WindowSurfaceController 12345678910111213141516171819WMS:private int createSurfaceControl(Surface outSurface, int result, WindowState win, WindowStateAnimator winAnimator) { ...... try { // &#x521B;&#x5EFA;createSurfaceLocked surfaceController = winAnimator.createSurfaceLocked(win.mAttrs.type, win.mOwnerUid); } ...... if (surfaceController != null) { // &#x901A;&#x8FC7;Surface.copyFrom&#x65B9;&#x6CD5;&#x83B7;&#x5F97;&#x771F;&#x6B63;&#x7684;Surface surfaceController.getSurface(outSurface); } else { ...... outSurface.release(); } return result;} WindowSurfaceController&#x7684;&#x521B;&#x5EFA;&#x8FC7;&#x7A0B;&#x4E2D;&#x901A;&#x8FC7;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x662F;&#x5426;&#x5904;&#x4E8E;debug&#x72B6;&#x6001;&#x6765;&#x5224;&#x65AD;&#x521B;&#x5EFA;&#x5177;&#x4F53;&#x7684;SurfaceControl 12345678910WindowSurfaceController.java:public WindowSurfaceController(SurfaceSession s, String name, int w, int h, int format, int flags, WindowStateAnimator animator, int windowType, int ownerUid) { ...... //&#x521B;&#x5EFA;SurfaceControl&#xFF0C;&#x4ECE;&#x540D;&#x5B57;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#x8FD9;&#x662F;&#x63A7;&#x5236;Surface&#x7684;&#x7C7B;&#xFF0C;&#x5F53;&#x7136;&#x4E86;&#x53C2;&#x6570;&#x4E5F;&#x5305;&#x62EC;&#x4E86;&#x4E4B;&#x524D;&#x7684;SurfaceSession&#x5BF9;&#x8C61; mSurfaceControl = new SurfaceControl( s, name, w, h, format, flags, windowType, ownerUid); ......} SurfaceControl&#x7684;&#x5177;&#x4F53;&#x521B;&#x5EFA;&#x8FC7;&#x7A0B;&#x662F;&#x901A;&#x8FC7;nativeCreate&#x65B9;&#x6CD5;&#x521B;&#x5EFA;&#xFF0C;&#x5F53;&#x7136;&#x4E86;&#x53C2;&#x6570;&#x5305;&#x62EC;&#x4E86;&#x4E4B;&#x524D;&#x7684;SurfaceSession&#x5BF9;&#x8C61;&#xFF0C;&#x4E4B;&#x524D;&#x4E5F;&#x8BF4;&#x8FC7;&#xFF0C;SurfaceSession&#x7528;&#x6765;&#x8FDE;&#x63A5;Surface flingler&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x89C9;&#x5F97;&#x8FD9;&#x91CC;Surface&#x548C;Surface flinger&#x662F;&#x901A;&#x8FC7;SurfaceSession&#x8FDE;&#x63A5;&#x3002; 12345678910111213141516171819202122SurfaceControl.java:public SurfaceControl(SurfaceSession session, String name, int w, int h, int format, int flags) throws OutOfResourcesException { if (session == null) { throw new IllegalArgumentException(&quot;session must not be null&quot;); } if (name == null) { throw new IllegalArgumentException(&quot;name must not be null&quot;); } mName = name; // &#x901A;&#x8FC7;native&#x65B9;&#x6CD5;&#x521B;&#x5EFA;&#xFF0C;&#x53C2;&#x6570;&#x662F;&#x540D;&#x79F0; SurfaceSession &#x5BBD; &#x9AD8;&#x7B49; // &#x5177;&#x4F53;&#x521B;&#x5EFA;&#x8FD8;&#x662F;&#x4E0D;&#x6E05;&#x695A;&#x3002;&#x3002; mNativeObject = nativeCreate(session, name, w, h, format, flags); if (mNativeObject == 0) { throw new OutOfResourcesException( &quot;Couldn&apos;t allocate SurfaceControl native object&quot;); } mCloseGuard.open(&quot;release&quot;);} &#x6267;&#x884C;&#x5B8C;relayoutWindow&#x540E;&#xFF0C;&#x6211;&#x4EEC;&#x7684;mSurface&#x5BF9;&#x8C61;&#x4E0D;&#x518D;&#x662F;&#x4E00;&#x4E2A;&#x7A7A;&#x6D1E;&#x6D1E;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;&#x800C;&#x662F;&#x4E00;&#x4E2A;&#x771F;&#x6B63;&#x7684;&#x201D;&#x201C;Surface&#x201D;&#x5BF9;&#x8C61;&#x3002; 6.2 performMeasure&#x65B9;&#x6CD5; performMeasure&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x5F88;&#x7B80;&#x5355;&#xFF0C;&#x5C31;&#x662F;&#x8C03;&#x7528;&#x4E86;View&#x7684;measure&#x65B9;&#x6CD5;&#x3002;123456789private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) { Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;); try { //&#x8C03;&#x7528;&#x4E86;View&#x7684;measure&#x65B9;&#x6CD5;&#xFF0C;&#x53C2;&#x6570;&#x662F;&#x957F;&#x548C;&#x5BBD;&#x7684;&#x6D4B;&#x91CF;&#x89C4;&#x683C; mView.measure(childWidthMeasureSpec, childHeightMeasureSpec); } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); }} &#x5173;&#x4E8E;View&#x7684;measure&#x8FD9;&#x91CC;&#x4E0D;&#x591A;&#x8BF4;&#x3002; 6.3 performLayout&#x65B9;&#x6CD5; performLayout&#x4E3B;&#x8981;&#x662F;&#x8C03;&#x7528;&#x4E86;View&#x7684;layout&#x65B9;&#x6CD5;&#xFF0C;&#x7531;&#x4E8E;DecorView&#x662F;FrameLayout&#x7684;&#x5B50;&#x7C7B;&#xFF0C;FrameLayout&#x53C8;&#x662F;ViewGroup&#x7684;&#x5B50;&#x7C7B;&#xFF0C;&#x800C;&#x4E14;ViewGroup&#x7684;layout&#x662F;final&#x65B9;&#x6CD5;&#xFF0C;&#x6240;&#x4EE5;&#x6700;&#x540E;&#x8C03;&#x7528;&#x7684;&#x662F;ViewGroup&#x7684;layout&#x65B9;&#x6CD5;&#xFF0C;&#x6EE1;&#x8DB3;&#x6761;&#x4EF6;&#x7684;&#x8BDD;&#xFF0C;&#x6700;&#x540E;&#x4F1A;&#x8C03;&#x7528;View&#x7684;layout&#x65B9;&#x6CD5;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private void performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight) { mLayoutRequested = false; mScrollMayChange = true; // &#x5728;&#x5E03;&#x5C40;&#x8FC7;&#x7A0B;&#x4E2D; mInLayout = true; final View host = mView; if (DEBUG_ORIENTATION || DEBUG_LAYOUT) { Log.v(mTag, &quot;Laying out &quot; + host + &quot; to (&quot; + host.getMeasuredWidth() + &quot;, &quot; + host.getMeasuredHeight() + &quot;)&quot;); } Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;layout&quot;); try { // &#x8C03;&#x7528;View&#xFF08;decorView&#xFF09;&#x7684;layout&#x65B9;&#x6CD5; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); // &#x4E0D;&#x5728;&#x5E03;&#x5C40;&#x8FC7;&#x7A0B;&#x4E2D;&#x4E86; mInLayout = false; int numViewsRequestingLayout = mLayoutRequesters.size(); if (numViewsRequestingLayout &gt; 0) { // &#x8FD9;&#x4E2A;&#x6CE8;&#x91CA;&#x5F88;&#x6E05;&#x695A;&#x4E86;&#xFF0C;&#x8FD9;&#x91CC;&#x5728;&#x5E03;&#x5C40;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x4E3B;&#x8981;&#x662F;requestLayout()&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x88AB;&#x8C03;&#x7528;&#x4E86;&#x3002; // requestLayout() &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4F1A;&#x8C03;&#x7528;ViewRootImpl&#x7684;requestLayoutDuringLayout&#x65B9;&#x6CD5;&#xFF0C;&#x5C06;&#x81EA;&#x5DF1;&#x6DFB;&#x52A0;&#x5230;list&#x4E2D; // &#x8FD9;&#x65F6;&#x5019;numViewsRequestingLayout &gt; 0&#x6267;&#x884C;&#x4E0B;&#x9762;&#x7684;&#x64CD;&#x4F5C; // requestLayout() was called during layout. // If no layout-request flags are set on the requesting views, there is no problem. // If some requests are still pending, then we need to clear those flags and do // a full request/measure/layout pass to handle this situation. ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, false); if (validLayoutRequesters != null) { // Set this flag to indicate that any further requests are happening during // the second pass, which may result in posting those requests to the next // frame instead mHandlingLayoutInLayoutRequest = true; // Process fresh layout requests, then measure and layout int numValidRequests = validLayoutRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = validLayoutRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during layout: running second layout pass&quot;); view.requestLayout(); } measureHierarchy(host, lp, mView.getContext().getResources(), desiredWindowWidth, desiredWindowHeight); mInLayout = true; host.layout(0, 0, host.getMeasuredWidth(), host.getMeasuredHeight()); mHandlingLayoutInLayoutRequest = false; // Check the valid requests again, this time without checking/clearing the // layout flags, since requests happening during the second pass get noop&apos;d validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, true); if (validLayoutRequesters != null) { final ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters; // Post second-pass requests to the next frame getRunQueue().post(new Runnable() { @Override public void run() { int numValidRequests = finalRequesters.size(); for (int i = 0; i &lt; numValidRequests; ++i) { final View view = finalRequesters.get(i); Log.w(&quot;View&quot;, &quot;requestLayout() improperly called by &quot; + view + &quot; during second layout pass: posting in next frame&quot;); view.requestLayout(); } } }); } } } } finally { Trace.traceEnd(Trace.TRACE_TAG_VIEW); } mInLayout = false;} 6.4 performDraw&#x7684;&#x8FC7;&#x7A0B; &#x524D;&#x9762;&#x8BF4;&#x4E86;&#x90A3;&#x4E48;&#x591A;&#xFF0C;&#x4E5F;&#x6CA1;&#x8F6E;&#x5230;&#x7ED8;&#x5236;&#x7684;&#x8FC7;&#x7A0B;&#x3002;&#x5F53;&#x6D4B;&#x91CF;&#x5B8C;&#x6210;&#xFF0C;&#x5E03;&#x5C40;&#x5B8C;&#x6210;&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x4FBF;&#x662F;&#x771F;&#x6B63;&#x7684;&#x7ED8;&#x5236;&#x7684;&#x8FC7;&#x7A0B;&#x2014;&#x2014;performDraw&#x3002;&#x6574;&#x4E2A;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#x5206;&#x4E3A;&#x4E86;&#x4E2D;&#x4E0D;&#x540C;&#x7684;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#xFF0C;&#x6211;&#x770B;&#x4E86;&#x5F88;&#x591A;&#x535A;&#x5BA2;&#xFF0C;&#x57FA;&#x672C;&#x4E0A;&#x5206;&#x6790;&#x7684;&#x90FD;&#x662F;&#x8F6F;&#x4EF6;&#x7ED8;&#x5236;&#x3002;&#x4F46;&#x662F;&#xFF0C;Android 4.0&#x5C31;&#x5DF2;&#x7ECF;&#x9ED8;&#x8BA4;&#x5F00;&#x542F;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#x4E86;&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x91CC;&#x91CD;&#x70B9;&#x8BF4;&#x4E0B;&#x786C;&#x4EF6;&#x7ED8;&#x5236;&#xFF08;&#x4E0D;&#x4F1A;&#x6D89;&#x53CA;native&#x5C42;&#xFF09;&#x3002;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#x7684;&#x6E32;&#x67D3;&#x8FC7;&#x7A0B;&#xFF1A; &#x5728;ViewRootImpl&#x7684;draw&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x5982;&#x679C;&#x5F00;&#x542F;&#x4E86;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#x4F1A;&#x8C03;&#x7528;ThreadedRenderer&#x7684;draw&#x65B9;&#x6CD5;&#x53BB;&#x7ED8;&#x5236;&#x3002; 12345678910111213141516171819202122232425262728293031323334353637383940ViewRootImpl.java:private void performDraw() { ...... try { draw(fullRedrawNeeded); } finally { mIsDrawing = false; Trace.traceEnd(Trace.TRACE_TAG_VIEW); } ...... try { mWindowSession.finishDrawing(mWindow); } catch (RemoteException e) { }}private void draw(boolean fullRedrawNeeded) { // &#x8BBE;&#x7F6E;&#x5C5E;&#x6027;&#x548C;&#x63A5;&#x53E3;&#x56DE;&#x8C03;&#x90E8;&#x5206; ...... mAttachInfo.mDrawingTime = mChoreographer.getFrameTimeNanos() / TimeUtils.NANOS_PER_MS; if (!dirty.isEmpty() || mIsAnimating || accessibilityFocusDirty) { // &#x5F00;&#x542F;&#x4E86;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#xFF0C;&#x4E4B;&#x524D;&#x8BF4;&#x8FC7; &#x5982;&#x679C;&#x6CA1;&#x6709;&#x81EA;&#x5DF1;&#x7684;SurfaceView&#x5219;&#x5F00;&#x542F;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#xFF0C;&#x6240;&#x4EE5;&#x6700;&#x7EC8;&#x4F1A;&#x6267;&#x884C;&#x8FD9;&#x90E8;&#x5206;&#x4EE3;&#x7801; if (mAttachInfo.mHardwareRenderer != null &amp;&amp; mAttachInfo.mHardwareRenderer.isEnabled()) { ...... // ThreadedRenderer&#x7684;draw&#x65B9;&#x6CD5; mAttachInfo.mHardwareRenderer.draw(mView, mAttachInfo, this); } else { ...... // &#x6CA1;&#x6709;&#x5F00;&#x542F;&#x786C;&#x4EF6;&#x52A0;&#x901F;&#xFF0C;&#x8F6F;&#x4EF6;&#x7ED8;&#x5236; if (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) { return; } } } ......} ThreadedRenderer&#x8C03;&#x7528;updateRootDisplayList&#x66F4;&#x65B0;&#x8DDF;&#x663E;&#x793A;&#x5217;&#x8868;&#x3002; 1234567891011ThreadedRenderer.java:void draw(View view, AttachInfo attachInfo, HardwareDrawCallbacks callbacks) { attachInfo.mIgnoreDirtyState = true; final Choreographer choreographer = attachInfo.mViewRootImpl.mChoreographer; choreographer.mFrameInfo.markDrawStart(); // &#x66F4;&#x65B0;&#x6839;&#x663E;&#x793A;&#x5217;&#x8868; updateRootDisplayList(view, callbacks); ......} updateRootDisplayList&#x8C03;&#x7528;View.updateDisplayListIfDirty&#x65B9;&#x6CD5;&#x83B7;&#x5F97;RenderNode&#x5BF9;&#x8C61;&#xFF0C;&#x901A;&#x8FC7;DisplayListCanvas.drawRenderNode&#x65B9;&#x6CD5;&#x771F;&#x6B63;&#x7ED8;&#x5236;&#x3002; 12345678910111213141516171819202122232425ThreadedRenderer.java:private void updateRootDisplayList(View view, HardwareDrawCallbacks callbacks) { updateViewTreeDisplayList(view); if (mRootNodeNeedsUpdate || !mRootNode.isValid()) { DisplayListCanvas canvas = mRootNode.start(mSurfaceWidth, mSurfaceHeight); try { final int saveCount = canvas.save(); canvas.translate(mInsetLeft, mInsetTop); callbacks.onHardwarePreDraw(canvas); canvas.insertReorderBarrier(); // view.updateDisplayListIfDirty()&#x8FD9;&#x4E2A;&#x662F;&#x91CD;&#x70B9;&#xFF0C;&#x771F;&#x6B63;&#x7684;&#x5C06;&#x8981;&#x663E;&#x793A;&#x7684;&#x5217;&#x8868;&#x4EA4;&#x7ED9;canvas&#x53BB;&#x7ED8;&#x5236; canvas.drawRenderNode(view.updateDisplayListIfDirty()); canvas.insertInorderBarrier(); callbacks.onHardwarePostDraw(canvas); canvas.restoreToCount(saveCount); mRootNodeNeedsUpdate = false; } finally { mRootNode.end(canvas); } } Trace.traceEnd(Trace.TRACE_TAG_VIEW);} &#x5173;&#x4E8E;View.updateDisplayListIfDirty()&#x65B9;&#x6CD5;&#xFF0C;&#x6211;&#x7684;&#x7406;&#x89E3;&#x662F;canvas&#x662F;&#x6574;&#x4E2A;&#x753B;&#x5E03;&#xFF0C;&#x901A;&#x8FC7;draw&#xFF0C;dispatchDraw&#x5C06;&#x8981;&#x753B;&#x7684;&#x5185;&#x5BB9;&#x6DFB;&#x52A0;&#x5230;&#x753B;&#x5E03;&#x4E0A;&#xFF0C;&#x901A;&#x8FC7;renderNode.end(canvas)&#x83B7;&#x5F97;&#x5F53;&#x524D;&#x7684;&#x753B;&#x5E03;&#x7684;&#x5185;&#x5BB9;&#xFF0C;&#x6700;&#x7EC8;&#x4EA4;&#x7ED9;GPU&#x7EDF;&#x4E00;&#x53BB;&#x5904;&#x7406;&#x3002; 1234567891011121314151617181920212223242526272829303132333435363738394041View.java:public RenderNode updateDisplayListIfDirty() { ...... try { if (layerType == LAYER_TYPE_SOFTWARE) {// &#x8F6F;&#x4EF6;&#x7ED8;&#x5236; buildDrawingCache(true); Bitmap cache = getDrawingCache(true); if (cache != null) { canvas.drawBitmap(cache, 0, 0, mLayerPaint); } } else { computeScroll(); canvas.translate(-mScrollX, -mScrollY); mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; // &#x5982;&#x679C;&#x6CA1;&#x6709;&#x80CC;&#x666F;&#xFF0C;&#x5219;&#x76F4;&#x63A5;&#x8C03;&#x7528;dispatchDraw(canvas)&#xFF0C;&#x5426;&#x5219;&#x8C03;&#x7528;draw(canvas) // Fast path for layouts with no backgrounds if ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) { dispatchDraw(canvas); if (mOverlay != null &amp;&amp; !mOverlay.isEmpty()) { mOverlay.getOverlayView().draw(canvas); } } else { draw(canvas); } } } finally { // &#x7ED8;&#x5236;&#x8282;&#x70B9;&#x4FDD;&#x5B58;&#xFF0C;&#x6211;&#x7684;&#x7406;&#x89E3;&#x662F;canvas&#x662F;&#x6574;&#x4E2A;&#x753B;&#x5E03;&#xFF0C;&#x901A;&#x8FC7;draw&#xFF0C;dispatchDraw&#x5C06;&#x8981;&#x753B;&#x7684;&#x4E1C;&#x897F;&#x6DFB;&#x52A0;&#x5230;&#x753B;&#x5E03;&#x4E0A;&#xFF0C; // &#x901A;&#x8FC7;renderNode.end(canvas)&#x4FDD;&#x5B58;&#x753B;&#x5E03;&#x72B6;&#x6001;&#xFF0C;&#x6700;&#x7EC8;&#x4EA4;&#x7ED9;GPU&#x53BB;&#x5904;&#x7406; renderNode.end(canvas); // &#x8BBE;&#x7F6E;alpha&#x7B49;&#x5C5E;&#x6027; setDisplayListProperties(renderNode); } } else { mPrivateFlags |= PFLAG_DRAWN | PFLAG_DRAWING_CACHE_VALID; mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK; } return renderNode;} &#x8F6F;&#x4EF6;&#x7ED8;&#x5236;&#x8FC7;&#x7A0B;&#xFF1A;drawSoftware&#x76F4;&#x63A5;&#x8C03;&#x7528;&#x4E86;View&#x7684;draw&#x65B9;&#x6CD5;&#xFF0C;&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x76F4;&#x63A5;&#x7ED8;&#x5236;&#x3002;12345678910111213141516171819202122private boolean drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty) { try { ...... try { ...... // &#x771F;&#x6B63;&#x7ED8;&#x5236;&#xFF0C;&#x5728;&#x8FD9;&#x91CC;&#x4E0E;&#x786C;&#x4EF6;&#x6E32;&#x67D3;&#x5BF9;&#x6BD4;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#x8FD9;&#x91CC;&#x9762;&#x53EA;&#x662F;canvas&#x53BB;draw&#x5404;&#x79CD;&#x5185;&#x5BB9;&#x3002; mView.draw(canvas); drawAccessibilityFocusedDrawableIfNeeded(canvas); } finally { if (!attachInfo.mSetIgnoreDirtyState) { // Only clear the flag if it was not set during the mView.draw() call attachInfo.mIgnoreDirtyState = false; } } } finally { ...... } return true;} 7. &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD; &#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#x65AD;&#x65AD;&#x7EED;&#x7EED;&#x5199;&#x4E86;&#x5C06;&#x8FD1;&#x4E24;&#x5468;&#x4E86;&#xFF0C;&#x60F3;&#x5927;&#x800C;&#x5168;&#x7684;&#x5168;&#x9762;&#x5206;&#x6790;&#x6240;&#x6709;&#x65B9;&#x6CD5;&#xFF0C;&#x53D1;&#x73B0;&#x4E1C;&#x897F;&#x592A;&#x591A;&#x4E86;&#x6839;&#x672C;&#x4E0D;&#x80FD;&#x4E00;&#x4E0B;&#x5B50;&#x5168;&#x90E8;&#x5206;&#x6790;&#x5B8C;&#x3002;&#x8FD9;&#x91CC;&#x9762;&#x6709;&#x5F88;&#x591A;&#x5730;&#x65B9;&#x90FD;&#x6CA1;&#x6709;&#x5199;&#x51FA;&#x6765;&#xFF0C;&#x5305;&#x62EC;&#x4E86;Choreographer&#xFF08;&#x7F16;&#x821E;&#x8005;&#xFF09;&#xFF0C;View&#x7684;measure&#x3001;layout&#x3001;draw&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x8FD8;&#x6709;&#x5404;&#x79CD;&#x7EC6;&#x8282;&#x7684;&#x5B9E;&#x73B0;&#x4EE5;&#x53CA;&#x5E95;&#x5C42;native&#x65B9;&#x6CD5;&#x7684;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x3002;&#x8DEF;&#x6F2B;&#x6F2B;&#x5176;&#x4FEE;&#x8FDC;&#x516E;&#xFF0C;&#x540C;&#x5FD7;&#x4ECD;&#x9700;&#x52AA;&#x529B;&#x3002;","tags":[]},{"title":"Activity从创建到显示的整个过程","date":"2017-11-15T16:01:12.605Z","path":"2017/11/16/Activity从创建到显示的整个过程/","text":"&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x4ECA;&#x5929;&#x6709;&#x70B9;&#x70E6;&#xFF0C;&#x6709;&#x70B9;&#x70E6;&#x3002;&#x9879;&#x76EE;&#x5199;&#x7684;&#x4E71;&#x6210;&#x56E2;&#xFF0C;&#x6539;&#x8D77;&#x9700;&#x6C42;&#x771F;&#x8981;&#x5B8C;&#x3002;&#x6B64;&#x540E;&#x5F53;&#x4E2A;&#x52A0;&#x73ED;&#x72D7;&#xFF0C;&#x65E0;&#x94B1;&#x65E0;&#x540D;&#x5FC3;&#x8981;&#x5BBD;&#x3002;&#x6628;&#x665A;&#x5199;&#x5230;&#x5341;&#x4E00;&#x70B9;&#xFF0C;&#x6211;&#x90FD;&#x5DEE;&#x70B9;&#x4E0D;&#x76F8;&#x4FE1;&#x8FD9;&#x662F;&#x6211;&#x81EA;&#x5DF1;&#x4E86;&#x3002;&#x4ECA;&#x5929;&#x63A5;&#x7740;&#x6628;&#x5929;&#x7684;&#x8282;&#x594F;&#x6765;&#xFF0C;&#x51C6;&#x5907;&#x5199;&#x4E0B;&#x5173;&#x4E8E;Activity&#x4ECE;&#x521B;&#x5EFA;&#x5230;&#x663E;&#x793A;&#x7684;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x3002; 1. Activity&#x7684;attach&#x65B9;&#x6CD5; &#x4E4B;&#x524D;&#x5206;&#x6790;&#x8FC7;Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x5177;&#x4F53;&#x8C03;&#x7528;&#x65F6;&#x673A;&#xFF0C;&#x6211;&#x4EEC;&#x77E5;&#x9053;Activity&#x662F;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x521B;&#x5EFA;&#x51FA;&#x6765;&#x7684;&#xFF0C;&#x4E4B;&#x540E;&#x4F1A;&#x6267;&#x884C;attach&#x65B9;&#x6CD5;&#xFF1A;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364ActivityThread.java:activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window);Activity.java:final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window) { //&#x628A;context&#x8D4B;&#x503C;&#x7ED9;mBase&#xFF0C;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;getBaseContext&#x83B7;&#x53D6;&#x5230;context attachBaseContext(context); mFragments.attachHost(null /*parent*/); //&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x7A97;&#x53E3; mWindow = new PhoneWindow(this, window); //&#x8FD9;&#x4E2A;&#x597D;&#x50CF;&#x662F;&#x753B;&#x4E2D;&#x753B;&#x7684;callback mWindow.setWindowControllerCallback(this); //&#x8BBE;&#x7F6E;callback&#xFF0C;&#x91CC;&#x9762;&#x6709;&#x5404;&#x79CD;&#x4E8B;&#x4EF6;&#x5305;&#x62EC;&#x952E;&#x76D8;&#x3001;&#x89E6;&#x6478;&#x7B49;&#x4E8B;&#x4EF6;&#x7684;&#x56DE;&#x8C03; mWindow.setCallback(this); //&#x8BBE;&#x7F6E;&#x7A97;&#x53E3;&#x6D88;&#x5931;&#x7684;&#x56DE;&#x8C03; mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); //&#x4E0E;&#x8F93;&#x5165;&#x6CD5;&#x6709;&#x5173;&#x7684;&#x8BBE;&#x7F6E; if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } //ui&#x7EBF;&#x7A0B; mUiThread = Thread.currentThread(); //&#x4E3B;&#x7EBF;&#x7A0B; mMainThread = aThread; //&#x4E4B;&#x524D;&#x8BF4;&#x5230;&#x7684;&#x5C0F;&#x79D8;&#x4E66; mInstrumentation = instr; //binder mToken = token; mIdent = ident; mApplication = application; mIntent = intent; mReferrer = referrer; mComponent = intent.getComponent(); mActivityInfo = info; mTitle = title; mParent = parent; mEmbeddedID = id; mLastNonConfigurationInstances = lastNonConfigurationInstances; ...... //&#x8BBE;&#x7F6E;(WindowManager)context.getSystemService(Context.WINDOW_SERVICE) mWindow.setWindowManager( (WindowManager)context.getSystemService(Context.WINDOW_SERVICE), mToken, mComponent.flattenToString(), (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0); if (mParent != null) { mWindow.setContainer(mParent.getWindow()); } //WindowManager mWindowManager = mWindow.getWindowManager(); mCurrentConfig = config;} attach&#x65B9;&#x6CD5;&#x5927;&#x90E8;&#x5206;&#x90FD;&#x662F;&#x5728;&#x505A;&#x6210;&#x5458;&#x53D8;&#x91CF;&#x7684;&#x8D4B;&#x503C;&#x64CD;&#x4F5C;&#xFF0C;&#x6BD4;&#x5982;&#x4E0A;&#x4E0B;&#x6587;&#xFF0C;&#x4E3B;&#x7EBF;&#x7A0B;&#x548C;UI&#x7EBF;&#x7A0B;&#x3002;&#x91CC;&#x9762;&#x6BD4;&#x8F83;&#x91CD;&#x8981;&#x7684;&#x4E00;&#x70B9;&#x662F;&#x5BF9;Window&#x7684;&#x521B;&#x5EFA;&#xFF0C;&#x6211;&#x4EEC;&#x90FD;&#x77E5;&#x9053;Activity&#x7684;layout&#x662F;&#x663E;&#x793A;&#x5728;&#x7A97;&#x53E3;&#x4E0A;&#x9762;&#x7684;&#xFF0C;&#x8FD9;&#x4E2A;PhoneWindow&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x7684;&#x7A97;&#x53E3;&#x3002;&#x53EF;&#x4EE5;&#x770B;&#x4E0B;&#x5176;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF1A;12345678910111213141516171819202122232425262728PhoneWindow.java:public PhoneWindow(Context context) { super(context); //&#x521D;&#x59CB;&#x5316;mLayoutInflater layout&#x52A0;&#x8F7D;&#x5668; mLayoutInflater = LayoutInflater.from(context);}public PhoneWindow(Context context, Window preservedWindow) { this(context); mUseDecorContext = true; //&#x4F20;&#x8FC7;&#x6765;&#x7684;preservedWindow&#x4E3A;null if (preservedWindow != null) { ...... } boolean forceResizable = Settings.Global.getInt(context.getContentResolver(), DEVELOPMENT_FORCE_RESIZABLE_ACTIVITIES, 0) != 0; //&#x662F;&#x5426;&#x652F;&#x6301;&#x753B;&#x4E2D;&#x753B; mSupportsPictureInPicture = forceResizable || context.getPackageManager().hasSystemFeature( PackageManager.FEATURE_PICTURE_IN_PICTURE);}Window.java:public Window(Context context) { //&#x628A;&#x4E0A;&#x4E0B;&#x6587;&#x8D4B;&#x503C;&#xFF0C;&#x5E76;&#x8BBE;&#x7F6E;&#x9ED8;&#x8BA4;&#x7684;&#x7279;&#x5F81; mContext = context; mFeatures = mLocalFeatures = getDefaultFeatures(context);} attach&#x5230;&#x8FD9;&#x8FB9;&#x57FA;&#x672C;&#x4E0A;&#x5C31;&#x7ED3;&#x675F;&#x4E86;&#x3002; 2. Activity&#x7684;onCreate &#x6309;&#x7167;&#x4E0A;&#x7BC7;&#x8BB2;&#x7684;&#xFF0C;&#x5728;attach&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x4F1A;&#x6267;&#x884C;Activity&#x7684;onCreate&#x65B9;&#x6CD5;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748ActivityThread.java:activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window);if (customIntent != null) { activity.mIntent = customIntent;}r.lastNonConfigurationInstances = null;activity.mStartedActivity = false;int theme = r.activityInfo.getThemeResource();if (theme != 0) { activity.setTheme(theme);}activity.mCalled = false;if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);} else { mInstrumentation.callActivityOnCreate(activity, r.state);}Activity.java:protected void onCreate(@Nullable Bundle savedInstanceState) { if (mLastNonConfigurationInstances != null) { mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders); } if (mActivityInfo.parentActivityName != null) { if (mActionBar == null) { mEnableDefaultActionBarUp = true; } else { mActionBar.setDefaultDisplayHomeAsUpEnabled(true); } } if (savedInstanceState != null) { Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG); mFragments.restoreAllState(p, mLastNonConfigurationInstances != null ? mLastNonConfigurationInstances.fragments : null); } //FragmentController&#x5206;&#x53D1;Create&#x4E8B;&#x4EF6; mFragments.dispatchCreate(); //application&#x5206;&#x53D1;ActivityCreated&#x4E8B;&#x4EF6; getApplication().dispatchActivityCreated(this, savedInstanceState); if (mVoiceInteractor != null) { mVoiceInteractor.attachActivity(this); } mCalled = true;} &#x4ECE;&#x4E0A;&#x9762;&#x7684;onCreate&#x4E2D;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x5E76;&#x6CA1;&#x6709;&#x505A;&#x592A;&#x591A;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x53EA;&#x6709;&#x5F53;&#x524D;create&#x7684;&#x4E8B;&#x4EF6;&#x5206;&#x53D1;&#x3002; 3. Activity&#x7684;onStart&#x548C;onResume &#x5728;&#x6267;&#x884C;&#x5B8C;Activity&#x7684;onCreate&#x65B9;&#x6CD5;&#x5C31;&#x4F1A;&#x6267;&#x884C;Activity&#x7684;onStart&#x65B9;&#x6CD5;&#xFF0C;onStart&#x65B9;&#x6CD5;&#x66F4;&#x7B80;&#x5355;&#x3002;&#x3002;&#x3002;12345protected void onStart() { mCalled = true; mFragments.doLoaderStart(); getApplication().dispatchActivityStarted(this);} &#x770B;&#x5B8C;onStart&#xFF0C;&#x5C31;&#x53EF;&#x4EE5;&#x731C;&#x51FA;onResume&#x505A;&#x4E86;&#x4EC0;&#x4E48;&#x3002;&#x6CA1;&#x9519;&#xFF0C;&#x5C31;&#x662F;&#xFF1A;12345protected void onResume() { getApplication().dispatchActivityResumed(this); mActivityTransitionState.onResume(this, isTopOfTask()); mCalled = true;} &#x770B;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x5176;&#x5B9E;&#x4F1A;&#x6709;&#x4E00;&#x70B9;&#x70B9;&#x61F5;&#x903C;&#x7684;&#x3002;&#x524D;&#x4EBA;&#x603B;&#x662F;&#x8BF4;&#xFF0C;onStart&#x4EE3;&#x8868;&#x7740;Activity&#x53EF;&#x89C1;&#x4E86;&#xFF0C;onResume&#x4EE3;&#x8868;&#x7740;&#x53EF;&#x4EE5;&#x4EA4;&#x4E92;&#x4E86;&#x3002;&#x4F46;&#x662F;&#x5230;&#x8FD9;&#x91CC;&#x4E86;&#xFF0C;&#x6211;&#x624D;&#x53D1;&#x73B0;&#x5982;&#x4F55;&#x628A;View&#x6DFB;&#x52A0;&#x5230;&#x7A97;&#x53E3;&#x4E0A;&#x7684;&#xFF1F;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x6DFB;&#x52A0;&#x7684;&#xFF1F;&#x7ED8;&#x5236;&#x7684;&#x65F6;&#x95F4;&#x5462;&#xFF1F;&#x53E4;&#x4EBA;&#x8BDA;&#x4F46;&#x6B3A;&#x6211;&#x3002;&#x5230;&#x4E86;&#x8FD9;&#x91CC;&#xFF0C;&#x5E0C;&#x671B;&#x5F97;&#x5230;&#x7684;&#x7B54;&#x6848;&#x5E76;&#x6CA1;&#x6709;&#x51FA;&#x73B0;&#xFF0C;&#x6240;&#x4EE5;&#x7EE7;&#x7EED;&#x5206;&#x6790;&#x3002; 4. &#x771F;&#x6B63;&#x7684;&#x6DFB;&#x52A0;&#x8FC7;&#x7A0B; &#x771F;&#x6B63;&#x6DFB;&#x52A0;&#x7684;&#x8FC7;&#x7A0B;&#x5176;&#x5B9E;&#x5728;&#x6267;&#x884C;&#x5B8C;performResumeActivity&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x540E;&#xFF0C;&#x7CFB;&#x7EDF;&#x6839;&#x636E;&#x8BE5;Activity&#x662F;&#x5426;&#x8981;&#x663E;&#x793A;&#x6765;&#x8BBE;&#x7F6E;&#x9875;&#x9762;&#x662F;&#x5426;&#x9700;&#x8981;&#x6DFB;&#x52A0;&#x5230;&#x7A97;&#x53E3;&#x4E0A;&#xFF0C;&#x5176;&#x4E2D;&#x6700;&#x4E3B;&#x8981;&#x7684;&#x662F;wm.addView(decor, l)&#x8FD9;&#x53E5;&#x4EE3;&#x7801;&#xFF0C;&#x901A;&#x8FC7;WindowManager&#x5C06;view&#x548C;LayoutParams&#x6DFB;&#x52A0;&#x5230;&#x7A97;&#x53E3;&#x4E0A;&#xFF0C;&#x5E76;&#x4E14;&#x663E;&#x793A;&#x51FA;&#x6765;&#xFF08;&#x8FD9;&#x90E8;&#x5206;&#x540E;&#x9762;&#x4F1A;&#x6709;&#x5206;&#x6790;&#xFF09;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { ...... r = performResumeActivity(token, clearHide, reason); if (r != null) { final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; //&#x5C06;&#x8981;&#x663E;&#x793A; boolean willBeVisible = !a.mStartedActivity; if (!willBeVisible) { try { willBeVisible = ActivityManagerNative.getDefault().willActivityBeVisible( a.getActivityToken()); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } //&#x8FD9;&#x4E2A;&#x6761;&#x4EF6;a.mFinished false r.window == null willBeVisible = true if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { //&#x8FD9;&#x4E2A;r.activity.getWindow()&#x5C31;&#x662F;&#x6211;&#x4EEC;attach&#x4E2D;&#x521B;&#x5EFA;&#x7684;PhoneWindow r.window = r.activity.getWindow(); //&#x83B7;&#x5F97;DecorView&#xFF0C;&#x8FD9;&#x91CC;&#x6682;&#x65F6;&#x7406;&#x89E3;&#x4E3A;&#x4E00;&#x4E2A;View&#x5427;&#xFF0C;&#x540E;&#x9762;&#x8FD8;&#x4F1A;&#x6709;&#x5206;&#x6790;&#x7684; View decor = r.window.getDecorView(); //DecorView&#x8BBE;&#x4E3A;INVISIBLE decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; //false&#xFF08;&#x5728;&#x521B;&#x5EFA;&#x8FD9;&#x4E2A;&#x5BF9;&#x8C61;&#x7684;&#x65F6;&#x5019;&#x6CA1;&#x6709;&#x8D4B;&#x503C;&#xFF09; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } //mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(com.android.internal.R.styleable.Window_windowNoDisplay, false); //&#x5982;&#x679C;Activity&#x6CA1;&#x6709;&#x8BBE;&#x7F6E;NoDisplay&#xFF0C;&#x5219;&#x8FD9;&#x4E2A;mVisibleFromClient&#x53D8;&#x91CF;&#x662F;true //mWindowAdded&#x8FD9;&#x4E2A;&#x503C;&#x662F;&#x9ED8;&#x8BA4;&#x7684;&#xFF0C;&#x53EA;&#x6709;&#x88AB;add&#x540E;&#x624D;&#x4F1A;&#x53D8;&#x4E3A;true if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } } else if (!willBeVisible) { r.hideForNow = true; } cleanUpPendingRemoveWindows(r, false /* force */); if (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != null &amp;&amp; !r.hideForNow) { if (r.newConfig != null) { performConfigurationChangedForActivity(r, r.newConfig, REPORT_TO_ACTIVITY); r.newConfig = null; } WindowManager.LayoutParams l = r.window.getAttributes(); ...... r.activity.mVisibleFromServer = true; mNumVisibleActivities++; //&#x8FD9;&#x91CC;&#x53C8;&#x6267;&#x884C;&#x4E86;makeVisible&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x5728;&#x4E0A;&#x9762;&#x5DF2;&#x7ECF;add&#x4E86;&#xFF0C;mWindowAdded&#x8FD9;&#x4E2A;&#x53D8;&#x91CF;&#x4E3A;true&#xFF0C;&#x6240;&#x4EE5;&#x4E0D;&#x4F1A;&#x8FDB;&#x884C;&#x591A;&#x6B21;add&#x3002; //&#x6700;&#x540E;decorView&#x8BBE;&#x7F6E;&#x4E3A;&#x663E;&#x793A; //void makeVisible() { // if (!mWindowAdded) { // ViewManager wm = getWindowManager(); // wm.addView(mDecor, getWindow().getAttributes()); // mWindowAdded = true; // } // mDecor.setVisibility(View.VISIBLE); //} if (r.activity.mVisibleFromClient) { r.activity.makeVisible(); } } if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; //&#x8FD9;&#x4E24;&#x5929;&#x624D;&#x4E86;&#x89E3;&#x5230;&#x8FD9;&#x4E2A;addIdleHandler&#x662F;&#x6307;&#x7A7A;&#x95F2;&#x65F6;&#x5904;&#x7406;&#x7684;&#x6D88;&#x606F;&#xFF0C;MessageQueue&#x6709;&#x4E13;&#x95E8;&#x7684;&#x63A5;&#x53E3;MessageQueue.IdleHandler //&#x8FD9;&#x91CC;&#x4E4B;&#x524D;&#x8BF4;&#x9053;&#x4F1A;&#x6267;&#x884C;&#x524D;&#x4E2A;&#x9875;&#x9762;&#x7684;onStop Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } } } else { //&#x51FA;&#x73B0;&#x95EE;&#x9898;&#x5C31;finish try { ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } }} 5. &#x5927;&#x81F4;&#x8981;&#x603B;&#x7ED3;&#x4E0B; &#x4ECE;&#x4E0A;&#x9762;&#x7684;&#x5206;&#x6790;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x77E5;&#x9053;Activity&#x5728;&#x521B;&#x5EFA;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;onCreate&#x3001;onStart&#x4EE5;&#x53CA;onResume&#x5176;&#x5B9E;&#x90FD;&#x6CA1;&#x6709;&#x5173;&#x4E8E;&#x5BF9;&#x9875;&#x9762;&#x663E;&#x793A;&#x7684;&#x64CD;&#x4F5C;&#xFF0C;&#x771F;&#x6B63;&#x663E;&#x793A;&#x9875;&#x9762;&#x662F;&#x5728;onResmue&#x4E4B;&#x540E;&#xFF0C;WindowManager&#x5C06;decorView&#x6DFB;&#x52A0;&#x540E;&#x8FDB;&#x884C;&#x7ED8;&#x5236;&#xFF08;&#x540E;&#x9762;&#x5E94;&#x8BE5;&#x4F1A;&#x5C06;&#xFF09;&#x3002;&#x4ECA;&#x5929;&#x4E5F;&#x6070;&#x5DE7;&#x770B;&#x5230;&#x4E86;&#x4E00;&#x7BC7;&#x8BB2;&#x89E3;&#x5173;&#x4E8E;MessageQueue.IdleHandler&#x7684;&#x6587;&#x7AE0;&#xFF0C;&#x8FD9;&#x4E2A;IdleHandler&#x4F1A;&#x5728;&#x7EBF;&#x7A0B;&#x7A7A;&#x95F2;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6307;&#x5B9A;&#x4E00;&#x4E2A;&#x64CD;&#x4F5C;&#x3002;&#x4F7F;&#x7528;&#x8FD9;&#x4E2A;IdleHandler&#x5BF9;&#x4E8E;&#x67D0;&#x4E9B;&#x5EF6;&#x65F6;&#x64CD;&#x4F5C;&#xFF0C;&#x4F46;&#x53C8;&#x4E0D;&#x6E05;&#x695A;&#x9875;&#x9762;&#x662F;&#x5426;&#x771F;&#x6B63;&#x7ED8;&#x5236;&#x5B8C;&#x6210;&#x6709;&#x5947;&#x6548;&#x3002; 6. &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD; &#x8FD9;&#x4E9B;&#x5929;&#x8BB2;&#x4E86;&#x4ECE;Android&#x542F;&#x52A8;&#x5230;HomeActivity&#x7684;&#x542F;&#x52A8;&#xFF0C;&#x53C8;&#x4ECE;HomeActivity&#x542F;&#x52A8;&#x8FC7;&#x7A0B;&#x5F00;&#x59CB;&#x5206;&#x6790;Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#xFF0C;&#x63A5;&#x7740;&#x8FD9;&#x7BC7;&#x8BB2;&#x89E3;&#x4E86;Activity&#x4ECE;&#x521B;&#x5EFA;&#x5230;&#x663E;&#x793A;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x4F46;&#x662F;&#x5E76;&#x6CA1;&#x6709;&#x5B8C;&#x5168;&#x5B8C;&#x6210;&#x3002;&#x8FD9;&#x91CC;&#x53EA;&#x8BB2;&#x5230;&#x4E86;&#x6267;&#x884C;&#x8FD9;&#x4E9B;&#x65B9;&#x6CD5;&#x4F1A;&#x5C06;&#x9875;&#x9762;&#x663E;&#x793A;&#xFF0C;&#x4F46;&#x662F;&#x5177;&#x4F53;&#x5982;&#x4F55;&#x663E;&#x793A;&#x6CA1;&#x6709;&#x8BF4;&#x660E;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#x5E94;&#x8BE5;&#x5C06;&#x7684;&#x5C31;&#x662F;&#x8FD9;&#x4E2A;&#x9875;&#x9762;&#x5982;&#x4F55;&#x7ED8;&#x5236;&#x5E76;&#x5C55;&#x793A;&#x51FA;&#x6765;&#x3002;&#x5C31;&#x8FD9;&#x6837;&#x3002;","tags":[]},{"title":"从源码分析Activity启动时的生命周期","date":"2017-11-13T15:02:07.760Z","path":"2017/11/13/ActivityLifeCycle/","text":"&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x6700;&#x8FD1;&#x9AD8;&#x4EA7;&#x4F3C;&#x6BCD;&#x732A;&#xFF0C;&#x6BCF;&#x5929;&#x90FD;&#x4F1A;&#x5199;&#x70B9;&#x5173;&#x4E8E;&#x8FD9;&#x4E2A;&#x7CFB;&#x5217;&#x7684;&#x603B;&#x7ED3;&#x3002;&#x5468;&#x4E00;&#x4E86;&#xFF0C;&#x53C8;&#x5F00;&#x59CB;&#x5FD9;&#x788C;&#x7684;&#x4E00;&#x5929;&#x3002;&#x9879;&#x76EE;&#x8D76;&#x8D76;&#x8D76;&#xFF0C;bug&#x6539;&#x6539;&#x6539;&#xFF0C;&#x76FC;&#x671B;&#x7740;&#x76FC;&#x671B;&#x7740;&#xFF0C;&#x7EC8;&#x4E8E;&#x4E0B;&#x73ED;&#x4E86;&#x3002;&#x7A81;&#x7136;&#x60F3;&#x8D77;&#x5C0F;&#x65F6;&#x5019;&#x5B66;&#x8FC7;&#x7684;&#x4E00;&#x7BC7;&#x8BFE;&#x6587;&#x300A;&#x548C;&#x65F6;&#x95F4;&#x8D5B;&#x8DD1;&#x300B;&#xFF0C;&#x8D8A;&#x6765;&#x8D8A;&#x89C9;&#x5F97;&#x201C;&#x5149;&#x9634;&#x4F3C;&#x7BAD;&#xFF0C;&#x65E5;&#x6708;&#x5982;&#x68AD;&#x201D;&#x4E86;&#x3002;&#x8FD8;&#x4EE5;&#x4E3A;&#x662F;&#x90A3;&#x4E2A;&#x521A;&#x521A;&#x6765;&#x5230;&#x9B54;&#x90FD;&#x7684;&#x6BDB;&#x5934;&#x5C0F;&#x5B50;&#xFF0C;&#x7A81;&#x7136;&#x95F4;&#x53D1;&#x73B0;&#xFF0C;&#x73B0;&#x5728;&#x5DF2;&#x7136;&#x53D8;&#x6210;&#x4E86;&#x201C;&#x7325;&#x7410;&#x5927;&#x53D4;&#x201D;&#x4E86;&#x3002;&#x867D;&#x7136;&#x6211;&#x5E76;&#x4E0D;&#x7325;&#x7410;&#xFF0C;&#x867D;&#x7136;&#x6211;&#x5E76;&#x4E0D;&#x662F;&#x5927;&#x53D4;&#x3002;&#x5662;&#xFF01;&#x53C8;&#x60F3;&#x8D77;&#x5927;&#x5B66;&#x5BBF;&#x820D;&#x7684;&#x7325;&#x7410;&#x5C0F;&#x54E5;&#x4E86;&#xFF0C;&#x90A3;&#x7325;&#x7410;&#x7684;&#x6837;&#x5B50;&#x2026;..&#x54CE;~&#x4E0D;&#x626F;&#x4E86;&#xFF0C;&#x518D;&#x626F;&#x5C31;&#x4E0D;&#x7528;&#x5199;&#x4E86;&#x3002; 1. &#x5173;&#x4E8E;Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F; &#x81EA;&#x4ECE;&#x5F00;&#x59CB;&#x5165;Android&#x7684;&#x5751;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5C31;&#x4E00;&#x76F4;&#x5FF5;&#x53E8;&#x7740;Activity&#x542F;&#x52A8;&#x65F6;&#x5148;onCreate&#xFF0C;&#x518D;onStart&#xFF0C;&#x6700;&#x540E;onResume&#x3002;&#x5404;&#x4E2A;&#x9636;&#x6BB5;&#x662F;&#x5565;&#x542B;&#x4E49;&#x5177;&#x4F53;&#x4E0D;&#x8BB2;&#x4E86;&#xFF08;&#x6211;&#x4E0D;&#x4F1A;&#x8BF4;&#x6211;&#x4E5F;&#x4E0D;&#x77E5;&#x9053;&#xFF09;&#x3002;&#x4F46;&#x662F;&#xFF0C;&#x81EA;&#x4ECE;&#x5F00;&#x59CB;&#x505A;Android&#x5C31;&#x60F3;&#x8FC7;&#xFF0C;&#x8FD9;&#x51E0;&#x4E2A;&#x65B9;&#x6CD5;&#x7A76;&#x7ADF;&#x662F;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x8C03;&#x7528;&#x7684;&#xFF1F;&#x53C8;&#x662F;&#x8C01;&#x53BB;&#x8C03;&#x7528;&#x7684;&#x4ED6;&#xFF1F;&#x4EE5;&#x524D;&#x5462;&#xFF0C;&#x81EA;&#x5DF1;&#x592A;&#x83DC;&#x4E86;&#xFF08;&#x867D;&#x7136;&#x73B0;&#x5728;&#x4E5F;&#x662F;&#x3002;&#x3002;&#xFF09;&#xFF0C;&#x6839;&#x672C;&#x6CA1;&#x6709;&#x597D;&#x597D;&#x53BB;&#x770B;&#xFF0C;&#x6700;&#x8FD1;&#x6709;&#x65F6;&#x95F4;&#x597D;&#x597D;&#x603B;&#x7ED3;&#x4E0B;&#x5173;&#x4E8E;&#x8FD9;&#x65B9;&#x9762;&#x7684;&#x77E5;&#x8BC6;&#x3002;&#x5728;&#x524D;&#x9762;&#x7684;Android&#x7684;luncher&#x542F;&#x52A8;&#x8FC7;&#x7A0B;&#x4E2D;&#x5DF2;&#x7ECF;&#x8BB2;&#x5230;&#xFF0C;Activity&#x542F;&#x52A8;&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x8C03;&#x7528;ApplicationThread&#x7684;scheduleLaunchActivity&#x65B9;&#x6CD5;&#x3002;&#x4E0B;&#x9762;&#x4ECE;&#x8FD9;&#x4E2A;&#x5730;&#x65B9;&#x5F00;&#x59CB;&#x5206;&#x6790;&#x6574;&#x4E2A;&#x8FC7;&#x7A0B;&#x3002; 2. scheduleLaunchActivity&#x65B9;&#x6CD5; &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x5176;&#x5B9E;&#x4E0D;&#x60F3;&#x8BF4;&#x7684;&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x53EA;&#x505A;&#x4E86;&#x4E00;&#x4E2A;&#x64CD;&#x4F5C;&#xFF0C;&#x5C31;&#x662F;&#x901A;&#x8FC7;Handler&#x53D1;&#x9001;LAUNCH_ACTIVITY&#x6D88;&#x606F;&#x3002;123456789101112@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident, ActivityInfo info, Configuration curConfig, Configuration overrideConfig, CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor, int procState, Bundle state, PersistableBundle persistentState, List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents, boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) { //&#x5BF9;&#x53D8;&#x91CF;&#x5404;&#x79CD;&#x8D4B;&#x503C; ...... //&#x53D1;&#x9001;LAUNCH_ACTIVITY&#x6D88;&#x606F;&#xFF0C;&#x5E76;&#x628A;&#x6570;&#x636E;&#x4F20;&#x5165; sendMessage(H.LAUNCH_ACTIVITY, r);} &#x8FD9;&#x91CC;&#x7B80;&#x5355;&#x770B;&#x4E0B;&#x8FD9;&#x4E2A;H&#x662F;&#x4F55;&#x65B9;&#x795E;&#x5723;private class H extends Handler&#xFF0C;&#x597D;&#x4E86;&#x770B;&#x5B8C;&#x4E86;&#x3002;&#x8FD9;&#x5C31;&#x591F;&#x4E86;&#xFF0C;&#x8FD9;&#x5C31;&#x662F;&#x4E2A;Handler&#x3002; 3. Handler&#x5904;&#x7406;LAUNCH_ACTIVITY&#x6D88;&#x606F; &#x8FD9;&#x91CC;&#x9762;&#x5904;&#x7406;&#x4E5F;&#x662F;&#x5F88;&#x7B80;&#x5355;&#x7684;&#xFF0C;&#x8C03;&#x7528;&#x4E86;handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;);&#x65B9;&#x6CD5;&#x3002;12345678910111213141516public void handleMessage(Message msg) { if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what)); switch (msg.what) { case LAUNCH_ACTIVITY: { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); //&#x8C03;&#x7528;ActivityThread&#x7684;handleLaunchActivity&#x65B9;&#x6CD5;&#x3002; handleLaunchActivity(r, null, &quot;LAUNCH_ACTIVITY&quot;); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); } break; &#xFF5D; ......&#xFF5D; 4. handleLaunchActivity&#x65B9;&#x6CD5;&#x548C;performLaunchActivity&#x65B9;&#x6CD5; handleLaunchActivity&#x53C8;&#x8C03;&#x7528;&#x4E86;performLaunchActivity&#x65B9;&#x6CD5;&#x53BB;&#x521B;&#x5EFA;&#xFF0C;&#x5E76;&#x542F;&#x52A8;Activity&#x3002;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent, String reason) { ...... // Initialize before creating the activity WindowManagerGlobal.initialize(); Activity a = performLaunchActivity(r, customIntent); if (a != null) { r.createdConfig = new Configuration(mConfiguration); reportSizeConfigurations(r); Bundle oldState = r.state; //&#x8FD9;&#x91CC;&#x8C03;&#x7528;Activity&#x7684;onResume&#x65B9;&#x6CD5; handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed, r.lastProcessedSeq, reason); ...... } else { //Activity&#x4E3A;null&#xFF0C;&#x5219;&#x4EE3;&#x8868;&#x542F;&#x52A8;&#x51FA;&#x73B0;&#x95EE;&#x9898;&#xFF0C;&#x9700;&#x8981;&#x5173;&#x95ED; try { ActivityManagerNative.getDefault() .finishActivity(r.token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } }}private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { // System.out.println(&quot;##### [&quot; + System.currentTimeMillis() + &quot;] ActivityThread.performLaunchActivity(&quot; + r + &quot;)&quot;); ActivityInfo aInfo = r.activityInfo; //&#x5BF9;&#x5404;&#x79CD;&#x4FE1;&#x606F;&#x7684;&#x975E;&#x7A7A;&#x5224;&#x65AD;&#x4EE5;&#x53CA;&#x4E3A;&#x7A7A;&#x7684;&#x65F6;&#x5019;&#x8D4B;&#x503C; ...... Activity activity = null; try { java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //&#x901A;&#x8FC7;Instrumentation&#x521B;&#x5EFA;&#x65B0;&#x7684;Activity activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } } catch (Exception e) { ...... } try { //&#x521B;&#x5EFA;Application Application app = r.packageInfo.makeApplication(false, mInstrumentation); ...... if (activity != null) { //&#x521B;&#x5EFA;Context Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (r.overrideConfig != null) { config.updateFrom(r.overrideConfig); } //&#x8FD9;&#x4E2A;Window&#x662F;&#x6211;&#x4EEC;&#x663E;&#x793A;&#x7684;&#x7A97;&#x4F53; Window window = null; if (r.mPendingRemoveWindow != null &amp;&amp; r.mPreserveWindow) { window = r.mPendingRemoveWindow; r.mPendingRemoveWindow = null; r.mPendingRemoveWindowManager = null; } //&#x8C03;&#x7528;attach&#x65B9;&#x6CD5; activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor, window); if (customIntent != null) { activity.mIntent = customIntent; } r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) { activity.setTheme(theme); } activity.mCalled = false; //&#x5224;&#x65AD;&#x662F;&#x4E0D;&#x662F;&#x6301;&#x4E45;&#x5316;&#x7684;&#xFF0C;&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x65B0;&#x7684;&#x73B0;&#x573A;&#x4FDD;&#x5B58;&#xFF0C;&#x67E5;&#x4E86;&#x4E0B;&#x8BF4;&#x662F;5.0&#x53CA;&#x4EE5;&#x4E0A;&#x6709;&#x7684;&#x4E00;&#x79CD;&#x66F4;&#x52A0;&#x575A;&#x56FA;&#x7684;&#x4FDD;&#x5B58;&#x6570;&#x636E;&#x65B9;&#x5F0F; //true&#x4F1A;&#x8C03;&#x7528;onCreate(@Nullable Bundle savedInstanceState,@Nullable PersistableBundle persistentState) //false&#x4F1A;&#x8C03;&#x7528;onCreate(@Nullable Bundle savedInstanceState) if (r.isPersistable()) { mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onCreate()&quot;); } r.activity = activity; r.stopped = true; //&#x8FD9;&#x91CC;&#x4F1A;&#x8C03;&#x7528;onStart&#x65B9;&#x6CD5; if (!r.activity.mFinished) { activity.performStart(); r.stopped = false; } //&#x8C03;&#x7528;onRestoreInstanceState&#x65B9;&#x6CD5;&#xFF0C;&#x5F53;&#x7136;&#x8FD9;&#x4E2A;&#x662F;&#x5728;re-initialized&#x72B6;&#x6001;&#x4E0B;&#xFF0C;&#x5373;&#x91CD;&#x65B0;&#x521D;&#x59CB;&#x5316; if (!r.activity.mFinished) { if (r.isPersistable()) { if (r.state != null || r.persistentState != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); } } else if (r.state != null) { mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); } } //onPostCreate&#x8FD9;&#x4E2A;&#x4F1A;&#x5728;&#x7A0B;&#x5E8F;&#x5B8C;&#x5168;&#x8FD0;&#x884C;&#x8D77;&#x6765;&#x8C03;&#x7528;&#xFF0C;onStart&#x4EE5;&#x540E;&#x3002;&#x597D;&#x50CF;&#x5F88;&#x5C11;&#x7528; if (!r.activity.mFinished) { activity.mCalled = false; if (r.isPersistable()) { mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnPostCreate(activity, r.state); } if (!activity.mCalled) { throw new SuperNotCalledException( &quot;Activity &quot; + r.intent.getComponent().toShortString() + &quot; did not call through to super.onPostCreate()&quot;); } } } r.paused = true; mActivities.put(r.token, r); } catch (SuperNotCalledException e) { throw e; } catch (Exception e) { ...... } return activity;}Instrumentation.javapublic Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException { //&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x521B;&#x5EFA;Activity return (Activity)cl.loadClass(className).newInstance();} &#x4ECE;&#x4E0A;&#x9762;&#x7684;&#x5206;&#x6790;&#x6765;&#x770B;&#xFF0C;&#x6211;&#x4EEC;&#x663E;&#x793A;&#x4F7F;&#x7528;Instrumentation.newActivity&#x65B9;&#x6CD5;&#xFF0C;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;Activity&#x5BF9;&#x8C61;&#xFF0C;&#x63A5;&#x7740;&#x4F1A;&#x8C03;&#x7528;attach&#x8FD9;&#x4E2A;&#x9690;&#x85CF;&#x65B9;&#x6CD5;&#x3002;&#x4E4B;&#x540E;&#x6839;&#x636E;&#x662F;&#x5426;&#x662F;&#x5F02;&#x5E38;&#x72B6;&#x6001;&#x6062;&#x590D;&#xFF0C;&#x53BB;&#x6389;&#x7528;onCreate&#x65B9;&#x6CD5;&#xFF0C;&#x63A5;&#x7740;&#x8C03;&#x7528;onStart&#x65B9;&#x6CD5;&#xFF0C;&#x5982;&#x679C;&#x662F;&#x5728;&#x91CD;&#x65B0;&#x521D;&#x59CB;&#x5316;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5219;&#x4F1A;&#x8C03;&#x7528;callActivityOnRestoreInstanceState&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x540E;&#x5728;&#x7A0B;&#x5E8F;&#x5B8C;&#x5168;&#x8FD0;&#x884C;&#x8D77;&#x6765;&#x8C03;&#x8C03;&#x7528;Activity&#x7684;callActivityOnPostCreate&#xFF08;&#x8FD9;&#x4E2A;&#x5F88;&#x5C11;&#x7528;&#x5230;&#x554A;&#xFF09;&#x3002; 5. &#x8FD8;&#x662F;&#x5148;&#x8BF4;&#x4E0B; onResume &#x5728;&#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x6267;&#x884C;&#x5B8C;performLaunchActivity&#x65B9;&#x6CD5;&#x4F1A;&#x6267;&#x884C;handleResumeActivity&#x65B9;&#x6CD5;&#x3002;&#x5728;&#x8FD9;&#x91CC;&#xFF0C;&#x6211;&#x4EEC;&#x662F;&#x6267;&#x884C;&#x4E86;Activity&#x7684;onResume&#x65B9;&#x6CD5;&#x3002;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume, int seq, String reason) { ActivityClientRecord r = mActivities.get(token); ...... //&#x6267;&#x884C;onResume&#x65B9;&#x6CD5; r = performResumeActivity(token, clearHide, reason); //onResume&#x662F;activity&#x4E0E;&#x7528;&#x6237;&#x80FD;&#x8FDB;&#x884C;&#x4EA4;&#x4E92;&#x65F6;&#x88AB;&#x6267;&#x884C;&#xFF0C;&#x7528;&#x6237;&#x53EF;&#x4EE5;&#x83B7;&#x5F97;activity&#x7684;&#x7126;&#x70B9;&#xFF0C;&#x80FD;&#x591F;&#x4E0E;&#x7528;&#x6237;&#x4EA4;&#x4E92; if (r != null) { final Activity a = r.activity; final int forwardBit = isForward ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : 0; boolean willBeVisible = !a.mStartedActivity; ...... //&#x901A;&#x8FC7;ViewManager&#x6216;&#x8005;&#x8BF4;WindowManager&#x5C06;&#x8981;&#x663E;&#x793A;&#x7684;Activity&#x663E;&#x793A;&#x51FA;&#x6765;&#xFF0C;&#x8FD9;&#x91CC;&#x4EE5;&#x540E;&#x5E94;&#x8BE5;&#x4F1A;&#x5206;&#x6790;&#xFF0C;&#x4E0D;&#x6025;&#x4E0D;&#x6025; if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) { r.window = r.activity.getWindow(); View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; if (r.mPreserveWindow) { a.mWindowAdded = true; r.mPreserveWindow = false; ViewRootImpl impl = decor.getViewRootImpl(); if (impl != null) { impl.notifyChildRebuilt(); } } if (a.mVisibleFromClient &amp;&amp; !a.mWindowAdded) { a.mWindowAdded = true; wm.addView(decor, l); } } else if (!willBeVisible) { if (localLOGV) Slog.v( TAG, &quot;Launch &quot; + r + &quot; mStartedActivity set&quot;); r.hideForNow = true; } ...... if (!r.onlyLocalRequest) { r.nextIdle = mNewActivities; mNewActivities = r; Looper.myQueue().addIdleHandler(new Idler()); } r.onlyLocalRequest = false; // Tell the activity manager we have resumed. if (reallyResume) { try { //&#x901A;&#x8FC7;AMS&#x8BBE;&#x7F6E;&#x72B6;&#x6001; ActivityManagerNative.getDefault().activityResumed(token); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } } } else { //&#x548C;&#x542F;&#x52A8;&#x4E00;&#x6837;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x95EE;&#x9898;&#x5219;&#x7ED3;&#x675F;&#x6389; try { ActivityManagerNative.getDefault() .finishActivity(token, Activity.RESULT_CANCELED, null, Activity.DONT_FINISH_TASK_WITH_ACTIVITY); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } }} 6. &#x603B;&#x7ED3; &#x54A6;&#xFF1F;&#x597D;&#x50CF;&#x6709;&#x70B9;&#x4E0D;&#x5BF9;&#xFF0C;&#x5982;&#x679C;&#x662F;&#x542F;&#x52A8;&#x65B0;&#x7684;Activity&#x65F6;&#xFF0C;&#x4F1A;&#x8C03;&#x7528;&#x4E0A;&#x4E00;&#x4E2A;&#x9875;&#x9762;&#x7684;onStop&#x65B9;&#x6CD5;&#x554A;&#xFF1F;&#x4E0D;&#x5BF9;&#x554A;&#xFF0C;&#x770B;&#x770B;&#x600E;&#x4E48;&#x7F16;&#x4E0B;&#x53BB;&#x5427;&#x3002; 7. &#x8FDF;&#x5230;&#x7684;onStop &#x5176;&#x5B9E;&#x8FD9;&#x4E2A;onStop&#x8C03;&#x7528;&#x65F6;&#x673A;&#x6211;&#x5728;&#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x4E5F;&#x5C55;&#x793A;&#x51FA;&#x6765;&#x4E86;&#xFF0C;&#x53EA;&#x4E0D;&#x8FC7;&#x6CA1;&#x6709;&#x6807;&#x660E;&#x3002;&#x5C31;&#x5728;&#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x4E2D;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293Looper.myQueue().addIdleHandler(new Idler());private class Idler implements MessageQueue.IdleHandler { @Override public final boolean queueIdle() { ActivityClientRecord a = mNewActivities; boolean stopProfiling = false; if (mBoundApplication != null &amp;&amp; mProfiler.profileFd != null &amp;&amp; mProfiler.autoStopProfiler) { stopProfiling = true; } if (a != null) { mNewActivities = null; IActivityManager am = ActivityManagerNative.getDefault(); ActivityClientRecord prev; do { if (a.activity != null &amp;&amp; !a.activity.mFinished) { try { //&#x901A;&#x8FC7;AMS&#x8C03;&#x7528;activityIdle&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x7EC8;&#x4F1A;&#x6267;&#x884C;onStop&#x65B9;&#x6CD5; am.activityIdle(a.token, a.createdConfig, stopProfiling); a.createdConfig = null; } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } } prev = a; a = a.nextIdle; prev.nextIdle = null; } while (a != null); } ...... return false; }}AMS:@Overridepublic final void activityIdle(IBinder token, Configuration config, boolean stopProfiling) { final long origId = Binder.clearCallingIdentity(); synchronized (this) { ActivityStack stack = ActivityRecord.getStackLocked(token); //&#x8C03;&#x7528;StackSupervisor.activityIdleInternalLocked&#x65B9;&#x6CD5; if (stack != null) { ActivityRecord r = mStackSupervisor.activityIdleInternalLocked(token, false, config); if (stopProfiling) { if ((mProfileProc == r.app) &amp;&amp; (mProfileFd != null)) { try { mProfileFd.close(); } catch (IOException e) { } clearProfilerLocked(); } } } } Binder.restoreCallingIdentity(origId);}ActivityStackSupervisor.javafinal ActivityRecord activityIdleInternalLocked(final IBinder token, boolean fromTimeout, Configuration config) { ...... for (int i = 0; i &lt; NS; i++) { r = stops.get(i); final ActivityStack stack = r.task.stack; if (stack != null) { if (r.finishing) { stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false); } else { //&#x8FD9;&#x91CC;&#x53BB;&#x771F;&#x6B63;stop Activity stack.stopActivityLocked(r); } } } ...... return r;}ActivityStack.javafinal void stopActivityLocked(ActivityRecord r) { if (r.app != null &amp;&amp; r.app.thread != null) { adjustFocusedActivityLocked(r, &quot;stopActivity&quot;); r.resumeKeyDispatchingLocked(); try { ...... //&#x8C03;&#x7528;ApplicationThread&#x7684;scheduleStopActivity&#x65B9;&#x6CD5;&#xFF0C;&#x771F;&#x6B63;stop activity r.app.thread.scheduleStopActivity(r.appToken, r.visible, r.configChangeFlags); ...... } catch (Exception e) { } }} &#x4E0A;&#x9762;&#x4E00;&#x5927;&#x90E8;&#x5206;&#x5C31;&#x662F;&#x5173;&#x4E8E;onStop&#x7684;&#x5927;&#x4F53;&#x8FC7;&#x7A0B;&#xFF0C;&#x5148;&#x662F;&#x5C06;Activity resume&#x540E;&#x5C06;Idler&#xFF08;&#x8FD9;&#x4E2A;&#x610F;&#x601D;&#x61D2;&#x6C49;&#xFF0C;&#x65E0;&#x6240;&#x4E8B;&#x4E8B;&#x7684;&#x4EBA;&#xFF09;&#x653E;&#x5230;&#x6D88;&#x606F;&#x961F;&#x5217;&#x4E2D;&#xFF0C;&#x5F53;&#x6D88;&#x606F;&#x8FDB;&#x884C;&#x6267;&#x884C;&#x662F;&#xFF0C;&#x4F1A;&#x6267;&#x884C;&#x5176;&#x4E2D;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;AMS&#x8C03;&#x7528;activityIdle&#x65B9;&#x6CD5;&#xFF0C;AMS&#x53C8;&#x8C03;&#x7528;ActivityStackSupervisor&#x7684;activityIdleInternalLocked&#x65B9;&#x6CD5;&#xFF0C;&#x800C;activityIdleInternalLocked&#x65B9;&#x6CD5;&#x53C8;&#x4F1A;&#x8C03;&#x7528;ActivityStack&#x7684;stopActivityLocked&#x65B9;&#x6CD5;&#xFF0C;&#x53C8;&#x8DD1;&#x5230;ApplicationThread&#x4E2D;&#x7684;scheduleStopActivity&#x65B9;&#x6CD5;&#x53BB;&#x771F;&#x6B63;stop activity&#x3002;&#x4E0B;&#x9762;&#x7B80;&#x5355;&#x770B;&#x4E0B;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x8FC7;&#x7A0B;&#x3002; 8. onStop&#x771F;&#x6B63;&#x6267;&#x884C;&#x8FC7;&#x7A0B; &#x8FD9;&#x91CC;&#x5C31;&#x7B80;&#x5355;&#x770B;&#x4E0B;&#xFF0C;&#x65E0;&#x975E;&#x8FD8;&#x662F;&#x901A;&#x8FC7;Handler&#x53D1;&#x9001;&#x6D88;&#x606F;&#xFF0C;&#x5728;&#x6D88;&#x606F;&#x6267;&#x884C;&#x662F;&#x8C03;&#x7528;ActivityThread&#x7684;&#x65B9;&#x6CD5;&#x53BB;&#x6267;&#x884C;stop&#x3002;&#x4E0B;&#x9762;&#x770B;&#x4E0B;&#x6E90;&#x7801;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445public final void scheduleStopActivity(IBinder token, boolean showWindow, int configChanges) { int seq = getLifecycleSeq(); if (DEBUG_ORDER) Slog.d(TAG, &quot;stopActivity &quot; + ActivityThread.this + &quot; operation received seq: &quot; + seq); sendMessage( showWindow ? H.STOP_ACTIVITY_SHOW : H.STOP_ACTIVITY_HIDE, token, 0, configChanges, seq);}private void handleStopActivity(IBinder token, boolean show, int configChanges, int seq) { ...... //&#x771F;&#x6B63;&#x6267;&#x884C;stop performStopActivityInner(r, info, show, true, &quot;handleStopActivity&quot;); ......}private void performStopActivityInner(ActivityClientRecord r, StopInfo info, boolean keepShown, boolean saveState, String reason) { ...... //&#x5982;&#x679C;&#x6709;&#x5FC5;&#x8981;&#x5148;&#x6267;&#x884C;pause&#x65B9;&#x6CD5; performPauseActivityIfNeeded(r, reason); ...... // Next have the activity save its current state and managed dialogs... if (!r.activity.mFinished &amp;&amp; saveState) { if (r.state == null) { callCallActivityOnSaveInstanceState(r); } } if (!keepShown) { try { // &#x6267;&#x884C;onStop&#x65B9;&#x6CD5; r.activity.performStop(false /*preserveWindow*/); } catch (Exception e) { if (!mInstrumentation.onException(r.activity, e)) { throw new RuntimeException( &quot;Unable to stop activity &quot; + r.intent.getComponent().toShortString() + &quot;: &quot; + e.toString(), e); } } r.stopped = true; } }} &#x6574;&#x4E2A;&#x6D41;&#x7A0B;&#x5927;&#x6982;&#x5C31;&#x8FD9;&#x6837;&#xFF0C;Activity&#x7684;&#x751F;&#x547D;&#x5468;&#x671F;&#x57FA;&#x672C;&#x6267;&#x884C;&#x5B8C;&#x6210;&#x4E86;&#x3002; 9. &#x6211;&#x8FD8;&#x6709;&#x8BDD;&#x8BF4; &#x5173;&#x4E8E;Instrumentation&#x7684;&#x5404;&#x79CD;&#x65B9;&#x6CD5;&#xFF0C;&#x4E3E;&#x4E2A;&#x4F8B;&#x5B50;&#x6765;&#x8BF4;&#xFF0C;&#x4F8B;&#x5982;Instrumentation.callActivityOnCreate(activity, r.state)&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x91CC;&#x4F1A;&#x6267;&#x884C;12345678910111213141516public void callActivityOnCreate(Activity activity, Bundle icicle) { //&#x521B;&#x5EFA;&#x524D; prePerformCreate(activity); //&#x6267;&#x884C;onCreate&#x65B9;&#x6CD5; activity.performCreate(icicle); //&#x521B;&#x5EFA;&#x5B8C;&#x6210; postPerformCreate(activity);}Activity.javafinal void performCreate(Bundle icicle) { restoreHasCurrentPermissionRequest(icicle); //&#x771F;&#x6B63;&#x6267;&#x884C;onCreate onCreate(icicle); mActivityTransitionState.readState(icicle); performCreateCommon();} &#x8FD9;&#x4E2A;Instrumentation&#x53EF;&#x4EE5;&#x8BF4;&#x662F;&#x4E2A;&#x5C0F;&#x79D8;&#x4E66;&#xFF0C;&#x6211;&#x53EF;&#x4EE5;&#x66FF;&#x5927;&#x8001;&#x677F;&#x6267;&#x884C;&#x4EFB;&#x52A1;&#xFF0C;&#x5E76;&#x4E14;&#x5728;&#x6267;&#x884C;&#x4EFB;&#x52A1;&#x524D;&#x540E;&#x6084;&#x6084;&#x7684;&#x505A;&#x70B9;&#x4E8B;&#x60C5;&#xFF0C;&#x8FD9;&#x611F;&#x89C9;&#x5C31;&#x662F;&#x4EE3;&#x7406;&#x6A21;&#x5F0F;&#x554A;&#xFF01;&#xFF01; &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD; &#x6709;&#x5B8C;&#x6CA1;&#x5B8C;&#x4E86;&#x554A;&#x3002;&#x597D;&#x5427;&#xFF0C;&#x771F;&#x7684;&#x7ED3;&#x675F;&#x4E86;&#x3002;&#x540E;&#x9762;&#x8FD8;&#x662F;&#x4F1A;&#x6709;&#x5206;&#x6790;&#xFF0C;&#x6574;&#x7406;&#x6574;&#x7406;&#x601D;&#x8DEF;&#xFF0C;&#x8D76;&#x660E;&#x518D;&#x51FA;&#x53D1;&#x3002;","tags":[]},{"title":"HomeActivity启动流程（launcher）","date":"2017-11-12T16:34:34.929Z","path":"2017/11/13/luncher/","text":"0. &#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x4E0A;&#x4E00;&#x7BC7;&#x8BB2;&#x4E86;&#x5404;&#x79CD;Service&#x662F;&#x5728;&#x4F55;&#x65F6;&#x542F;&#x52A8;&#x7684;&#xFF0C;&#x6700;&#x540E;&#x63D0;&#x5230;&#x4E86;&#x5173;&#x4E8E;HomeActivity&#x7684;&#x542F;&#x52A8;&#x3002;HomeActivity&#x4F5C;&#x4E3A;Android&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#x540E;&#x7B2C;&#x4E00;&#x4E2A;&#x52A0;&#x8F7D;&#x7684;Activity&#xFF0C;&#x4ECA;&#x5929;&#x5C31;&#x6765;&#x5206;&#x6790;&#x4E0B;&#x5176;&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#x3002;&#x5176;&#x5B9E;&#x8FD8;&#x6709;&#x4E2A;&#x65F6;&#x5E8F;&#x56FE;&#x7684;&#xFF0C;&#x4F46;&#x662F;&#x592A;&#x5927;&#x4E86;&#xFF0C;&#x622A;&#x56FE;&#x4E5F;&#x4E0D;&#x5168;&#xFF0C;&#x7B49;&#x4E0B;&#x6B21;&#x76F4;&#x63A5;&#x4E0A;&#x4F20;&#xFF0C;&#x65B9;&#x4FBF;&#x81EA;&#x5DF1;&#x67E5;&#x770B;&#x3002;&#x6682;&#x65F6;&#x7684;&#x89C4;&#x5212;&#x5148;&#x662F;Activity&#x7684;&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#xFF0C;&#x901A;&#x8FC7;&#x8FD9;&#x4E2A;&#x53C8;&#x4F1A;&#x6D89;&#x53CA;&#x5230;&#x8FDB;&#x7A0B;&#x95F4;&#x901A;&#x4FE1;&#x2014;&#x2014;Binder&#x673A;&#x5236;&#xFF0C;&#x63A5;&#x7740;Activity&#x542F;&#x52A8;&#x540E;&#xFF0C;&#x5E03;&#x5C40;&#x662F;&#x5982;&#x4F55;&#x7ED8;&#x5236;&#x5230;&#x5C4F;&#x5E55;&#x4E0A;&#xFF0C;View&#x7684;&#x4E8B;&#x4EF6;&#x662F;&#x5982;&#x4F55;&#x5206;&#x53D1;&#x7684;&#xFF1F;&#x901A;&#x8FC7;&#x8FD9;&#x6761;&#x7EBF;&#x6765;&#x6162;&#x6162;&#x6574;&#x7406;&#x8FD9;&#x4E24;&#x5E74;&#x591A;&#x6211;&#x5BF9;Android&#x7684;&#x7406;&#x89E3;&#xFF0C;&#x52A0;&#x6DF1;&#x81EA;&#x5DF1;&#x7684;&#x5370;&#x8C61;&#x3002; 1. ActivityManagerService.systemReady(new Runnable())&#x505A;&#x4E86;&#x4EC0;&#x4E48;&#xFF1F; &#x6211;&#x4EEC;&#x5148;&#x6765;&#x770B;&#x4E0B;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x7684;&#x4EE3;&#x7801;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void systemReady(final Runnable goingCallback) { synchronized(this) { //mSystemReady&#x9ED8;&#x8BA4;&#x4E3A;false&#xFF0C;&#x6240;&#x4EE5;&#x7B2C;&#x4E00;&#x6B21;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x65F6;&#x4E0D;&#x4F1A;&#x6267;&#x884C;goingCallback.run() if (mSystemReady) { if (goingCallback != null) { goingCallback.run(); } return; } ...... } //&#x8981;&#x6740;&#x6389;&#x7684;&#x8FDB;&#x7A0B;&#xFF08;&#x542F;&#x52A8;&#x65F6;&#x4E0D;&#x5141;&#x8BB8;&#x542F;&#x52A8;&#x7684;&#x8FDB;&#x7A0B;&#xFF09; ArrayList&lt;ProcessRecord&gt; procsToKill = null; synchronized(mPidsSelfLocked) { for (int i=mPidsSelfLocked.size()-1; i&gt;=0; i--) { ProcessRecord proc = mPidsSelfLocked.valueAt(i); if (!isAllowedWhileBooting(proc.info)){ if (procsToKill == null) { procsToKill = new ArrayList&lt;ProcessRecord&gt;(); } procsToKill.add(proc); } } } //&#x6740;&#x6389;&#x8FD9;&#x4E9B;&#x8FDB;&#x7A0B; synchronized(this) { if (procsToKill != null) { for (int i=procsToKill.size()-1; i&gt;=0; i--) { ProcessRecord proc = procsToKill.get(i); Slog.i(TAG, &quot;Removing system update proc: &quot; + proc); removeProcessLocked(proc, true, false, &quot;system update done&quot;); } } // Now that we have cleaned up any update processes, we // are ready to start launching real processes and know that // we won&apos;t trample on them any more. mProcessesReady = true; } ...... //&#x8FD9;&#x91CC;&#x4F1A;&#x8C03;&#x7528;Runnable&#x7684;run()&#x65B9;&#x6CD5; if (goingCallback != null) goingCallback.run(); ...... synchronized (this) { //&#x542F;&#x52A8;&#x5E38;&#x9A7B;&#x7684;&#x5E94;&#x7528; startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE); mBooting = true; if (UserManager.isSplitSystemUser()) { ComponentName cName = new ComponentName(mContext, SystemUserHomeActivity.class); try { //&#x89E3;&#x7981;SystemUserHomeActivity AppGlobals.getPackageManager().setComponentEnabledSetting(cName, PackageManager.COMPONENT_ENABLED_STATE_ENABLED, 0, UserHandle.USER_SYSTEM); } catch (RemoteException e) { throw e.rethrowAsRuntimeException(); } } //&#x5F00;&#x59CB;&#x542F;&#x52A8;HomeActivity startHomeActivityLocked(currentUserId, &quot;systemReady&quot;); ...... }} &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x5185;&#x5BB9;&#x633A;&#x591A;&#x7684;&#xFF0C;&#x9996;&#x6B21;&#x8FDB;&#x5165;&#x662F;&#x8BBE;&#x7F6E;&#x7684;Runnable&#x4E0D;&#x4F1A;&#x6267;&#x884C;&#xFF0C;&#x540E;&#x9762;&#x901A;&#x8FC7;&#x67E5;&#x627E;&#x542F;&#x52A8;&#x65F6;&#x7CFB;&#x7EDF;&#x4E0D;&#x5141;&#x8BB8;&#x542F;&#x52A8;&#x7684;&#x8FDB;&#x7A0B;&#xFF0C;&#x5E76;&#x5C06;&#x5176;kill&#x6389;&#x3002;&#x63A5;&#x4E0B;&#x6765;&#x542F;&#x52A8;&#x4E86;&#x7CFB;&#x7EDF;&#x5E38;&#x9A7B;&#x5E94;&#x7528;startPersistentApps(PackageManager.MATCH_DIRECT_BOOT_AWARE)&#xFF0C;&#x901A;&#x8FC7;&#x4F7F;&#x7528;AppGlobals.getPackageManager().setComponentEnabledSetting&#x65B9;&#x6CD5;&#x89E3;&#x7981;SystemUserHomeActivity&#xFF0C;&#x5176;flag&#x4E3A;PackageManager.COMPONENT_ENABLED_STATE_ENABLED&#xFF0C;&#x6700;&#x540E;&#x901A;&#x8FC7;startHomeActivityLocked(currentUserId, &quot;systemReady&quot;)&#x6765;&#x542F;&#x52A8;HomeActivity&#x3002; 2. startHomeActivityLocked&#x5F00;&#x59CB;&#x542F;&#x52A8;HomeActivity &#x8FD9;&#x91CC;&#x7684;&#x4EE3;&#x7801;&#x4E0D;&#x591A;&#xFF0C;&#x4E5F;&#x5F88;&#x597D;&#x7406;&#x89E3;&#xFF1A; 12345678910111213141516171819202122232425262728293031323334353637383940414243boolean startHomeActivityLocked(int userId, String reason) { //&#x6D4B;&#x8BD5;&#x6A21;&#x5F0F;&#x4E0B;&#x4E0D;&#x7528;&#x7BA1; if (mFactoryTest == FactoryTest.FACTORY_TEST_LOW_LEVEL &amp;&amp; mTopAction == null) { // We are running in factory test mode, but unable to find // the factory test app, so just sit around displaying the // error message and don&apos;t try to start anything. return false; } //&#x5F97;&#x5230;&#x8981;&#x542F;&#x52A8;Activity&#x7684;Intent Intent intent = getHomeIntent(); //&#x5C06;Intent&#x89E3;&#x6790;&#x6210;ActivityInfo ActivityInfo aInfo = resolveActivityInfo(intent, STOCK_PM_FLAGS, userId); if (aInfo != null) { intent.setComponent(new ComponentName(aInfo.applicationInfo.packageName, aInfo.name)); // Don&apos;t do this if the home app is currently being // instrumented. aInfo = new ActivityInfo(aInfo); aInfo.applicationInfo = getAppInfoForUser(aInfo.applicationInfo, userId); ProcessRecord app = getProcessRecordLocked(aInfo.processName, aInfo.applicationInfo.uid, true); if (app == null || app.instrumentationClass == null) { intent.setFlags(intent.getFlags() | Intent.FLAG_ACTIVITY_NEW_TASK); //&#x542F;&#x52A8;Activity mActivityStarter.startHomeActivityLocked(intent, aInfo, reason); } } else { Slog.wtf(TAG, &quot;No home screen found for &quot; + intent, new Throwable()); } return true;}Intent getHomeIntent() { Intent intent = new Intent(mTopAction, mTopData != null ? Uri.parse(mTopData) : null); intent.setComponent(mTopComponent); intent.addFlags(Intent.FLAG_DEBUG_TRIAGED_MISSING); //&#x4E0D;&#x662F;&#x6D4B;&#x8BD5;&#x60C5;&#x51B5;&#x4E0B;&#x5219;&#x8BBE;&#x7F6E;Category&#x4E3A;Intent.CATEGORY_HOME if (mFactoryTest != FactoryTest.FACTORY_TEST_LOW_LEVEL) { intent.addCategory(Intent.CATEGORY_HOME); } return intent;} &#x9996;&#x5148;&#x662F;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x7CFB;&#x7EDF;&#x662F;&#x5426;&#x5904;&#x4E8E;&#x6D4B;&#x8BD5;&#x73AF;&#x5883;&#xFF0C;&#x63A5;&#x7740;&#x53BB;&#x83B7;&#x53D6;&#xFF08;&#x521B;&#x5EFA;&#xFF09;HomeIntent&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x89E3;&#x6790;&#x6210;ActivityInfo&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x8C03;&#x7528;ActivityStarter&#x4E2D;&#x7684;startHomeActivityLocked(intent, aInfo, reason)&#x65B9;&#x6CD5;&#x53BB;&#x542F;&#x52A8;HomeActivity&#x3002; 3. startHomeActivityLocked&#x548C;startActivityLocked &#x6211;&#x4EEC;&#x8FDB;&#x5165;ActivityStarter&#x4E2D;&#x53EF;&#x4EE5;&#x770B;&#x5230;startHomeActivityLocked&#x8C03;&#x7528;&#x4E86;startActivityLocked&#x65B9;&#x6CD5;&#xFF0C;&#x5176;&#x4E2D;&#x4F20;&#x5165;&#x7684;&#x53C2;&#x6570;&#x53EA;&#x6709;Intent&#x548C;ActivityInfo&#x4E0D;&#x4E3A;&#x7A7A;&#xFF0C;&#x5176;&#x4ED6;&#x7684;&#x90FD;&#x4E3A;null&#x6216;&#x8005;0&#x6216;&#x8005;false&#xFF0C;&#x7531;&#x4E8E;&#x5927;&#x90E8;&#x5206;&#x53C2;&#x6570;&#x90FD;&#x4E3A;null&#xFF0C;startActivityLocked&#x4E2D;&#x771F;&#x6B63;&#x6267;&#x884C;&#x7684;&#x4EE3;&#x7801;&#x5E76;&#x4E0D;&#x662F;&#x5F88;&#x591A;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109void startHomeActivityLocked(Intent intent, ActivityInfo aInfo, String reason) { mSupervisor.moveHomeStackTaskToTop(HOME_ACTIVITY_TYPE, reason); //&#x8C03;&#x7528;&#x4E86;&#x53C2;&#x6570;&#x5C45;&#x591A;&#x7684;&#x65B9;&#x6CD5; startActivityLocked(null /*caller*/, intent, null /*ephemeralIntent*/, null /*resolvedType*/, aInfo, null /*rInfo*/, null /*voiceSession*/, null /*voiceInteractor*/, null /*resultTo*/, null /*resultWho*/, 0 /*requestCode*/, 0 /*callingPid*/, 0 /*callingUid*/, null /*callingPackage*/, 0 /*realCallingPid*/, 0 /*realCallingUid*/, 0 /*startFlags*/, null /*options*/, false /*ignoreTargetSecurity*/, false /*componentSpecified*/, null /*outActivity*/, null /*container*/, null /*inTask*/); if (mSupervisor.inResumeTopActivity) { // If we are in resume section already, home activity will be initialized, but not // resumed (to avoid recursive resume) and will stay that way until something pokes it // again. We need to schedule another resume. mSupervisor.scheduleResumeTopActivities(); }}//&#x8FD9;&#x4E2A;&#x53C2;&#x6570;&#x662F;&#x771F;TM&#x7684;&#x591A;&#x554A;final int startActivityLocked(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, ActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, ActivityStackSupervisor.ActivityContainer container, TaskRecord inTask) { //&#x542F;&#x52A8;&#x7ED3;&#x679C;&#x4EE3;&#x7801; int err = ActivityManager.START_SUCCESS; ProcessRecord callerApp = null; //caller == null if (caller != null) { ...... } final int userId = aInfo != null ? UserHandle.getUserId(aInfo.applicationInfo.uid) : 0; if (err == ActivityManager.START_SUCCESS) { ..Log.. } ActivityRecord sourceRecord = null; ActivityRecord resultRecord = null; //resultTo == null if (resultTo != null) { ...... } final int launchFlags = intent.getFlags(); //Activity&#x542F;&#x52A8;&#x662F;&#x8BBE;&#x7F6E;&#x7684;flags if ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != 0 &amp;&amp; sourceRecord != null) { ...... } ...... //&#x68C0;&#x67E5;&#x542F;&#x52A8;Activity&#x7684;&#x6743;&#x9650; boolean abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho, requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity, callerApp, resultRecord, resultStack, options); abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid, callingPid, resolvedType, aInfo.applicationInfo); if (mService.mController != null) { try { // The Intent we give to the watcher has the extra data // stripped off, since it can contain private information. Intent watchIntent = intent.cloneFilter(); abort |= !mService.mController.activityStarting(watchIntent, aInfo.applicationInfo.packageName); } catch (RemoteException e) { mService.mController = null; } } ...... // If we have an ephemeral app, abort the process of launching the resolved intent. // Instead, launch the ephemeral installer. Once the installer is finished, it // starts either the intent we resolved here [on install error] or the ephemeral // app [on install success]. if (rInfo != null &amp;&amp; rInfo.ephemeralResolveInfo != null) { intent = buildEphemeralInstallerIntent(intent, ephemeralIntent, rInfo.ephemeralResolveInfo.getPackageName(), callingPackage, resolvedType, userId); resolvedType = null; callingUid = realCallingUid; callingPid = realCallingPid; aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, null /*profilerInfo*/); } //&#x521B;&#x5EFA;&#x4E86;ActivityRecord&#xFF0C;&#x7528;&#x4E8E;&#x5B58;&#x50A8;&#x4FDD;&#x5B58;Activity ActivityRecord r = new ActivityRecord(mService, callerApp, callingUid, callingPackage, intent, resolvedType, aInfo, mService.mConfiguration, resultRecord, resultWho, requestCode, componentSpecified, voiceSession != null, mSupervisor, container, options, sourceRecord); ...... try { mService.mWindowManager.deferSurfaceLayout(); //&#x542F;&#x52A8;Activity err = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true, options, inTask); } finally { mService.mWindowManager.continueSurfaceLayout(); } postStartActivityUncheckedProcessing(r, err, stack.mStackId, mSourceRecord, mTargetStack); return err;} &#x867D;&#x7136;&#x4E0A;&#x9762;&#x7684;&#x65B9;&#x6CD5;&#x53C2;&#x6570;&#x5F88;&#x591A;&#xFF0C;&#x4F46;&#x662F;&#x7531;&#x4E8E;&#x5927;&#x90E8;&#x5206;&#x90FD;&#x4E3A;null&#x6216;&#x8005;0&#xFF0C;&#x6240;&#x4EE5;&#x771F;&#x6B63;&#x6267;&#x884C;&#x7684;&#x90E8;&#x5206;&#x5F88;&#x5C11;&#x3002;&#x5148;&#x8FDB;&#x884C;&#x5BF9;flag&#x7684;&#x68C0;&#x67E5;&#xFF0C;&#x6211;&#x4EEC;&#x7684;intent&#x53EA;&#x8BBE;&#x7F6E;&#x4E86;Intent.FLAG_DEBUG_TRIAGED_MISSING&#xFF0C;&#x6240;&#x4EE5;&#x5BF9;flag&#x5224;&#x65AD;&#x7684;&#x90E8;&#x5206;&#x6267;&#x884C;&#x4E5F;&#x4E0D;&#x6267;&#x884C;&#x3002;&#x6743;&#x9650;&#x68C0;&#x67E5;!mSupervisor.checkStartAnyActivityPermission&#xFF0C;&#x5982;&#x679C;&#x6CA1;&#x6709;&#x6743;&#x9650;&#xFF0C;&#x5219;&#x6700;&#x7EC8;&#x4E0D;&#x4F1A;&#x542F;&#x52A8;&#x3002;&#x6211;&#x4EEC;&#x8981;&#x542F;&#x52A8;&#x7684;&#x662F;HomeActivity&#xFF0C;&#x6240;&#x6709;&#x9700;&#x8981;&#x7684;&#x6743;&#x9650;&#x90FD;&#x6709;&#xFF0C;&#x56E0;&#x6B64;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;ActivityRecord&#xFF0C;&#x7528;&#x4E8E;&#x5B58;&#x653E;Activity&#x7684;&#x4FE1;&#x606F;&#xFF0C;&#x6700;&#x540E;&#x8C03;&#x7528;startActivityUnchecked&#x6267;&#x884C;&#x542F;&#x52A8;&#x8FC7;&#x7A0B;&#x3002; 4. startActivityUnchecked&#x8FC7;&#x7A0B; startActivityUnchecked&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x505A;&#x4E86;&#x5F88;&#x591A;&#x4E8B;&#x60C5;&#xFF0C;&#x5305;&#x62EC;&#x4E86;&#x5BF9;&#x5F53;&#x524D;&#x7684;Activity&#x7684;launchMode&#x7684;&#x8BBE;&#x7F6E;&#x3001;&#x5904;&#x7406;&#xFF0C;&#x6211;&#x4EEC;&#x8981;&#x542F;&#x52A8;&#x7684;&#x662F;HomeActivity&#xFF0C;&#x6240;&#x4EE5;&#x5462;&#xFF0C;&#x6211;&#x4EEC;&#x5E76;&#x4E0D;care&#x8FD9;&#x4E9B;&#x4E1C;&#x897F;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223private int startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask) { //&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x8FD9;&#x91CC;&#x9700;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x4E00;&#x70B9;&#x662F;doResume&#x8FD9;&#x4E2A;&#x53C2;&#x6570;&#x6211;&#x4EEC;&#x4F20;&#x8FC7;&#x6765;&#x7684;&#x662F;true&#xFF0C;&#x4E0B;&#x9762;&#x4F1A;&#x7528;&#x5230; setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession, voiceInteractor); //&#x8BBE;&#x7F6E;launchMode flag computeLaunchingTaskFlags(); computeSourceStack(); mIntent.setFlags(mLaunchFlags); mReusedActivity = getReusableIntentActivity(); final int preferredLaunchStackId = (mOptions != null) ? mOptions.getLaunchStackId() : INVALID_STACK_ID; if (mReusedActivity != null) { // When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but // still needs to be a lock task mode violation since the task gets cleared out and // the device would otherwise leave the locked task. if (mSupervisor.isLockTaskModeViolation(mReusedActivity.task, (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK)) == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) { mSupervisor.showLockTaskToast(); Slog.e(TAG, &quot;startActivityUnchecked: Attempt to violate Lock Task Mode&quot;); return START_RETURN_LOCK_TASK_MODE_VIOLATION; } if (mStartActivity.task == null) { mStartActivity.task = mReusedActivity.task; } if (mReusedActivity.task.intent == null) { // This task was started because of movement of the activity based on affinity... // Now that we are actually launching it, we can assign the base intent. mReusedActivity.task.setIntent(mStartActivity); } // This code path leads to delivering a new intent, we want to make sure we schedule it // as the first operation, in case the activity will be resumed as a result of later // operations. //&#x8FD9;&#x91CC;&#x662F;&#x5904;&#x7406;launchMode&#x4E3A;FLAG_ACTIVITY_CLEAR_TOP&#x7684;&#x60C5;&#x51B5; if ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != 0 || mLaunchSingleInstance || mLaunchSingleTask) { // In this situation we want to remove all activities from the task up to the one // being started. In most cases this means we are resetting the task to its initial // state. final ActivityRecord top = mReusedActivity.task.performClearTaskForReuseLocked( mStartActivity, mLaunchFlags); if (top != null) { if (top.frontOfTask) { // Activity aliases may mean we use different intents for the top activity, // so make sure the task now has the identity of the new intent. top.task.setIntent(mStartActivity); } ActivityStack.logStartActivity(AM_NEW_INTENT, mStartActivity, top.task); //&#x53BB;&#x6389;&#x7528;Activity&#x7684;onNewIntent&#x65B9;&#x6CD5; top.deliverNewIntentLocked(mCallingUid, mStartActivity.intent, mStartActivity.launchedFromPackage); } } sendPowerHintForLaunchStartIfNeeded(false /* forceSend */); mReusedActivity = setTargetStackAndMoveToFrontIfNeeded(mReusedActivity); if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) { ...... } setTaskFromIntentActivity(mReusedActivity); if (!mAddingToTask &amp;&amp; mReuseTask == null) { ...... } } if (mStartActivity.packageName == null) { if (mStartActivity.resultTo != null &amp;&amp; mStartActivity.resultTo.task.stack != null) { mStartActivity.resultTo.task.stack.sendActivityResultLocked( -1, mStartActivity.resultTo, mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED, null); } ActivityOptions.abort(mOptions); //&#x542F;&#x52A8;&#x5931;&#x8D25; return START_CLASS_NOT_FOUND; } // If the activity being launched is the same as the one currently at the top, then // we need to check if it should only be launched once. //&#x5982;&#x679C;&#x5F53;&#x524D;&#x7684;Activity&#x7684;launchModeFLAG_ACTIVITY_SINGLE_TOP&#xFF0C;&#x5E76;&#x4E14;&#x662F;&#x5904;&#x4E8E;&#x4EFB;&#x52A1;&#x6808;&#x7684;&#x6808;&#x9876;&#xFF0C; //&#x5219;&#x4E0D;&#x7528;&#x542F;&#x52A8;&#xFF0C;&#x5E76;&#x8C03;&#x7528;Activity&#x7684;onNewIntent&#x65B9;&#x6CD5; final ActivityStack topStack = mSupervisor.mFocusedStack; final ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop); final boolean dontStart = top != null &amp;&amp; mStartActivity.resultTo == null &amp;&amp; top.realActivity.equals(mStartActivity.realActivity) &amp;&amp; top.userId == mStartActivity.userId &amp;&amp; top.app != null &amp;&amp; top.app.thread != null &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != 0 || mLaunchSingleTop || mLaunchSingleTask); if (dontStart) { ActivityStack.logStartActivity(AM_NEW_INTENT, top, top.task); // For paranoia, make sure we have correctly resumed the top activity. topStack.mLastPausedActivity = null; if (mDoResume) { mSupervisor.resumeFocusedStackTopActivityLocked(); } ActivityOptions.abort(mOptions); if ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != 0) { // We don&apos;t need to start a new activity, and the client said not to do // anything if that is the case, so this is it! return START_RETURN_INTENT_TO_CALLER; } //&#x8C03;&#x7528;Activity&#x7684;onNewIntent&#x65B9;&#x6CD5; top.deliverNewIntentLocked( mCallingUid, mStartActivity.intent, mStartActivity.launchedFromPackage); // Don&apos;t use mStartActivity.task to show the toast. We&apos;re not starting a new activity // but reusing &apos;top&apos;. Fields in mStartActivity may not be fully initialized. mSupervisor.handleNonResizableTaskIfNeeded( top.task, preferredLaunchStackId, topStack.mStackId); return START_DELIVERED_TO_TOP; } boolean newTask = false; final TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != null) ? mSourceRecord.task : null; // Should this be considered a new task? if (mStartActivity.resultTo == null &amp;&amp; mInTask == null &amp;&amp; !mAddingToTask &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != 0) { newTask = true; setTaskFromReuseOrCreateNewTask(taskToAffiliate); if (mSupervisor.isLockTaskModeViolation(mStartActivity.task)) { Slog.e(TAG, &quot;Attempted Lock Task Mode violation mStartActivity=&quot; + mStartActivity); return START_RETURN_LOCK_TASK_MODE_VIOLATION; } if (!mMovedOtherTask) { // If stack id is specified in activity options, usually it means that activity is // launched not from currently focused stack (e.g. from SysUI or from shell) - in // that case we check the target stack. updateTaskReturnToType(mStartActivity.task, mLaunchFlags, preferredLaunchStackId != INVALID_STACK_ID ? mTargetStack : topStack); } } else if (mSourceRecord != null) { if (mSupervisor.isLockTaskModeViolation(mSourceRecord.task)) { Slog.e(TAG, &quot;Attempted Lock Task Mode violation mStartActivity=&quot; + mStartActivity); return START_RETURN_LOCK_TASK_MODE_VIOLATION; } final int result = setTaskFromSourceRecord(); if (result != START_SUCCESS) { return result; } } else if (mInTask != null) { // The caller is asking that the new activity be started in an explicit // task it has provided to us. if (mSupervisor.isLockTaskModeViolation(mInTask)) { Slog.e(TAG, &quot;Attempted Lock Task Mode violation mStartActivity=&quot; + mStartActivity); return START_RETURN_LOCK_TASK_MODE_VIOLATION; } final int result = setTaskFromInTask(); if (result != START_SUCCESS) { return result; } } else { // This not being started from an existing activity, and not part of a new task... // just put it in the top task, though these days this case should never happen. setTaskToCurrentTopOrCreateNewTask(); } mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName, mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId); if (mSourceRecord != null &amp;&amp; mSourceRecord.isRecentsActivity()) { mStartActivity.task.setTaskToReturnTo(RECENTS_ACTIVITY_TYPE); } if (newTask) { EventLog.writeEvent( EventLogTags.AM_CREATE_TASK, mStartActivity.userId, mStartActivity.task.taskId); } ActivityStack.logStartActivity( EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.task); mTargetStack.mLastPausedActivity = null; sendPowerHintForLaunchStartIfNeeded(false /* forceSend */); mTargetStack.startActivityLocked(mStartActivity, newTask, mKeepCurTransition, mOptions); //mDoResume&#x8BBE;&#x7F6E;&#x4E3A;true if (mDoResume) { ...... final ActivityRecord topTaskActivity = mStartActivity.task.topRunningActivityLocked(); if (!mTargetStack.isFocusable() || (topTaskActivity != null &amp;&amp; topTaskActivity.mTaskOverlay &amp;&amp; mStartActivity != topTaskActivity)) { // If the activity is not focusable, we can&apos;t resume it, but still would like to // make sure it becomes visible as it starts (this will also trigger entry // animation). An example of this are PIP activities. // Also, we don&apos;t want to resume activities in a task that currently has an overlay // as the starting activity just needs to be in the visible paused state until the // over is removed. mTargetStack.ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); // Go ahead and tell window manager to execute app transition for this activity // since the app transition will not be triggered through the resume channel. mWindowManager.executeAppTransition(); } else { //&#x6267;&#x884C;&#x6B64;&#x65B9;&#x6CD5; mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity, mOptions); } } else { mTargetStack.addRecentActivityLocked(mStartActivity); } mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack); mSupervisor.handleNonResizableTaskIfNeeded( mStartActivity.task, preferredLaunchStackId, mTargetStack.mStackId); return START_SUCCESS;} &#x5728;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x770B;&#x5230;&#x4E86;&#x5BF9;Activity&#x7684;&#x4E0D;&#x540C;&#x7684;launchMode&#x7684;&#x5904;&#x7406;&#xFF0C;&#x6211;&#x4EEC;&#x8981;&#x542F;&#x52A8;&#x7684;HomeActivity&#x53EA;&#x4F1A;&#x662F;&#x542F;&#x52A8;&#x4E00;&#x4E2A;&#x65B0;&#x7684;Task&#xFF0C;&#x6240;&#x4EE5;&#x5927;&#x90E8;&#x5206;&#x64CD;&#x4F5C;&#x8FD8;&#x662F;&#x542F;&#x52A8;&#x5176;&#x4ED6;Activity&#x65F6;&#x8FDB;&#x884C;&#x7684;&#x3002;&#x4EE3;&#x7801;&#x91CC;&#x9762;&#x4E5F;&#x8BB2;&#x5230;&#x4E86;&#xFF0C;&#x6211;&#x4EEC;&#x5728;&#x521D;&#x59CB;&#x5316;&#x662F;mDoResume&#x4F20;&#x5165;&#x4E86;true&#xFF0C;&#x4EE3;&#x7801;&#x4F1A;&#x6267;&#x884C;mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,mOptions);&#x3002; 5. &#x65B9;&#x6CD5;&#x7684;&#x5404;&#x79CD;&#x8C03;&#x7528;&#x76F4;&#x81F3;resumeTopActivityInnerLocked &#x4E0A;&#x9762;&#x8BB2;&#x5230;&#x6211;&#x4EEC;&#x4F1A;&#x6267;&#x884C;ActivityStackSupervisor&#x7684;resumeFocusedStackTopActivityLocked&#x65B9;&#x6CD5;&#xFF0C;&#x8DDF;&#x8FDB;&#x65B9;&#x6CD5;&#x540E;&#x4F1A;&#x53D1;&#x73B0;&#x5176;&#x53C8;&#x4F1A;&#x8C03;&#x7528;ActivityStack&#x7684;resumeTopActivityUncheckedLocked&#x65B9;&#x6CD5;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4F1A;&#x8C03;&#x7528;&#x81EA;&#x8EAB;&#x7684;resumeTopActivityInnerLocked&#x65B9;&#x6CD5;&#xFF0C;&#x5728;resumeTopActivityInnerLocked&#x4E2D;&#xFF0C;&#x4F1A;&#x6839;&#x636E;&#x5F53;&#x524D;&#x7684;Activity Task&#x4E2D;&#x662F;&#x5426;&#x6709;&#x9700;&#x8981;pause&#x7684;Activity&#xFF0C;&#x5982;&#x679C;&#x6709;&#x5148;&#x53BB;&#x6267;&#x884C;pause&#xFF0C;&#x6CA1;&#x6709;&#x7684;&#x8BDD;&#x5219;&#x53BB;&#x542F;&#x52A8;Activity&#x3002;&#x5927;&#x81F4;&#x4EE3;&#x7801; 123456789101112131415161718192021222324252627private boolean resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options) { // Find the first activity that is not finishing. //&#x8FD9;&#x91CC;&#x770B;&#x4E86;&#x5F88;&#x4E45;&#xFF0C;&#x540E;&#x6765;&#x4ECE;&#x524D;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x6162;&#x6162;&#x7406;&#x6E05;&#x7684;&#x8BDD;&#xFF0C;&#x8FD9;&#x4E2A;next&#x5C31;&#x662F;&#x6307;&#x7684;&#x5C31;&#x662F;&#x5F53;&#x524D;&#x8981;&#x542F;&#x52A8;&#x7684;Activity&#x7684;Record //&#x8FD9;&#x91CC;&#x662F;&#x81EA;&#x5DF1;&#x7684;&#x7406;&#x89E3;&#xFF0C;&#x5E0C;&#x671B;&#x4E0D;&#x4F1A;&#x6709;&#x4EC0;&#x4E48;&#x5DEE;&#x9519; final ActivityRecord next = topRunningActivityLocked(); ...... final boolean dontWaitForPause = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != 0; boolean pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, dontWaitForPause); if (mResumedActivity != null) { if (DEBUG_STATES) Slog.d(TAG_STATES, &quot;resumeTopActivityLocked: Pausing &quot; + mResumedActivity); //&#x6267;&#x884C;pause pausing |= startPausingLocked(userLeaving, false, next, dontWaitForPause); } ...... ActivityStack lastStack = mStackSupervisor.getLastStack(); //&#x8981;&#x542F;&#x52A8;&#x7684;Activity&#x7684;app&#x662F;&#x4E0D;&#x662F;&#x4E3A;&#x7A7A;&#xFF0C;&#x663E;&#x7136;&#x662F;null if (next.app != null &amp;&amp; next.app.thread != null) { ...... } else { //&#x542F;&#x52A8; mStackSupervisor.startSpecificActivityLocked(next, true, true); } if (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked(); return true;} &#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x6211;&#x7701;&#x7565;&#x4E86;&#x5F88;&#x591A;&#xFF0C;&#x4E3B;&#x8981;&#x662F;&#x5148;&#x62FF;&#x5230;&#x6700;&#x4E0A;&#x9762;&#x8FD0;&#x884C;&#x7684;&#x5148;&#x5224;&#x65AD;&#x5176;&#x662F;&#x5426;&#x4E3A;null&#xFF0C;&#x4E0D;&#x4E3A;null&#x5219;&#x53BB;&#x5224;&#x65AD;&#x662F;&#x5426;&#x9700;&#x8981;&#x6267;&#x884C;pause&#xFF0C;&#x6211;&#x4EEC;&#x8FD9;&#x91CC;&#x9762;&#x662F;&#x4E0D;&#x9700;&#x8981;&#x6267;&#x884C;&#x7684;&#xFF0C;&#x5728;&#x540E;&#x9762;&#x6709;&#x4E2A;&#x5BF9;next.app&#x7684;&#x975E;&#x7A7A;&#x5224;&#x65AD;&#xFF0C;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x662F;&#x7B2C;&#x4E00;&#x6B21;&#x542F;&#x52A8;&#xFF0C;&#x6240;&#x4EE5;&#x5E76;&#x6CA1;&#x6709;app&#xFF0C;&#x6700;&#x540E;&#x4F1A;&#x6267;&#x884C;mStackSupervisor.startSpecificActivityLocked(next, true, true)&#x8FD9;&#x90E8;&#x5206;&#x4EE3;&#x7801;&#x3002; 6. ActivityStackSupervisor.startSpecificActivityLocked&#x8FC7;&#x7A0B; &#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x5C31;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#x4E86;&#xFF0C;&#x901A;&#x8FC7;AMS&#x53BB;&#x542F;&#x52A8;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x8FDB;&#x7A0B;&#xFF08;Process&#xFF09;&#x3002; 123456789101112131415void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity&apos;s application already running? ProcessRecord app = mService.getProcessRecordLocked(r.processName, r.info.applicationInfo.uid, true); r.task.stack.setLaunchTime(r); //&#x5F88;&#x660E;&#x663E;&#xFF0C;&#x8FD9;&#x91CC;&#x7684;app&#x4E3A;null&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x521B;&#x5EFA;&#x65B0;&#x7684;process if (app != null &amp;&amp; app.thread != null) { ...... } //&#x542F;&#x52A8;&#x65B0;&#x7684;process mService.startProcessLocked(r.processName, r.info.applicationInfo, true, 0, &quot;activity&quot;, r.intent.getComponent(), false, false, true);} 7. AMS&#x542F;&#x52A8;&#x65B0;&#x7684;&#x8FDB;&#x7A0B; AMS&#x4E2D;startProcessLocked&#x4E2D;&#x8C03;&#x7528;&#x4E86;Process.start&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x3002;Process.start&#x4E2D;&#x8C03;&#x7528;&#x4E86;startViaZygote&#x65B9;&#x6CD5;&#xFF0C;&#x63A5;&#x7740;&#x8C03;&#x7528;zygoteSendArgsAndGetResult&#x65B9;&#x6CD5;&#xFF0C;&#x901A;&#x8FC7;socket&#x8FDB;&#x884C;&#x901A;&#x4FE1;&#x6267;&#x884C;ActivityThread&#x7684;main&#x65B9;&#x6CD5;&#x3002;&#x90E8;&#x5206;&#x4EE3;&#x7801;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293AMS:private final void startProcessLocked(ProcessRecord app, String hostingType, String hostingNameStr, String abiOverride, String entryPoint, String[] entryPointArgs) { ...... //&#x53BB;&#x542F;&#x52A8;&#x8FDB;&#x7A0B; Process.ProcessStartResult startResult = Process.start(entryPoint, app.processName, uid, uid, gids, debugFlags, mountExternal, app.info.targetSdkVersion, app.info.seinfo, requiredAbi, instructionSet, app.info.dataDir, entryPointArgs); ......}Process.java:public static final ProcessStartResult start(final String processClass, final String niceName, int uid, int gid, int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] zygoteArgs) { try { return startViaZygote(processClass, niceName, uid, gid, gids, debugFlags, mountExternal, targetSdkVersion, seInfo, abi, instructionSet, appDataDir, zygoteArgs); } catch (ZygoteStartFailedEx ex) { }}private static ProcessStartResult startViaZygote(final String processClass, final String niceName, final int uid, final int gid, final int[] gids, int debugFlags, int mountExternal, int targetSdkVersion, String seInfo, String abi, String instructionSet, String appDataDir, String[] extraArgs) throws ZygoteStartFailedEx { synchronized(Process.class) { ...... return zygoteSendArgsAndGetResult(openZygoteSocketIfNeeded(abi)/**&#x8FD9;&#x91CC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x901A;&#x8FC7;socket&#x542F;&#x52A8;*/, argsForZygote); }}private static ProcessStartResult zygoteSendArgsAndGetResult( ZygoteState zygoteState, ArrayList&lt;String&gt; args) throws ZygoteStartFailedEx { try { int sz = args.size(); for (int i = 0; i &lt; sz; i++) { if (args.get(i).indexOf(&apos;\\n&apos;) &gt;= 0) { throw new ZygoteStartFailedEx(&quot;embedded newlines not allowed&quot;); } } final BufferedWriter writer = zygoteState.writer; final DataInputStream inputStream = zygoteState.inputStream; writer.write(Integer.toString(args.size())); writer.newLine(); for (int i = 0; i &lt; sz; i++) { String arg = args.get(i); writer.write(arg); writer.newLine(); } writer.flush(); // Should there be a timeout on this? ProcessStartResult result = new ProcessStartResult(); // Always read the entire result from the input stream to avoid leaving // bytes in the stream for future process starts to accidentally stumble // upon. result.pid = inputStream.readInt(); result.usingWrapper = inputStream.readBoolean(); if (result.pid &lt; 0) { throw new ZygoteStartFailedEx(&quot;fork() failed&quot;); } //&#x8FD4;&#x56DE;&#x7ED3;&#x679C; return result; } catch (IOException ex) { zygoteState.close(); throw new ZygoteStartFailedEx(ex); }} &#x901A;&#x8FC7;Zygote&#x53EF;&#x4EE5;&#x6267;&#x884C;ActivityThread&#x4E2D;&#x7684;main&#x65B9;&#x6CD5;&#x3002; 8. ActivityThread&#x7684;main&#x65B9;&#x6CD5; main&#x65B9;&#x6CD5;&#x4E2D;&#x5728;&#x4E0A;&#x9762;&#x4E00;&#x7BC7;&#x4E2D;&#x4E5F;&#x63D0;&#x5230;&#x8FC7;&#xFF0C;&#x4E0A;&#x6B21;SystemServer&#x542F;&#x52A8;&#x8FC7;&#x7A0B;&#x4E2D;&#x4F1A;&#x8C03;&#x7528;attach(true)&#x65B9;&#x6CD5;&#xFF0C;&#x800C;&#x6211;&#x4EEC;&#x901A;&#x8FC7;Zygote&#x542F;&#x52A8;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x4F1A;&#x8C03;&#x7528;attach(false)&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x3002; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public static void main(String[] args) { ...... //&#x4E3B;&#x7EBF;&#x7A0B; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); ...... //&#x4E00;&#x76F4;&#x5FAA;&#x73AF;&#xFF0C;&#x5982;&#x679C;&#x9000;&#x51FA;&#xFF0C;&#x8BF4;&#x660E;&#x7A0B;&#x5E8F;&#x5173;&#x95ED; Looper.loop(); ......}private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ViewRootImpl.addFirstDrawHandler(new Runnable() { @Override public void run() { ensureJitEnabled(); } }); android.ddm.DdmHandleAppName.setAppName(&quot;&lt;pre-initialized&gt;&quot;, UserHandle.myUserId()); RuntimeInit.setApplicationObject(mAppThread.asBinder()); //&#x83B7;&#x53D6;AMS&#x7684;&#x672C;&#x5730;&#x4EE3;&#x7406;&#x7C7B; final IActivityManager mgr = ActivityManagerNative.getDefault(); try { //&#x8C03;&#x7528;AMS&#x7684;attachApplication&#x65B9;&#x6CD5; mgr.attachApplication(mAppThread); } catch (RemoteException ex) { throw ex.rethrowFromSystemServer(); } // Watch for getting close to heap limit. BinderInternal.addGcWatcher(new Runnable() { @Override public void run() { if (!mSomeActivitiesChanged) { return; } Runtime runtime = Runtime.getRuntime(); long dalvikMax = runtime.maxMemory(); long dalvikUsed = runtime.totalMemory() - runtime.freeMemory(); if (dalvikUsed &gt; ((3*dalvikMax)/4)) { if (DEBUG_MEMORY_TRIM) Slog.d(TAG, &quot;Dalvik max=&quot; + (dalvikMax/1024) + &quot; total=&quot; + (runtime.totalMemory()/1024) + &quot; used=&quot; + (dalvikUsed/1024)); mSomeActivitiesChanged = false; try { mgr.releaseSomeActivities(mAppThread); } catch (RemoteException e) { throw e.rethrowFromSystemServer(); } } } }); } else { ...... } ...... ViewRootImpl.addConfigCallback(new ComponentCallbacks2() {......});} &#x4E0A;&#x9762;&#x7684;&#x4E3B;&#x8981;&#x662F;&#x5C31;&#x662F;&#x901A;&#x8FC7;Binder&#x8C03;&#x7528;AMS&#x7684;attachApplication&#x65B9;&#x6CD5;&#x3002; 9. AMS&#x7684;attachApplication&#x65B9;&#x6CD5; attachApplication&#x4E2D;&#x4E3B;&#x8981;&#x662F;&#x5224;&#x65AD;&#x5F53;&#x524D;&#x7684;Process&#x662F;&#x5426;&#x5B58;&#x5728;&#xFF0C;&#x5982;&#x679C;&#x5B58;&#x5728;&#xFF0C;&#x5219;&#x9700;&#x8981;&#x5C06;&#x5176;kill&#x3002;&#x63A5;&#x7740;&#x901A;&#x8FC7;thread.bindApplication&#x6765;&#x5C06;&#x4E00;&#x4E9B;&#x9700;&#x8981;&#x7684;&#x53D8;&#x91CF;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x8FDB;&#x884C;Application&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x8C03;&#x7528;Application&#x7684;onCreate()&#x65B9;&#x6CD5;&#x3002;&#x6700;&#x540E;&#x901A;&#x8FC7;mStackSupervisor.attachApplicationLocked(app)&#x65B9;&#x6CD5;&#x53BB;&#x771F;&#x6B63;&#x542F;&#x52A8;Activity&#x3002;&#x4E0B;&#x9762;&#x5927;&#x6982;&#x770B;&#x4E0B;&#x6574;&#x4E2A;&#x6D41;&#x7A0B;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184//&#x8FD9;&#x91CC;&#x6CA1;&#x5565;&#x8BB2;&#x7684;&#xFF0C;&#x5C31;&#x662F;&#x8C03;&#x7528;&#x4E86;attachApplicationLocked&#x65B9;&#x6CD5;@Overridepublic final void attachApplication(IApplicationThread thread) { synchronized (this) { int callingPid = Binder.getCallingPid(); final long origId = Binder.clearCallingIdentity(); attachApplicationLocked(thread, callingPid); Binder.restoreCallingIdentity(origId); }}private final boolean attachApplicationLocked(IApplicationThread thread, int pid) { // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. //&#x4ECE;&#x8FDB;&#x7A0B;&#x4E2D;&#x67E5;&#x627E;&#x662F;&#x5426;&#x6709;&#xFF0C;&#x5982;&#x679C;&#x6709;&#x7684;&#x8BDD;&#x53BB;&#x6740;&#x6389;&#x8FD9;&#x4E2A;&#x8FDB;&#x7A0B; ProcessRecord app; if (pid != MY_PID &amp;&amp; pid &gt;= 0) { synchronized (mPidsSelfLocked) { app = mPidsSelfLocked.get(pid); } } else { app = null; } if (app == null) { Slog.w(TAG, &quot;No pending application record for pid &quot; + pid + &quot; (IApplicationThread &quot; + thread + &quot;); dropping process&quot;); EventLog.writeEvent(EventLogTags.AM_DROP_PROCESS, pid); if (pid &gt; 0 &amp;&amp; pid != MY_PID) { Process.killProcessQuiet(pid); //TODO: killProcessGroup(app.info.uid, pid); } else { try { //&#x9000;&#x51FA; thread.scheduleExit(); } catch (Exception e) { // Ignore exceptions. } } return false; } // If this application record is still attached to a previous // process, clean it up now. //&#x5982;&#x679C;&#x5F53;&#x524D;&#x7684;Application&#x8BB0;&#x5F55;&#x4ECD;&#x7136;&#x4F9D;&#x9644;&#x5230;&#x4E4B;&#x524D;&#x7684;&#x8FDB;&#x7A0B;&#x4E2D;&#xFF0C;&#x5219;&#x6E05;&#x7406;&#x6389; if (app.thread != null) { handleAppDiedLocked(app, true, true); } // Tell the process all about itself. if (DEBUG_ALL) Slog.v( TAG, &quot;Binding process pid &quot; + pid + &quot; to record &quot; + app); final String processName = app.processName; try { AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; } catch (RemoteException e) { app.resetPackageList(mProcessStats); startProcessLocked(app, &quot;link fail&quot;, processName); return false; } EventLog.writeEvent(EventLogTags.AM_PROC_BOUND, app.userId, app.pid, app.processName); app.makeActive(thread, mProcessStats); app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ; app.curSchedGroup = app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT; app.forcingToForeground = null; updateProcessForegroundLocked(app, false, false); app.hasShownUi = false; app.debugging = false; app.cached = false; app.killedByAm = false; // We carefully use the same state that PackageManager uses for // filtering, since we use this flag to decide if we need to install // providers when user is unlocked later app.unlocked = StorageManager.isUserKeyUnlocked(app.userId); mHandler.removeMessages(PROC_START_TIMEOUT_MSG, app); //mProcessesReady&#x8FD9;&#x4E2A;&#x53D8;&#x91CF;&#x5728;AMS&#x7684;systemReady&#x4E2D;&#x88AB;&#x8D4B;&#x503C;&#x4E3A;true&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x91CC;&#x7684;normalMode&#x4E5F;&#x4E3A;true boolean normalMode = mProcessesReady || isAllowedWhileBooting(app.info); ...... try { int testMode = IApplicationThread.DEBUG_OFF; if (mDebugApp != null &amp;&amp; mDebugApp.equals(processName)) { testMode = mWaitForDebugger ? IApplicationThread.DEBUG_WAIT : IApplicationThread.DEBUG_ON; app.debugging = true; if (mDebugTransient) { mDebugApp = mOrigDebugApp; mWaitForDebugger = mOrigWaitForDebugger; } } String profileFile = app.instrumentationProfileFile; ParcelFileDescriptor profileFd = null; int samplingInterval = 0; boolean profileAutoStop = false; if (mProfileApp != null &amp;&amp; mProfileApp.equals(processName)) { mProfileProc = app; profileFile = mProfileFile; profileFd = mProfileFd; samplingInterval = mSamplingInterval; profileAutoStop = mAutoStopProfiler; } boolean enableTrackAllocation = false; if (mTrackAllocationApp != null &amp;&amp; mTrackAllocationApp.equals(processName)) { enableTrackAllocation = true; mTrackAllocationApp = null; } // If the app is being launched for restore or full backup, set it up specially boolean isRestrictedBackupMode = false; if (mBackupTarget != null &amp;&amp; mBackupAppName.equals(processName)) { isRestrictedBackupMode = mBackupTarget.appInfo.uid &gt;= Process.FIRST_APPLICATION_UID &amp;&amp; ((mBackupTarget.backupMode == BackupRecord.RESTORE) || (mBackupTarget.backupMode == BackupRecord.RESTORE_FULL) || (mBackupTarget.backupMode == BackupRecord.BACKUP_FULL)); } if (app.instrumentationClass != null) { notifyPackageUse(app.instrumentationClass.getPackageName(), PackageManager.NOTIFY_PACKAGE_USE_INSTRUMENTATION); } if (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION, &quot;Binding proc &quot; + processName + &quot; with config &quot; + mConfiguration); ApplicationInfo appInfo = app.instrumentationInfo != null ? app.instrumentationInfo : app.info; app.compat = compatibilityInfoForPackageLocked(appInfo); if (profileFd != null) { profileFd = profileFd.dup(); } ProfilerInfo profilerInfo = profileFile == null ? null : new ProfilerInfo(profileFile, profileFd, samplingInterval, profileAutoStop); //&#x771F;&#x6B63;&#x6267;&#x884C;&#x7ED1;&#x5B9A;&#x64CD;&#x4F5C;&#x662F;&#x901A;&#x8FC7;thread&#x7684;bindApplication&#x65B9;&#x6CD5;&#x3002; thread.bindApplication(processName, appInfo, providers, app.instrumentationClass, profilerInfo, app.instrumentationArguments, app.instrumentationWatcher, app.instrumentationUiAutomationConnection, testMode, mBinderTransactionTrackingEnabled, enableTrackAllocation, isRestrictedBackupMode || !normalMode, app.persistent, new Configuration(mConfiguration), app.compat, getCommonServicesLocked(app.isolated), mCoreSettingsObserver.getCoreSettingsLocked()); updateLruProcessLocked(app, false, null); app.lastRequestedGc = app.lastLowMemory = SystemClock.uptimeMillis(); } catch (Exception e) { ...... return false; } // Remove this record from the list of starting applications. mPersistentStartingProcesses.remove(app); if (DEBUG_PROCESSES &amp;&amp; mProcessesOnHold.contains(app)) Slog.v(TAG_PROCESSES, &quot;Attach application locked removing on hold: &quot; + app); mProcessesOnHold.remove(app); boolean badApp = false; boolean didSomething = false; // See if the top visible activity is waiting to run in this process... //&#x4E0A;&#x9762;&#x8BF4;&#x5230;&#xFF0C;&#x8FD9;&#x91CC;&#x4E3A;true&#xFF0C;&#x8FDB;&#x5165;StackSupervisor&#x7684;attachApplicationLocked&#x65B9;&#x6CD5;&#x53BB;&#x771F;&#x6B63;&#x542F;&#x52A8;Activity if (normalMode) { try { if (mStackSupervisor.attachApplicationLocked(app)) { didSomething = true; } } catch (Exception e) { Slog.wtf(TAG, &quot;Exception thrown launching activities in &quot; + app, e); badApp = true; } } ...... return true;} 10. StackSupervisor&#x7684;attachApplicationLocked&#x65B9;&#x6CD5; &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x4F1A;&#x8C03;&#x7528;realStartActivityLocked&#x65B9;&#x6CD5;&#xFF0C;&#x53BB;&#x771F;&#x6B63;&#x542F;&#x52A8;Activity 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253boolean attachApplicationLocked(ProcessRecord app) throws RemoteException { final String processName = app.processName; boolean didSomething = false; for (int displayNdx = mActivityDisplays.size() - 1; displayNdx &gt;= 0; --displayNdx) { ArrayList&lt;ActivityStack&gt; stacks = mActivityDisplays.valueAt(displayNdx).mStacks; for (int stackNdx = stacks.size() - 1; stackNdx &gt;= 0; --stackNdx) { final ActivityStack stack = stacks.get(stackNdx); if (!isFocusedStack(stack)) { continue; } ActivityRecord hr = stack.topRunningActivityLocked(); if (hr != null) { if (hr.app == null &amp;&amp; app.uid == hr.info.applicationInfo.uid &amp;&amp; processName.equals(hr.processName)) { try { //&#x771F;&#x6B63;&#x542F;&#x52A8;Activity if (realStartActivityLocked(hr, app, true, true)) { didSomething = true; } } catch (RemoteException e) { Slog.w(TAG, &quot;Exception in new application when starting activity &quot; + hr.intent.getComponent().flattenToShortString(), e); throw e; } } } } } if (!didSomething) { ensureActivitiesVisibleLocked(null, 0, !PRESERVE_WINDOWS); } return didSomething;}final boolean realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig) throws RemoteException { ...... try { ...... app.forceProcessStateUpTo(mService.mTopProcessState); //&#x6700;&#x4E3B;&#x8981;&#x7684;&#x5C31;&#x662F;&#x8FD9;&#x91CC;&#xFF0C;&#x4E5F;&#x662F;&#x901A;&#x8FC7;Activity&#x4E2D;&#x7684;&#x65B9;&#x6CD5;&#x53BB;&#x542F;&#x52A8;Activity&#x3002; app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken, System.identityHashCode(r), r.info, new Configuration(mService.mConfiguration), new Configuration(task.mOverrideConfig), r.compat, r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle, r.persistentState, results, newIntents, !andResume, mService.isNextTransitionForward(), profilerInfo); ...... } catch (RemoteException e) { } ...... return true;} &#x8BB2;&#x5230;&#x8FD9;&#x91CC;&#x57FA;&#x672C;&#x4E0A;&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#x5C31;&#x5B8C;&#x6210;&#x4E86;&#xFF0C;&#x540E;&#x9762;&#x5C31;&#x662F;ActivityThread&#x8FDB;&#x884C;Activity&#x7684;&#x542F;&#x52A8;&#x8FC7;&#x7A0B;&#xFF0C;&#x8FD9;&#x4E2A;&#x4E0B;&#x6B21;&#x5728;&#x7EE7;&#x7EED;&#x5206;&#x6790;&#x3002; 11. &#x603B;&#x7ED3; &#x8FD9;&#x91CC;&#x9762;&#x6240;&#x6709;&#x7684;&#x5173;&#x4E8E;Activity&#x542F;&#x52A8;&#xFF0C;resume&#xFF0C;pause&#x7B49;&#x7B49;&#x90FD;&#x662F;&#x901A;&#x8FC7;ActivityThread&#x6765;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x800C;&#x8FD9;&#x4E4B;&#x4E2D;&#x53C8;&#x4F1A;&#x6D89;&#x53CA;&#x5230;ActivityThread&#x5C06;&#x4EFB;&#x52A1;&#x4EA4;&#x7ED9;Instrumentation&#x53BB;&#x5904;&#x7406;&#x3002;&#x8FD9;&#x4E2A;&#x5904;&#x7406;&#x8FC7;&#x7A0B;&#x5305;&#x62EC;&#x4E86;&#x4E0E;&#x8DE8;&#x8FDB;&#x7A0B;&#x4E0E;&#x8FDC;&#x7AEF;&#x7684;AMS&#x8FDB;&#x884C;&#x901A;&#x4FE1;&#xFF0C;AMS&#x53C8;&#x901A;&#x8FC7;ActivityStarter,ActivityStackSupervisor,ActivityStack&#x7B49;&#x8FDB;&#x884C;&#x5904;&#x7406;&#xFF0C;&#x6700;&#x7EC8;&#x5C06;&#x6240;&#x542F;&#x52A8;&#x7684;Activity&#x771F;&#x6B63;&#x542F;&#x52A8;&#x3002;&#x5176;&#x5B9E;&#x8FD8;&#x6709;&#x4E2A;&#x65F6;&#x5E8F;&#x56FE;&#x7684;&#xFF0C;&#x4F46;&#x662F;&#x592A;&#x5927;&#x4E86;&#xFF0C;&#x622A;&#x56FE;&#x4E5F;&#x4E0D;&#x5168;&#xFF0C;&#x7B49;&#x4E0B;&#x6B21;&#x76F4;&#x63A5;&#x4E0A;&#x4F20;&#xFF0C;&#x65B9;&#x4FBF;&#x81EA;&#x5DF1;&#x67E5;&#x770B;&#x3002;&#x4E0B;&#x9762;&#x8BA1;&#x5212;&#x5206;&#x6790;ActivityThread&#x542F;&#x52A8;Activity&#x3002; 12. &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD; &#x60F3;&#x5199;&#x5173;&#x4E8E;Activity&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#x60F3;&#x4E86;&#x597D;&#x4E45;&#xFF0C;&#x8BF4;&#x5B9E;&#x8BDD;&#x5176;&#x4E2D;&#x6709;&#x4E00;&#x90E8;&#x5206;&#x53EA;&#x80FD;&#x6309;&#x81EA;&#x5DF1;&#x7684;&#x7406;&#x89E3;&#x6765;&#x89E3;&#x91CA;&#xFF0C;&#x53EF;&#x80FD;&#x4F1A;&#x6709;&#x4E00;&#x4E9B;&#x95EE;&#x9898;&#x3002;&#x4F46;&#x662F;&#x8D77;&#x7801;&#x81EA;&#x5DF1;&#x8BA4;&#x4E3A;&#x662F;&#x5BF9;&#x7684;&#x3002;&#x55EF;&#xFF0C;&#x8FD9;&#x5C31;&#x591F;&#x4E86;&#x3002;","tags":[]},{"title":"Android启动流程（Java层）","date":"2017-11-03T13:40:58.024Z","path":"2017/11/03/启动流程/","text":"&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x597D;&#x50CF;&#x53C8;&#x5F88;&#x4E45;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x4E86;&#xFF0C;&#x8FD9;&#x6BB5;&#x65F6;&#x95F4;&#x4E5F;&#x662F;&#x5728;&#x505A;&#x9879;&#x76EE;+&#x81EA;&#x6211;&#x5B66;&#x4E60;&#x4E2D;&#x3002;&#x76EE;&#x524D;&#x6253;&#x7B97;&#x662F;&#x5148;&#x628A;Android&#x7684;&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#x5305;&#x62EC;luncher&#x3001;Activity&#x7684;&#x542F;&#x52A8;&#x4EE5;&#x53CA;Service&#x542F;&#x52A8;&#xFF0C;View&#x7684;&#x7ED8;&#x5236;&#xFF0C;&#x4E8B;&#x4EF6;&#x5206;&#x53D1;&#x7B49;&#x8FDB;&#x884C;&#x5206;&#x6790;&#xFF0C;&#x540E;&#x9762;&#x5E94;&#x8BE5;&#x8FD8;&#x4F1A;&#x5305;&#x62EC;&#x73B0;&#x9636;&#x6BB5;&#x6B63;&#x5728;&#x4F7F;&#x7528;&#x7684;&#x6846;&#x67B6;MVVM&#x7684;&#x5206;&#x6790;&#x3002;&#x53EF;&#x80FD;&#x662F;&#x66F4;&#x65B0;Android&#x4E0D;&#x4F1A;&#x592A;&#x4E45;&#x4E86;&#xFF0C;&#x6709;&#x70B9;&#x8FF7;&#x832B;Android&#x7684;&#x672A;&#x6765;&#x5230;&#x5E95;&#x5728;&#x54EA;&#x91CC;&#xFF0C;&#x628A;&#x63E1;&#x73B0;&#x5728;&#x5427;&#x3002;&#x4ECA;&#x5929;&#x8FD9;&#x90E8;&#x5206;&#x8BB2;&#x89E3;&#x7684;&#x662F;Android&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#x540E;&#x52A0;&#x8F7D;&#x5404;&#x79CD;&#x670D;&#x52A1;&#x7684;&#x8FC7;&#x7A0B;&#x3002; 1 init init&#x662F;&#x7B2C;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x8BF4;&#x5B83;&#x662F;root&#x8FDB;&#x7A0B;&#x6216;&#x8005;&#x8BF4;&#x6709;&#x8FDB;&#x7A0B;&#x7684;&#x7236;&#x8FDB;&#x7A0B;&#x3002;init&#x8FDB;&#x7A0B;&#x6709;&#x4E24;&#x4E2A;&#x8D23;&#x4EFB;&#xFF0C;&#x4E00;&#x662F;&#x6302;&#x8F7D;&#x76EE;&#x5F55;&#xFF0C;&#x6BD4;&#x5982;/sys&#x3001;/dev&#x3001;/proc&#xFF0C;&#x4E8C;&#x662F;&#x8FD0;&#x884C;init.rc&#x811A;&#x672C;&#x3002;init&#x8FDB;&#x7A0B;&#x53EF;&#x4EE5;&#x5728;/system/core/init&#x627E;&#x5230;&#x3002;init.rc&#x6587;&#x4EF6;&#x53EF;&#x4EE5;&#x5728;/system/core/rootdir/init.rc&#x627E;&#x5230;&#x3002;readme.txt&#x53EF;&#x4EE5;&#x5728;/system/core/init/readme.txt&#x627E;&#x5230;&#x3002;&#x5BF9;&#x4E8E;init.rc&#x6587;&#x4EF6;&#xFF0C;Android&#x4E2D;&#x6709;&#x7279;&#x5B9A;&#x7684;&#x683C;&#x5F0F;&#x4EE5;&#x53CA;&#x89C4;&#x5219;&#x3002;&#x5728;Android&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x53EB;&#x505A;Android&#x521D;&#x59CB;&#x5316;&#x8BED;&#x8A00;&#x3002; 2 Zygote&#x52A0;&#x8F7D;&#x8FDB;&#x7A0B; Zygote&#x672C;&#x610F;&#x662F;&#x53D7;&#x7CBE;&#x5375;&#xFF0C;Android&#x4E2D;&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x5B75;&#x5316;&#x5668;&#x3002;Android&#x7684;&#x5E94;&#x7528;&#x7684;&#x8FDB;&#x7A0B;&#x90FD;&#x662F;&#x7531;Zygote&#x5B75;&#x5316;&#x800C;&#x6765;&#xFF0C;&#x56E0;&#x6B64;&#x4ED6;&#x4EEC;&#x90FD;&#x6709;&#x5171;&#x540C;&#x7684;ppid&#xFF08;&#x7236;&#x8FDB;&#x7A0B;&#x7684;id&#xFF09; 3 SystemServer&#x542F;&#x52A8; Zygote&#x542F;&#x52A8;&#x5B8C;&#x6210;&#x540E;&#xFF0C;Zygote&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x8FDB;&#x7A0B;&#x53BB;&#x542F;&#x52A8;&#x7CFB;&#x7EDF;&#x670D;&#x52A1;&#x3002;&#x6211;&#x4EEC;&#x90FD;&#x77E5;&#x9053;Android&#x7684;&#x8FDB;&#x7A0B;&#x95F4;&#x901A;&#x4FE1;&#x662F;&#x901A;&#x8FC7;binder&#x673A;&#x5236;&#xFF0C;&#x901A;&#x8FC7;binder&#x673A;&#x5236;&#x53EF;&#x4EE5;&#x907F;&#x514D;&#x5BF9;&#x67D0;&#x4E2A;&#x670D;&#x52A1;&#x7684;&#x5355;&#x72EC;&#x521B;&#x5EFA;&#xFF0C;&#x6240;&#x6709;&#x7684;&#x670D;&#x52A1;&#x5728;&#x7CFB;&#x7EDF;&#x542F;&#x52A8;&#x540E;&#x5373;&#x521B;&#x5EFA;&#x5B8C;&#x6210;&#x3002;&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x901A;&#x8FC7;Context.getSystemService(String name)&#x83B7;&#x7684;&#x5E76;&#x4E0D;&#x662F;&#x6211;&#x4EEC;&#x7684;&#x670D;&#x52A1;&#x7684;&#x4EE3;&#x7406;&#x7C7B;&#xFF0C;&#x6211;&#x4EEC;&#x83B7;&#x53D6;&#x7684;&#x662F;&#x5404;&#x79CD;Manager&#x7C7B;&#x3002; 3.1 SystemServer&#x542F;&#x52A8;&#x6D41;&#x7A0B; &#x6253;&#x5F00;SystemServer.java ,&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x5B83;&#x662F;&#x4E00;&#x4E2A;&#x542B;&#x6709;main&#x65B9;&#x6CD5;&#x7684;&#x7C7B;&#xFF0C;Zygote&#x542F;&#x52A8;&#x7CFB;&#x7EDF;&#x670D;&#x52A1;&#x65F6;&#x4F1A;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;main&#x65B9;&#x6CD5;&#x3002; 123public static void main(String[] args) { new SystemServer().run();} main&#x521B;&#x5EFA;&#x4E86;SystemServer&#x5BF9;&#x8C61;&#x540E;&#xFF0C;&#x8C03;&#x7528;&#x5176;run&#x65B9;&#x6CD5;&#xFF0C;&#x4E0B;&#x9762;&#x662F;&#x5177;&#x4F53;&#x5B9E;&#x73B0;&#x3002; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void run() { try { Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;InitBeforeStartServices&quot;); //&#x8FDB;&#x884C;&#x65F6;&#x95F4;&#x6821;&#x9A8C; if (System.currentTimeMillis() &lt; EARLIEST_SUPPORTED_TIME) { Slog.w(TAG, &quot;System clock is before 1970; setting to 1970.&quot;); SystemClock.setCurrentTimeMillis(EARLIEST_SUPPORTED_TIME); } //&#x8BED;&#x8A00;&#x6821;&#x9A8C; if (!SystemProperties.get(&quot;persist.sys.language&quot;).isEmpty()) { final String languageTag = Locale.getDefault().toLanguageTag(); SystemProperties.set(&quot;persist.sys.locale&quot;, languageTag); SystemProperties.set(&quot;persist.sys.language&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.country&quot;, &quot;&quot;); SystemProperties.set(&quot;persist.sys.localevar&quot;, &quot;&quot;); } ...... //&#x8BBE;&#x7F6E;&#x7EBF;&#x7A0B;&#x4F18;&#x5148;&#x7EA7; android.os.Process.setThreadPriority( android.os.Process.THREAD_PRIORITY_FOREGROUND); android.os.Process.setCanSelfBackground(false); //&#x5F00;&#x542F;&#x4E86;&#x4E00;&#x4E2A;Looper&#x7528;&#x4E8E;&#x6D88;&#x606F;&#x5904;&#x7406;&#xFF0C;&#x6B64;&#x5904;&#x548C;ActivityThread&#x521B;&#x5EFA;&#x6D88;&#x606F;&#x961F;&#x5217;&#x5FAA;&#x73AF;&#x4E00;&#x81F4; Looper.prepareMainLooper(); //&#x52A0;&#x8F7D;&#x4E86;android_servers.so&#xFF0C;&#x91CC;&#x9762;&#x5E94;&#x8BE5;&#x662F;&#x5404;&#x4E2A;server System.loadLibrary(&quot;android_servers&quot;); performPendingShutdown(); //&#x521B;&#x5EFA;&#x4E86;&#x7CFB;&#x7EDF;&#x7684;&#x4E0A;&#x4E0B;&#x6587;Context 3.1.1 createSystemContext(); //&#x5C06;SystemServiceManager&#x653E;&#x5165;LocalServices&#x4E2D; mSystemServiceManager = new SystemServiceManager(mSystemContext); LocalServices.addService(SystemServiceManager.class, mSystemServiceManager); } finally { Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); } try { Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;StartServices&quot;); //&#x542F;&#x52A8;&#x5173;&#x952E;services 3.2 startBootstrapServices(); //&#x542F;&#x52A8;&#x6838;&#x5FC3;services 3.3 startCoreServices(); //&#x542F;&#x52A8;&#x5176;&#x4ED6;services 3.4 startOtherServices(); } catch (Throwable ex) { Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; } finally { Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); } if (StrictMode.conditionallyEnableDebugLogging()) { Slog.i(TAG, &quot;Enabled StrictMode for system server main thread.&quot;); } //&#x5F00;&#x542F;&#x6D88;&#x606F;&#x961F;&#x5217;&#x5FAA;&#x73AF; Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);} run()&#x65B9;&#x6CD5;&#x4E2D;&#x5148;&#x5BF9;&#x65F6;&#x95F4;&#x548C;&#x8BED;&#x8A00;&#x8FDB;&#x884C;&#x6821;&#x9A8C;&#x540E;&#xFF0C;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x6D88;&#x606F;&#x961F;&#x5217;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;createSystemContext()&#x65B9;&#x6CD5;&#x521B;&#x5EFA;SystemServer&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x5BF9;&#x8C61;&#xFF0C;&#x4E4B;&#x540E;&#x5F00;&#x59CB;&#x542F;&#x52A8;&#x5F15;&#x5BFC;services&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x662F;&#x6838;&#x5FC3;services&#x4EE5;&#x53CA;&#x6700;&#x540E;&#x542F;&#x52A8;&#x5176;&#x4ED6;services&#x3002; 3.1.1 createSystemContext()&#x8FC7;&#x7A0B; &#x4ECE;&#x540D;&#x5B57;&#x4E2D;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x77E5;&#x9053;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x662F;&#x7528;&#x6765;&#x521B;&#x5EFA;&#x7CFB;&#x7EDF;&#x7684;&#x4E0A;&#x4E0B;&#x6587;&#x5BF9;&#x8C61;&#xFF0C;createSystemContext()&#x4E2D;&#x4EE3;&#x7801;&#x6BD4;&#x8F83;&#x5C11;&#xFF0C;&#x5F88;&#x5BB9;&#x6613;&#x7406;&#x89E3;&#x3002;1234567private void createSystemContext() { //&#x901A;&#x8FC7;ActivityThread&#x7684;systemMain()&#x8FDB;&#x884C;&#x5BF9;&#x8C61;&#x7684;&#x521B;&#x5EFA; 3.1.2 ActivityThread activityThread = ActivityThread.systemMain(); //&#x5C06;&#x4E0A;&#x4E0B;&#x6587;&#x5BF9;&#x8C61;&#x8D4B;&#x503C; mSystemContext = activityThread.getSystemContext(); mSystemContext.setTheme(DEFAULT_SYSTEM_THEME);} 3.1.2 Context&#x521B;&#x5EFA;&#x7684;&#x8FC7;&#x7A0B; ActivityThread&#x521B;&#x5EFA;&#x7684;&#x8FC7;&#x7A0B;&#xFF0C;&#x4E0D;&#x5F97;&#x4E0D;&#x8BF4;&#x8C37;&#x6B4C;&#x7684;&#x4EE3;&#x7801;&#x771F;&#x662F;&#x77ED;&#x5C0F;&#x7CBE;&#x608D;&#x554A;&#x3002;1234567891011public static ActivityThread systemMain() { if (!ActivityManager.isHighEndGfx()) { ThreadedRenderer.disable(true); } else { ThreadedRenderer.enableForegroundTrimming(); } //&#x597D;&#x50CF;&#x6CE8;&#x91CA;&#x90FD;&#x4E0D;&#x9700;&#x8981;&#x4E86;&#x3002; ActivityThread thread = new ActivityThread(); thread.attach(true); return thread;} &#x63A5;&#x7740;&#x6211;&#x4EEC;&#x6765;&#x770B;thread.attach(true)&#x65B9;&#x6CD5;&#x3002;&#xFF08;&#x53C2;&#x6570;&#x6211;&#x4EEC;&#x4F20;&#x5165;&#x7684;&#x662F;true&#xFF09;&#xFF0C;&#x8FD9;&#x91CC;&#x53EA;&#x5C55;&#x793A;&#x6267;&#x884C;&#x7684;&#x4EE3;&#x7801;&#x3002;123456789101112131415161718192021222324252627282930313233343536373839private void attach(boolean system) { sCurrentActivityThread = this; mSystemThread = system; if (!system) { ...... } else { // Don&apos;t set application object here -- if the system crashes, // we can&apos;t display an alert, we just want to die die die. //&#x8FD9;&#x53E5;&#x8BDD;&#x633A;&#x6709;&#x610F;&#x601D;&#x7684;&#x3002;&#x3002;&#x3002; android.ddm.DdmHandleAppName.setAppName(&quot;system_process&quot;, UserHandle.myUserId()); try { mInstrumentation = new Instrumentation(); //&#x521B;&#x5EFA;context ContextImpl context = ContextImpl.createAppContext( this, getSystemContext().mPackageInfo); mInitialApplication = context.mPackageInfo.makeApplication(true, null); //&#x8C03;&#x7528;Application&#x7684;onCreate()&#x65B9;&#x6CD5; mInitialApplication.onCreate(); } catch (Exception e) { throw new RuntimeException( &quot;Unable to instantiate Application():&quot; + e.toString(), e); } } DropBox.setReporter(new DropBoxReporter()); ViewRootImpl.addConfigCallback(new ComponentCallbacks2() {......});}//&#x5BF9;&#x8C61;&#x4E0D;&#x91CD;&#x590D;&#x521B;&#x5EFA;public ContextImpl getSystemContext() { synchronized (this) { if (mSystemContext == null) { //&#x521B;&#x5EFA;&#x7CFB;&#x7EDF;&#x7684;&#x4E0A;&#x4E0B;&#x6587; mSystemContext = ContextImpl.createSystemContext(this); } return mSystemContext; }} &#x4EE3;&#x7801;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#xFF0C;&#x901A;&#x8FC7;createAppContext&#x65B9;&#x6CD5;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x4E0A;&#x4E0B;&#x6587;&#x5BF9;&#x8C61;&#xFF0C;&#x5E76;&#x901A;&#x8FC7;makeApplication&#x65B9;&#x6CD5;&#x521B;&#x5EFA;Application&#xFF0C;&#x5E76;&#x8C03;&#x7528;onCreate()&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x540E;&#x8C03;&#x7528;getSystemContext()&#x5C06;&#x4E0A;&#x4E0B;&#x6587;&#x8D4B;&#x503C;&#x7ED9;mSystemContext&#x3002;&#x8FD9;&#x8FB9;&#x5BF9;&#x4E0A;&#x4E0B;&#x6587;&#x7684;&#x521B;&#x5EFA;&#x5C31;&#x5230;&#x8FD9;&#x91CC;&#x7ED3;&#x675F;&#x4E86;&#xFF0C;&#x4E0B;&#x9762;&#x5F00;&#x59CB;&#x5BF9;&#x5404;&#x79CD;&#x670D;&#x52A1;&#x542F;&#x52A8;&#x7684;&#x6D41;&#x7A0B;&#x5206;&#x6790;&#x3002; 3.2 startBootstrapServices()&#x542F;&#x52A8;&#x6838;&#x5FC3;&#x670D;&#x52A1; &#x542F;&#x52A8;&#x6838;&#x5FC3;&#x670D;&#x52A1;&#x7684;&#x8FC7;&#x7A0B;&#x5176;&#x5B9E;&#x5E76;&#x6CA1;&#x6709;&#x591A;&#x4E48;&#x7684;&#x590D;&#x6742;&#xFF0C;&#x6700;&#x5F00;&#x59CB;&#x88AB;&#x542F;&#x52A8;&#x7684;&#x662F;Installer&#xFF0C;&#x5373;&#x7CFB;&#x7EDF;&#x5B89;&#x88C5;apk&#x65F6;&#x7684;&#x4E00;&#x4E2A;&#x670D;&#x52A1;&#x7C7B;&#xFF0C;&#x542F;&#x52A8;&#x5B8C;&#x6210;Installer&#x670D;&#x52A1;&#x4E4B;&#x540E;&#x624D;&#x80FD;&#x542F;&#x52A8;&#x5176;&#x4ED6;&#x7684;&#x7CFB;&#x7EDF;&#x670D;&#x52A1;&#xFF0C;&#x4E4B;&#x540E;&#x542F;&#x52A8;AMS&#xFF0C;PowerManagerService&#xFF0C;LightsService&#xFF0C;DisplayManagerService&#x2026;&#x2026;&#xFF0C;&#x6838;&#x5FC3;&#x4EE3;&#x7801;&#x5982;&#x4E0B;&#xFF1A;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869private void startBootstrapServices() { //&#x7CFB;&#x7EDF;&#x5B89;&#x88C5;apk&#x65F6;&#x7684;&#x4E00;&#x4E2A;&#x670D;&#x52A1;&#x7C7B;&#xFF0C;&#x542F;&#x52A8;&#x5B8C;&#x6210;Installer&#x670D;&#x52A1;&#x4E4B;&#x540E;&#x624D;&#x80FD;&#x542F;&#x52A8;&#x5176;&#x4ED6;&#x7684;&#x7CFB;&#x7EDF;&#x670D;&#x52A1; //&#x76F4;&#x63A5;&#x7FFB;&#x8BD1;&#x4E86;&#x6E90;&#x7801;&#x6CE8;&#x91CA;&#xFF08;&#x6709;&#x70B9;&#x65E0;&#x803B;&#x54C8;&#xFF09;&#x3002; //&#x7B49;&#x5F85;installd&#x5B8C;&#x6210;&#x542F;&#x52A8;&#xFF0C;&#x4EE5;&#x4FBF;&#x5B83;&#x6709;&#x673A;&#x4F1A;&#x521B;&#x5EFA;&#x5177;&#x6709;&#x9002;&#x5F53;&#x6743;&#x9650;&#x7684;&#x5173;&#x952E;&#x76EE;&#x5F55;&#xFF0C;&#x5982;/ data / user&#x3002; //&#x5728;&#x6211;&#x4EEC;&#x521D;&#x59CB;&#x5316;&#x5176;&#x4ED6;&#x670D;&#x52A1;&#x4E4B;&#x524D;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5B8C;&#x6210;&#x8FD9;&#x4E2A;&#x5DE5;&#x4F5C; startService 3.2.1 Installer installer = mSystemServiceManager.startService(Installer.class); //&#x542F;&#x52A8;ActivityManagerService mActivityManagerService = mSystemServiceManager.startService( ActivityManagerService.Lifecycle.class).getService(); mActivityManagerService.setSystemServiceManager(mSystemServiceManager); mActivityManagerService.setInstaller(installer); //&#x7535;&#x6E90;&#x7BA1;&#x7406;&#x5668;&#x9700;&#x8981;&#x63D0;&#x524D;&#x542F;&#x52A8;&#xFF0C;&#x56E0;&#x4E3A;&#x5176;&#x4ED6;&#x670D;&#x52A1;&#x9700;&#x8981;&#x5B83;&#x3002; //&#x672C;&#x5730;&#x5B88;&#x62A4;&#x8FDB;&#x7A0B;&#x53EF;&#x80FD;&#x6B63;&#x5728;&#x6CE8;&#x518C;&#xFF0C;&#x56E0;&#x6B64;&#x5B83;&#x5FC5;&#x987B;&#x7ACB;&#x5373;&#x5904;&#x7406;&#x4F20;&#x5165;&#x7684;&#x7ED1;&#x5B9A;&#x5668;&#x8C03;&#x7528;&#xFF08;&#x5305;&#x62EC;&#x80FD;&#x591F;&#x9A8C;&#x8BC1;&#x8FD9;&#x4E9B;&#x8C03;&#x7528;&#x7684;&#x6743;&#x9650;&#xFF09;&#x3002; mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); Trace.traceBegin(Trace.TRACE_TAG_SYSTEM_SERVER, &quot;InitPowerManagement&quot;); mActivityManagerService.initPowerManagement(); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); //&#x542F;&#x52A8;&#x706F;&#x5149;service mSystemServiceManager.startService(LightsService.class); //&#x542F;&#x52A8;&#x663E;&#x793A;service mDisplayManagerService = mSystemServiceManager.startService(DisplayManagerService.class); //&#x5728;&#x521D;&#x59CB;&#x5316;package manager&#x5B8C;&#x6210;&#x524D;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x9ED8;&#x8BA4;&#x663E;&#x793A; mSystemServiceManager.startBootPhase(SystemService.PHASE_WAIT_FOR_DEFAULT_DISPLAY); String cryptState = SystemProperties.get(&quot;vold.decrypt&quot;); if (ENCRYPTING_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Detected encryption in progress - only parsing core apps&quot;); mOnlyCore = true; } else if (ENCRYPTED_STATE.equals(cryptState)) { Slog.w(TAG, &quot;Device encrypted - only parsing core apps&quot;); mOnlyCore = true; } traceBeginAndSlog(&quot;StartPackageManagerService&quot;); //PackageManagerService&#x5F00;&#x59CB;&#x521D;&#x59CB;&#x5316; mPackageManagerService = PackageManagerService.main(mSystemContext, installer, mFactoryTestMode != FactoryTest.FACTORY_TEST_OFF, mOnlyCore); mFirstBoot = mPackageManagerService.isFirstBoot(); mPackageManager = mSystemContext.getPackageManager(); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); if (!mOnlyCore) { boolean disableOtaDexopt = SystemProperties.getBoolean(&quot;config.disable_otadexopt&quot;, false); if (!disableOtaDexopt) { traceBeginAndSlog(&quot;StartOtaDexOptService&quot;); try { OtaDexoptService.main(mSystemContext, mPackageManagerService); } catch (Throwable e) { reportWtf(&quot;starting OtaDexOptService&quot;, e); } finally { Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); } } } traceBeginAndSlog(&quot;StartUserManagerService&quot;); //&#x591A;&#x7528;&#x6237;UserManagerService mSystemServiceManager.startService(UserManagerService.LifeCycle.class); Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); AttributeCache.init(mSystemContext); //&#x628A;&#x51E0;&#x4E2A;service&#x6DFB;&#x52A0;&#x5230;ServiceManager&#x7684;&#x4E2D; mActivityManagerService.setSystemProcess(); //&#x542F;&#x52A8;&#x4F20;&#x611F;&#x5668;&#x7684;&#x670D;&#x52A1;&#xFF0C;native&#x65B9;&#x6CD5; startSensorService();} 3.2.1 SystemServiceManager.startService&#x7684;&#x8FC7;&#x7A0B; &#x542F;&#x52A8;service&#x7684;&#x8FC7;&#x7A0B;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#xFF0C;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x53BB;&#x521B;&#x5EFA;service&#x5BF9;&#x8C61;&#xFF0C;&#x5176;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;&#x4E3A;Context&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x6DFB;&#x52A0;&#x5230;SystemServiceManager&#x7684;mServices&#x5217;&#x8868;&#x4E2D;&#x3002;12345678910111213141516171819202122232425262728/** * &#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x53BB;&#x521B;&#x5EFA;&#xFF0C;&#x5176;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x7684;&#x53C2;&#x6570;&#x4E3A;Context */public &lt;T extends SystemService&gt; T startService(Class&lt;T&gt; serviceClass) { try { final String name = serviceClass.getName(); // Create the service. if (!SystemService.class.isAssignableFrom(serviceClass)) { throw new RuntimeException(&quot;Failed to create &quot; + name + &quot;: service must extend &quot; + SystemService.class.getName()); } final T service; try { Constructor&lt;T&gt; constructor = serviceClass.getConstructor(Context.class); service = constructor.newInstance(mContext); } catch (InstantiationException ex) {......} // &#x6DFB;&#x52A0;&#x5230;mServices&#x5217;&#x8868;&#x4E2D; mServices.add(service); try { //&#x8C03;&#x7528;onStart&#x65B9;&#x6CD5; service.onStart(); } catch (RuntimeException ex) {......} return service; } finally { Trace.traceEnd(Trace.TRACE_TAG_SYSTEM_SERVER); }} 3.3&#x542F;&#x52A8;&#x6838;&#x5FC3;&#x670D;&#x52A1; &#x4ECE;&#x4EE3;&#x7801;&#x4E2D;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#x6838;&#x5FC3;&#x670D;&#x52A1;&#x5305;&#x62EC;&#x4E86;&#x7BA1;&#x7406;&#x7535;&#x6C60;&#x76F8;&#x5173;&#x7684;&#x670D;&#x52A1;&#xFF0C;&#x6536;&#x96C6;&#x7528;&#x6237;&#x4F7F;&#x7528;&#x6BCF;&#x4E00;&#x4E2A;APP&#x7684;&#x9891;&#x7387;&#x3001;&#x4F7F;&#x7528;&#x65F6;&#x5E38;&#x7684;&#x670D;&#x52A1;&#x4EE5;&#x53CA;WebView&#x66F4;&#x65B0;&#x670D;&#x52A1;&#x7684;&#x542F;&#x52A8;&#x3002;123456789101112private void startCoreServices() { //&#x7BA1;&#x7406;&#x7535;&#x6C60;&#x76F8;&#x5173;&#x7684;&#x670D;&#x52A1; mSystemServiceManager.startService(BatteryService.class); //&#x6536;&#x96C6;&#x7528;&#x6237;&#x4F7F;&#x7528;&#x6BCF;&#x4E00;&#x4E2A;APP&#x7684;&#x9891;&#x7387;&#x3001;&#x4F7F;&#x7528;&#x65F6;&#x5E38; mSystemServiceManager.startService(UsageStatsService.class); mActivityManagerService.setUsageStatsManager( LocalServices.getService(UsageStatsManagerInternal.class)); //WebView&#x66F4;&#x65B0;&#x670D;&#x52A1; mWebViewUpdateService = mSystemServiceManager.startService(WebViewUpdateService.class);} 3.4 &#x542F;&#x52A8;&#x5176;&#x4ED6;&#x670D;&#x52A1; &#x542F;&#x52A8;&#x5176;&#x4ED6;&#x670D;&#x52A1;&#xFF0C;&#x5305;&#x62EC;&#x84DD;&#x7259;&#xFF0C;&#x6444;&#x50CF;&#x5934;&#x76F8;&#x5173;&#x670D;&#x52A1;&#xFF0C;&#x7BA1;&#x7406;&#x8F93;&#x5165;&#x4E8B;&#x4EF6;&#x7B49;&#x670D;&#x52A1;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x8D58;&#x8FF0;&#x3002;12345678910111213/** * &#x5176;&#x4ED6;&#x670D;&#x52A1;&#xFF0C;&#x5305;&#x62EC;&#x84DD;&#x7259;&#xFF0C;&#x6444;&#x50CF;&#x5934;&#x76F8;&#x5173;&#x670D;&#x52A1;&#xFF0C;&#x7BA1;&#x7406;&#x8F93;&#x5165;&#x4E8B;&#x4EF6;&#x7B49;&#x670D;&#x52A1;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x8D58;&#x8FF0; */private void startOtherServices() { ...... //&#x5212;&#x91CD;&#x70B9;&#xFF0C;&#x8FD9;&#x91CC;&#x4F1A;&#x542F;&#x52A8;HomeActivity&#xFF0C;&#x4E0B;&#x7BC7;&#x8BB2;HomeActivity&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#xFF0C;&#x8FD9;&#x91CC;mark&#x4E0B; mActivityManagerService.systemReady(new Runnable() { @Override public void run() { ...... } });} &#x4E0D;&#x8FC7;&#xFF0C;&#x91CC;&#x9762;&#x6709;&#x4E2A;&#x91CD;&#x8981;&#x7684;&#x5730;&#x65B9;&#x662F;&#x5173;&#x4E8E;HomeActivity&#x7684;&#x542F;&#x52A8;&#xFF0C;&#x8C03;&#x7528;&#x4E86;mActivityManagerService.systemReady(new Runnable()&#x540E;&#xFF0C;&#x4F1A;&#x542F;&#x52A8;HomeActivity&#xFF0C;&#x4E0B;&#x7BC7;&#x8BB2;&#x89E3;&#x4E0B;&#x3002; &#x5199;&#x5728;&#x540E;&#x9762;&#x7684;&#x8BDD; &#x4ECA;&#x5929;&#x7684;&#x5206;&#x6790;&#x597D;&#x50CF;&#x5E76;&#x6CA1;&#x6709;&#x8FC7;&#x591A;&#x7684;&#x6D41;&#x7A0B;&#xFF0C;&#x4EE3;&#x7801;&#x770B;&#x8D77;&#x6765;&#x4E5F;&#x6BD4;&#x8F83;&#x7B80;&#x5355;&#xFF0C;&#x540E;&#x9762;&#x7684;&#x4F1A;&#x6BD4;&#x8F83;&#x590D;&#x6742;&#xFF0C;&#x6211;&#x4F1A;&#x5C06;&#x65F6;&#x5E8F;&#x56FE;&#x4E0A;&#x4F20;&#xFF0C;&#x65B9;&#x4FBF;&#x81EA;&#x5DF1;&#x4EE5;&#x540E;&#x590D;&#x4E60;&#x3002;","tags":[]},{"title":"数据结构栈操作之迷宫求解","date":"2017-08-16T13:36:44.731Z","path":"2017/08/16/maze/","text":"1.&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x535A;&#x5BA2;&#x5F88;&#x4E45;&#x6CA1;&#x6709;&#x66F4;&#x65B0;&#x4E86;&#xFF0C;&#x4E0D;&#x8FC7;&#x8FD9;&#x51E0;&#x4E2A;&#x6708;&#x5012;&#x662F;&#x6CA1;&#x6709;&#x505C;&#x4E0B;&#x5B66;&#x4E60;&#x7684;&#x811A;&#x6B65;&#x3002;&#x5148;&#x540E;&#x770B;&#x8FC7;&#x4E86;&#x300A;Android&#x5F00;&#x53D1;&#x827A;&#x672F;&#x63A2;&#x7D22;&#x300B;&#x3001;&#x300A;Java&#x865A;&#x62DF;&#x673A;&#x89C4;&#x8303;&#x300B;&#x4EE5;&#x53CA;&#x300A;&#x81EA;&#x5DF1;&#x52A8;&#x624B;&#x5199;Java&#x865A;&#x62DF;&#x673A;&#x300B;&#xFF0C;&#x5E76;&#x4E14;&#x6309;&#x7167;&#x300A;&#x81EA;&#x5DF1;&#x52A8;&#x624B;&#x5199;Java&#x865A;&#x62DF;&#x673A;&#x300B;&#x4E2D;&#x7684;&#x601D;&#x8DEF;&#x548C;&#x60F3;&#x6CD5;&#x5B9E;&#x73B0;&#x4E86;&#x4E00;&#x4E2A;&#x7B80;&#x5355;&#x7684;JVM&#x3002;&#x5F53;&#x7136;&#xFF0C;&#x5B9E;&#x73B0;&#x7684;&#x76EE;&#x7684;&#x4E3B;&#x8981;&#x662F;&#x4E3A;&#x4E86;&#x52A0;&#x6DF1;&#x7406;&#x89E3;&#x3002;&#x8BE5;&#x4E66;&#x4E2D;&#x4F7F;&#x7528;&#x7684;&#x662F;Go&#x8BED;&#x8A00;&#xFF0C;&#x6211;&#x5219;&#x4F7F;&#x7528;Java&#xFF08;&#x611F;&#x89C9;&#x6709;&#x70B9;&#x7528;&#x8F6E;&#x5B50;&#x627E;&#x8F6E;&#x5B50;&#x7684;&#x611F;&#x89C9;&#x30FD;(&#x2267;&#x25A1;&#x2266;)&#x30CE;&#xFF09;&#x3002; &#x8FD1;&#x671F;&#x5728;&#x770B;&#x6570;&#x636E;&#x7ED3;&#x6784;&#xFF0C;&#x8BFB;&#x5230;&#x7B2C;&#x4E09;&#x7AE0;&#x6808;&#x3002;&#x91CC;&#x9762;&#x6709;&#x4E00;&#x5C0F;&#x8282;&#x662F;&#x8BB2;&#x6808;&#x64CD;&#x4F5C;&#x7684;&#xFF0C;&#x5305;&#x62EC;&#x4E86;&#x6570;&#x5236;&#x8F6C;&#x6362;&#x3001;&#x62EC;&#x53F7;&#x5339;&#x914D;&#x7684;&#x68C0;&#x9A8C;&#x3001;&#x884C;&#x7F16;&#x8F91;&#x7A0B;&#x5E8F;&#x4EE5;&#x53CA;&#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x95EE;&#x9898;&#x7B49;&#x3002;&#x72B9;&#x8BB0;&#x5F97;&#x5F53;&#x5E74;&#x4E0A;&#x5B66;&#x7684;&#x65F6;&#x5019;&#x5BF9;&#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x5F88;&#x662F;&#x597D;&#x5947;&#xFF0C;&#x5982;&#x4F55;&#x4F7F;&#x7528;&#x6808;&#x5C31;&#x80FD;&#x627E;&#x5230;&#x4E00;&#x6761;&#x901A;&#x5F80;&#x51FA;&#x53E3;&#x7684;&#x8DEF;&#x6210;&#x4E3A;&#x5F53;&#x65F6;&#x7684;&#x96BE;&#x9898;&#xFF08;&#x5F53;&#x7136;&#x4E5F;&#x5305;&#x62EC;&#x73B0;&#x5728;&#xFF09;&#x3002; 2. &#x5173;&#x4E8E;&#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x95EE;&#x9898; &#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x95EE;&#x9898;&#x6211;&#x53EF;&#x4EE5;&#x7406;&#x89E3;&#x4E3A;&#x4E00;&#x4E2A;&#x975E;&#x5E38;&#x7B80;&#x5355;&#x7684;&#x201C;&#x4EBA;&#x5DE5;&#x667A;&#x80FD;&#x884C;&#x4E3A;&#x201D;&#xFF0C;&#x5373;&#x5F53;&#x6211;&#x5728;&#x5BFB;&#x627E;&#x8DEF;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#xFF0C;&#x6211;&#x53EA;&#x6309;&#x4E00;&#x4E2A;&#x65B9;&#x5411;&#x53BB;&#x5BFB;&#x627E;&#x51FA;&#x53E3;&#xFF0C;&#x5E76;&#x4E14;&#x6211;&#x5728;&#x8D70;&#x7684;&#x8FC7;&#x7A0B;&#x4E2D;&#x7559;&#x4E0B;&#x75D5;&#x8FF9;&#x3002;&#x5F53;&#x6211;&#x78B0;&#x5230;&#x6B64;&#x8DEF;&#x4E0D;&#x901A;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x6211;&#x53BB;&#x66F4;&#x6539;&#x65B9;&#x5411;&#xFF0C;&#x5728;&#x53BB;&#x6309;&#x7167;&#x4E0A;&#x9762;&#x65B9;&#x6CD5;&#x6267;&#x884C;&#x3002;&#x5982;&#x679C;&#x8FD8;&#x662F;&#x4E0D;&#x884C;&#xFF0C;&#x6211;&#x5C31;&#x6807;&#x8BB0;&#x201C;&#x8FD9;&#x6761;&#x8DEF;&#x4E0D;&#x80FD;&#x901A;&#x5411;&#x7EC8;&#x70B9;&#x201D;&#x3002;&#x5982;&#x6B64;&#x53CD;&#x590D;&#xFF0C;&#x8981;&#x4E48;&#x6211;&#x90FD;&#x6807;&#x8BB0;&#x201C;&#x8FD9;&#x6761;&#x8DEF;&#x4E0D;&#x80FD;&#x901A;&#x5411;&#x7EC8;&#x70B9;&#x201D;&#xFF0C;&#x8981;&#x4E48;&#x6211;&#x627E;&#x5230;&#x4E86;&#x51FA;&#x53E3;&#x3002; &#x4E66;&#x4E0A;&#x5173;&#x4E8E;&#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x7684;&#x7B97;&#x6CD5;&#x63CF;&#x8FF0;&#x4E3A;&#xFF1A;12345678910111213141516do { &#x82E5;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x53EF;&#x901A;&#xFF0C; &#x5219;{ &#x5C06;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x63D2;&#x5165;&#x6808;&#x9876;&#xFF0C; //&#x7EB3;&#x5165;&#x8DEF;&#x5F84; &#x82E5;&#x8BE5;&#x4F4D;&#x7F6E;&#x662F;&#x51FA;&#x53E3;&#x4F4D;&#x7F6E;&#xFF0C;&#x5219;&#x7ED3;&#x675F;&#xFF1B; //&#x6C42;&#x5F97;&#x8DEF;&#x5F84;&#x5B58;&#x653E;&#x6808;&#x4E2D; &#x5426;&#x5219;&#x5207;&#x6362;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x7684;&#x4E1C;&#x90BB;&#x65B9;&#x5757;&#x4E3A;&#x65B0;&#x7684;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#xFF1B; } &#x5426;&#x5219;&#xFF0C; &#x82E5;&#x6808;&#x4E0D;&#x4E3A;&#x7A7A;&#x4E14;&#x6808;&#x9876;&#x4F4D;&#x7F6E;&#x5C1A;&#x6709;&#x5176;&#x4ED6;&#x65B9;&#x5411;&#x672A;&#x7ECF;&#x63A2;&#x7D22;&#xFF0C; &#x5219;&#x8BBE;&#x5B9A;&#x65B0;&#x7684;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x4E3A;&#x6CBF;&#x987A;&#x65F6;&#x9488;&#x65B9;&#x5411;&#x65CB;&#x8F6C;&#x627E;&#x5230;&#x7684;&#x6808;&#x9876;&#x7684;&#x4E0B;&#x4E00;&#x76F8;&#x90BB;&#x5757;&#xFF1B; &#x82E5;&#x6808;&#x4E0D;&#x7A7A;&#x4F46;&#x6808;&#x9876;&#x4F4D;&#x7F6E;&#x7684;&#x56DB;&#x5468;&#x5747;&#x4E0D;&#x901A;&#xFF0C; &#x5219;&#xFF5B;&#x5220;&#x53BB;&#x6808;&#x9876;&#x4F4D;&#x7F6E;&#xFF1B; &#x82E5;&#x6808;&#x4E0D;&#x7A7A;&#xFF0C;&#x5219;&#x91CD;&#x65B0;&#x6D4B;&#x8BD5;&#x65B0;&#x7684;&#x6808;&#x9876;&#x4F4D;&#x7F6E;&#xFF0C; &#x76F4;&#x81F3;&#x627E;&#x5230;&#x4E00;&#x4E2A;&#x53EF;&#x901A;&#x7684;&#x76F8;&#x90BB;&#x5757;&#x6216;&#x51FA;&#x6808;&#x81F3;&#x6808;&#x7A7A;&#xFF1B; &#xFF5D;} while&#xFF08;&#x6808;&#x4E0D;&#x4E3A;&#x7A7A;&#xFF09; 3. &#x5173;&#x4E8E;&#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x7684;&#x4EE3;&#x7801;&#x5B9E;&#x73B0; &#x5728;&#x6570;&#x636E;&#x63A5;&#x53E3;&#x8FD9;&#x672C;&#x4E66;&#x4E2D;&#x6709;&#x4F2A;&#x4EE3;&#x7801;&#x5B9E;&#x73B0;&#x8FC7;&#x7A0B;&#xFF0C;&#x901A;&#x8FC7;&#x67E5;&#x9605;&#x8D44;&#x6599;&#x627E;&#x5230;&#x4E86;&#x5B9E;&#x73B0;&#x7684;&#x65B9;&#x6CD5;&#x3002; &#x7531;&#x4E8E;C&#x8BED;&#x8A00;&#x4E2D;&#x5B9A;&#x4E49;&#x6808;&#x64CD;&#x4F5C;&#x6BD4;&#x8F83;&#x7E41;&#x7410;&#xFF0C;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x8D34;&#x51FA;&#x3002;&#x4E0B;&#x9762;&#x7528;java&#x6765;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x8FC7;&#x7A0B;&#x3002;&#x9996;&#x5148;&#xFF0C;&#x8FF7;&#x5BAB;&#x7684;&#x6570;&#x636E;&#x7C7B;&#x578B;&#x3002;&#x5305;&#x62EC;&#x4E86;&#x5F53;&#x524D;&#x5143;&#x7D20;&#x7684;&#x65B9;&#x5411;&#xFF0C;&#x5E8F;&#x53F7;&#x4EE5;&#x53CA;&#x4F4D;&#x7F6E;&#x3002; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169/** * &#x8FF7;&#x5BAB;&#x7C7B; */public class Maze { public MazeMode di;//&#x65B9;&#x5411; public int ord;//&#x5E8F;&#x53F7; public Point pos = new Point();//&#x4F4D;&#x7F6E; //&#x8FF7;&#x5BAB;&#x7684;&#x957F;&#x5BBD; public static int MAZE_WIDTH = 16; /** * &#x8FF7;&#x5BAB;&#x7684;&#x679A;&#x4E3E;&#xFF0C;&#x5B9A;&#x4E49;&#x65B9;&#x5411;&#x4EE5;&#x53CA;&#x5899;&#x4F53;&#x969C;&#x788D;&#x7269;&#x7B49; */ public enum MazeMode { //&#x5899;&#x4F53; Wall(1), //&#x969C;&#x788D;&#x7269; Obstacle(2), //&#x8DEF; Way(3), //&#x6B7B;&#x80E1;&#x540C; DeadLock(4), //&#x4E1C; East(5), //&#x5357; South(6), //&#x897F; West(7), //&#x5317; North(8); public int value; MazeMode(int i) { value = i; } } /** * &#x662F;&#x5426;&#x53EF;&#x901A; * * @param pos &#x4F4D;&#x7F6E; * @param maze &#x8FF7;&#x5BAB; * @return true &#x53EF;&#x901A; false &#x4E0D;&#x53EF;&#x901A; */ public static boolean pass(Point pos, int maze[][]) { return !isCross(pos) &amp;&amp; maze[pos.x][pos.y] == MazeMode.Way.value; } /** * &#x6807;&#x8BB0;&#x8FD9;&#x4E2A;&#x4F4D;&#x7F6E;&#x4E3A;&#x5411;&#x4E1C;&#x5BFB;&#x627E; * * @param pos &#x4F4D;&#x7F6E; * @param maze &#x8FF7;&#x5BAB; */ public static void footPrint(Point pos, int maze[][]) { maze[pos.x][pos.y] = East.value; } /** * &#x4E0B;&#x4E00;&#x4F4D;&#x7F6E; * * @param curPos &#x5F53;&#x524D;&#x4F4D;&#x7F6E; * @param value &#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x7684;&#x65B9;&#x5411; */ public static void nextPos(Point curPos, int value) { switch (value) { case 5: curPos.y++; break; case 6: curPos.x++; break; case 7: curPos.y--; break; case 8: curPos.x--; break; } } /** * &#x662F;&#x5426;&#x8D8A;&#x754C; * @param pos &#x4F4D;&#x7F6E; * @return true &#x8D8A;&#x754C; false &#x6CA1;&#x6709; */ private static boolean isCross(Point pos) { return pos.x &lt; 0 || pos.x &gt; MAZE_WIDTH - 1 || pos.y &gt; MAZE_WIDTH - 1 || pos.y &lt; 0; } /** * &#x65B0;&#x7684;&#x65B9;&#x5411; * &#x6309;&#x7167;&#x4E1C;-&gt;&#x5357;-&gt;&#x897F;-&gt;&#x5317;&#x6765;&#xFF0C;&#x5F53;&#x4E3A;&#x5317;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x4E0D;&#x4F1A;&#x8FDB;&#x5165;&#x6B64;&#x65B9;&#x6CD5;&#x3002; * @param di &#x5F53;&#x524D;&#x65B9;&#x5411; * @return &#x65B0;&#x7684;&#x65B9;&#x5411; */ public static MazeMode nextDi(MazeMode di) { switch (di) { case East: return South; case South: return West; case West: return North; } return null; } /** * &#x7ED8;&#x5236;&#x8FF7;&#x5BAB; * @param maze &#x8FF7;&#x5BAB; */ private static void paintMaze(int[][] maze) { int i, j; for (i = 0; i &lt; MAZE_WIDTH; i++) { for (j = 0; j &lt; MAZE_WIDTH; j++) { if (maze[i][j] == Wall.value) { printf(&quot; &#x25A0; &quot;); } else if (maze[i][j] == Obstacle.value) { printf(&quot; &#x25A1; &quot;); } else if (maze[i][j] == East.value) { printf(&quot; &#x2192; &quot;); } else if (maze[i][j] == South.value) { printf(&quot; &#x2193; &quot;); } else if (maze[i][j] == North.value) { printf(&quot; &#x2191; &quot;); } else if (maze[i][j] == West.value) { printf(&quot; &#x2190; &quot;); } else if (maze[i][j] == DeadLock.value) { printf(&quot; &#x25CB; &quot;); } else { printf(&quot; &quot;); } if (j != 0 &amp;&amp; j % (MAZE_WIDTH - 1) == 0) { printf(&quot;\\n&quot;); } } } } /** * &#x8BBE;&#x7F6E;&#x6B7B;&#x80E1;&#x540C; * @param maze &#x8FF7;&#x5BAB; * @param pos &#x4F4D;&#x7F6E; */ public static void setDeadLock(int[][] maze, Point pos) { maze[pos.x][pos.y] = DeadLock.value; } private static void printf(String s) { System.out.print(s); } /** * &#x663E;&#x793A;&#x8FF7;&#x5BAB;&#xFF0C;200&#x6BEB;&#x79D2;&#x8F93;&#x51FA;&#x4E00;&#x6B21; * @param maze */ public static void showMaze(int[][] maze) { try { Thread.sleep(200); paintMaze(maze); } catch (InterruptedException e) { e.printStackTrace(); } }} &#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x7684;&#x4E3B;&#x8981;&#x7B97;&#x6CD5;&#xFF1A; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * &#x8FF7;&#x5BAB;&#x6C42;&#x89E3;&#x7B97;&#x6CD5; * @param maze &#x8FF7;&#x5BAB; * @param start &#x5F00;&#x59CB;&#x4F4D;&#x7F6E; * @param end &#x7ED3;&#x675F;&#x4F4D;&#x7F6E; */ public static void maze(int[][] maze, Point start, Point end) { //&#x5B9A;&#x4E49;&#x6808; Stack&lt;Maze&gt; record = new Stack&lt;&gt;(); //&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x4E3A;&#x5F00;&#x59CB;&#x4F4D;&#x7F6E; Point curPos = new Point(start.x, start.y); //&#x5F53;&#x524D;&#x662F;&#x7B2C;&#x51E0;&#x6B65; int curStep = 1; do {//&#x5F00;&#x59CB;&#x5FAA;&#x73AF;&#x4E86;&#x3002; if (pass(curPos, maze)) {//&#x5982;&#x679C;&#x5F53;&#x524D;&#x8DEF;&#x53EF;&#x901A; footPrint(curPos, maze);//&#x6807;&#x8BB0;&#x8FD9;&#x4E2A;&#x4F4D;&#x7F6E;&#x6211;&#x6765;&#x8FC7; showMaze(maze);//&#x7ED8;&#x5236;&#x8FF7;&#x5BAB; //&#x628A;&#x5F53;&#x524D;&#x6570;&#x636E;&#x5B58;&#x653E;&#x5230;&#x6808;&#x4E2D; Maze e = new Maze(); e.di = East; e.ord = curStep; e.pos.x = curPos.x; e.pos.y = curPos.y; record.push(e); if (curPos.x == end.x &amp;&amp; curPos.y == end.y) {//&#x7ED3;&#x675F;&#x6761;&#x4EF6;&#x5224;&#x65AD; println(&quot;&#x5BFB;&#x8DEF;&#x6210;&#x529F;&quot;); return; } //&#x53BB;&#x4E0B;&#x4E00;&#x4E2A;&#x4F4D;&#x7F6E;&#xFF0C;&#x5411;&#x4E1C;&#x524D;&#x884C;&#x3002; nextPos(curPos, East.value); } else {//&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x4E0D;&#x53EF;&#x901A;&#xFF0C;&#x5373;&#x6B64;&#x4F4D;&#x7F6E;&#x4E0D;&#x662F;way Maze temp = null; if (!record.empty()) { temp = record.pop();//&#x83B7;&#x5F97;&#x6808;&#x9876;&#x5143;&#x7D20;&#xFF0C;&#x5373;&#x524D;&#x4E00;&#x6B65;&#x7684;&#x4F4D;&#x7F6E; } assert temp != null;//&#x8FD9;&#x73A9;&#x610F;&#x80AF;&#x5B9A;&#x4E0D;&#x4E3A;&#x7A7A; while (temp.di == North &amp;&amp; !record.empty()) {//&#x5982;&#x679C;&#x6B64;&#x65F6;&#x4E0A;&#x4E00;&#x6B65;&#x662F;&#x5317;&#x65B9;&#x5411;&#xFF0C;&#x5219;&#x4EE3;&#x8868;&#x5DF2;&#x7ECF;&#x65E0;&#x8DEF;&#x53EF;&#x8D70;&#x4E86;&#xFF0C;&#x6807;&#x8BB0;&#x6B7B;&#x80E1;&#x540C; setDeadLock(maze, temp.pos); showMaze(maze);//&#x7ED8;&#x5236; temp = record.pop();//&#x518D;&#x83B7;&#x5F97;&#x6808;&#x9876; } if (temp.di.value &lt; North.value) {//&#x5982;&#x679C;&#x5F53;&#x524D;&#x5143;&#x7D20;&#x8FD8;&#x4E0D;&#x4E3A;&#x5317;&#x65B9;&#x5411; maze[temp.pos.x][temp.pos.y] = temp.di.value + 1;//&#x65B9;&#x5411;&#x503C;+1 temp.di = nextDi(temp.di);//&#x5F53;&#x524D;&#x5143;&#x7D20;&#x7684;&#x653E;&#x4E0B;&#x4E3A;&#x4E0B;&#x4E00;&#x4E2A;&#x65B9;&#x5411; showMaze(maze);//&#x8F93;&#x51FA; record.push(temp);//&#x538B;&#x6808; //&#x8BBE;&#x7F6E;&#x5F53;&#x524D;&#x4F4D;&#x7F6E;&#x4E3A;&#x8FD9;&#x4E2A;&#x5143;&#x7D20;&#x7684;&#x4F4D;&#x7F6E; curPos.x = temp.pos.x; curPos.y = temp.pos.y; //&#x83B7;&#x53D6;&#x4E0B;&#x4E2A;&#x5143;&#x7D20; nextPos(curPos, temp.di.value); } } } while (!record.empty()); println(&quot;&#x5BFB;&#x8DEF;&#x5931;&#x8D25;&quot;); } public static void println(String s) { System.out.println(s); } &#x6D4B;&#x8BD5;&#x4EE3;&#x7801;&#xFF1A; 123456789101112131415161718192021222324public static void main(String[] args) { int[][] maze = new int[MAZE_WIDTH][MAZE_WIDTH]; Point start = new Point(1, 0); Point end = new Point(MAZE_WIDTH - 2, MAZE_WIDTH - 1); for (int i = 0; i &lt; maze.length; i++) { for (int j = 0; j &lt; maze.length; j++) { if (i == 0 || j == 0 || i == MAZE_WIDTH - 1 || j == MAZE_WIDTH - 1) { maze[i][j] = Wall.value; } else { if (Math.random() * MAZE_WIDTH &gt; 4) { maze[i][j] = Way.value; } else { maze[i][j] = Obstacle.value; } } } } //&#x8BBE;&#x7F6E;&#x6700;&#x540E;&#x4EE5;&#x53CA;&#x8FDE;&#x63A5;&#x6700;&#x540E;&#x7684;&#x4F4D;&#x7F6E;&#x548C;&#x5F00;&#x59CB;&#x4F4D;&#x7F6E;&#x4EE5;&#x53CA;&#x8FDE;&#x63A5;&#x5F00;&#x59CB;&#x7684;&#x4F4D;&#x7F6E;&#x90FD;&#x53EF;&#x901A;&#xFF0C;&#x63D0;&#x9AD8;&#x6210;&#x529F;&#x7387; maze[1][0] = maze[MAZE_WIDTH - 2][MAZE_WIDTH - 1] = Way.value; maze[1][1] = maze[MAZE_WIDTH - 2][MAZE_WIDTH - 2] = Way.value; maze(maze, start, end); } &#x6D4B;&#x8BD5;&#x7ED3;&#x679C;&#xFF0C;&#x6709;&#x56FE;&#x6709;&#x771F;&#x76F8;&#x3002; 4. &#x5199;&#x5728;&#x6700;&#x540E; 2017&#x5E74;&#x5DF2;&#x8FC7;&#x5927;&#x534A;&#xFF0C;&#x6362;&#x4E86;&#x65B0;&#x7684;&#x5DE5;&#x4F5C;&#xFF0C;&#x65B0;&#x7684;&#x73AF;&#x5883;&#x3002;&#x5E0C;&#x671B;&#x81EA;&#x5DF1;&#x80FD;&#x591F;&#x575A;&#x6301;&#x5B66;&#x4E60;&#x4E0B;&#x53BB;&#x3002;&#x98CE;&#x8F7B;&#x4E91;&#x6DE1;&#xFF0C;&#x52FF;&#x5FD8;&#x521D;&#x5FC3;&#x3002;","tags":[]},{"title":"Android Handler消息机制不完全解析","date":"2017-03-18T15:33:43.609Z","path":"2017/03/18/Android-Handler/","text":"1.Handler&#x7684;&#x4F5C;&#x7528; Android&#x5F00;&#x53D1;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x7ECF;&#x5E38;&#x4F7F;&#x7528;Handler&#x8FDB;&#x884C;&#x9875;&#x9762;&#x7684;&#x66F4;&#x65B0;&#x3002;&#x4F8B;&#x5982;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5728;&#x4E00;&#x4E2A;&#x4E0B;&#x8F7D;&#x4EFB;&#x52A1;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x53BB;&#x66F4;&#x65B0;&#x6211;&#x4EEC;&#x7684;UI&#x6548;&#x679C;&#xFF0C;&#x56E0;&#x4E3A;AndroidUI&#x64CD;&#x4F5C;&#x4E0D;&#x662F;&#x7EBF;&#x7A0B;&#x5B89;&#x5168;&#x7684;&#xFF0C;&#x4E5F;&#x5C31;&#x610F;&#x5473;&#x7740;&#x6211;&#x4EEC;&#x4E0D;&#x80FD;&#x5728;&#x975E;UI&#x7EBF;&#x7A0B;&#x4E2D;&#x53BB;&#x64CD;&#x4F5C;UI&#xFF0C;&#x5426;&#x5219;&#x4F1A;&#x629B;&#x51FA;CalledFromWrongThreadException&#x5F02;&#x5E38;&#x3002; Handler&#x7684;&#x57FA;&#x672C;&#x7528;&#x6CD5;&#xFF1A;1234567891011121314151617181920212223242526Handler handler = new Handler() { @Override public void handleMessage(Message msg) { switch (msg.what) { //do something } }};Handler handler1 = new Handler(new Handler.Callback() { @Override public boolean handleMessage(Message msg) { switch (msg.what) { //do something } return false; }});handler.sendEmptyMessage(1);handler.post(new Runnable() { @Override public void run() { }});... &#x4E0A;&#x9762;&#x662F;&#x6211;&#x4EEC;&#x719F;&#x6089;&#x7684;Handler&#x7684;&#x7528;&#x6CD5;&#xFF0C;&#x901A;&#x8FC7;&#x51E0;&#x5929;&#x7684;&#x6E90;&#x7801;&#x9605;&#x8BFB;&#xFF0C;&#x4ECA;&#x5929;&#x5199;&#x4E0B;&#x6211;&#x5BF9;Handler&#x7684;&#x4E0D;&#x5B8C;&#x5168;&#x89E3;&#x6790;&#x5427;&#x3002;&#x4E3A;&#x4EC0;&#x4E48;&#x8BF4;&#x4E0D;&#x5B8C;&#x5168;&#x5462;&#xFF1F;&#x56E0;&#x4E3A;&#x80FD;&#x529B;&#x6709;&#x9650;&#xFF0C;&#x6240;&#x4EE5;&#x5E76;&#x6CA1;&#x6709;&#x5305;&#x62EC;native&#x4EE3;&#x7801;&#x7684;&#x89E3;&#x6790;&#x3002;&#x624B;&#x52A8;&#x6ED1;&#x7A3D;&#x3002; 2.&#x6E90;&#x7801;&#x4E0D;&#x5B8C;&#x5168;&#x89E3;&#x6790; &#x63D0;&#x524D;&#x58F0;&#x660E;&#x4E0B;&#xFF0C;&#x8FD9;&#x91CC;&#x7684;&#x89E3;&#x6790;&#x57FA;&#x672C;&#x4E0A;&#x90FD;&#x662F;&#x5EFA;&#x7ACB;&#x5728;&#x7F51;&#x4E0A;&#x67E5;&#x9605;&#x8D44;&#x6599;&#x4EE5;&#x53CA;&#x81EA;&#x5DF1;&#x6E90;&#x7801;&#x7684;&#x7406;&#x89E3;&#x3002;&#x5982;&#x679C;&#x6709;&#x95EE;&#x9898;&#xFF0C;&#x8BF7;&#x6307;&#x51FA;&#x3002;&#x5728;&#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x5148;&#x67E5;&#x770B;Handler&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x3002; 12345678910111213141516171819//&#x65E0;&#x53C2;&#x6784;&#x9020;&#x65B9;&#x6CD5;public Handler() { this(null, false);}//&#x53C2;&#x6570;&#x4E3A;Looper&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;public Handler(Looper looper) { this(looper, null, false);}//&#x53C2;&#x6570;&#x4E3A;Callback&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;public Handler(Callback callback) { this(callback, false);}//&#x53C2;&#x6570;&#x4E3A;Looper&#x548C;Callback&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;public Handler(Looper looper, Callback callback) { this(looper, callback, false);} &#x4ECE;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x770B;&#xFF0C;&#x4ED6;&#x4EEC;&#x7ADF;&#x7136;&#x540E;&#x9762;&#x7684;&#x90FD;&#x6709;&#x4E00;&#x4E2A;&#x503C;&#x4E3A;false&#x7684;&#x53C2;&#x6570;&#xFF0C;&#x6211;&#x4EEC;&#x968F;&#x4FBF;&#x770B;&#x4E00;&#x4E2A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x3002; 12345678910111213141516171819/** * @param callback The callback interface in which to handle messages, or null.* @param async If true, the handler calls {@link Message#setAsynchronous(boolean)} for* each {@link Message} that is sent to it or {@link Runnable} that is posted to it.** @hide*/public Handler(Callback callback, boolean async) { ... mLooper = Looper.myLooper(); if (mLooper == null) { //&#x5728;&#x5B50;&#x7EBF;&#x7A0B;&#x4E2D;&#x521B;&#x5EFA;Handler&#x7684;&#x65F6;&#x5019;&#x4F1A;&#x629B;&#x51FA;&#x7684;&#x5F02;&#x5E38;&#x3002; throw new RuntimeException( &quot;Can&apos;t create handler inside thread that has not called Looper.prepare()&quot;); } mQueue = mLooper.mQueue;//&#x628A;Looper&#x7684;MessageQueue&#x8D4B;&#x503C;&#x7ED9;Handler&#x7684;mQuene&#x5C5E;&#x6027; mCallback = callback;//Callback&#x8D4B;&#x503C; mAsynchronous = async;//&#x662F;&#x5426;&#x4E3A;&#x5F02;&#x6B65;&#x7684;&#x6807;&#x5FD7;} &#x770B;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x7684;&#x5BF9;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x53C2;&#x6570;&#x7684;&#x6CE8;&#x91CA;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x77E5;&#x9053;&#xFF0C;&#x6700;&#x540E;&#x4E00;&#x4E2A;&#x53C2;&#x6570;&#x662F;&#x662F;&#x5426;&#x5F02;&#x6B65;&#x6267;&#x884C;&#x7684;&#x6807;&#x5FD7;&#xFF0C;&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53C8;&#x662F;&#x88AB;&#x9690;&#x85CF;&#x7684; @hide &#xFF0C;&#x6211;&#x4EEC;&#x65E0;&#x6CD5;&#x663E;&#x793A;&#x7684;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF0C;&#x4F46;&#x662F;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x6765;&#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF08;&#x5F85;&#x6D4B;&#x8BD5;&#xFF09;&#x3002;OK&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x77E5;&#x9053;&#xFF0C;&#x6211;&#x4EEC;&#x6240;&#x6709;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x90FD;&#x662F;&#x540C;&#x6B65;&#x7684;&#xFF0C;&#x5E76;&#x6CA1;&#x6709;&#x5F02;&#x6B65;&#x6267;&#x884C;&#x3002; &#x4E0A;&#x9762;&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x4E2D;&#x5305;&#x62EC;&#x4E86;&#x4E00;&#x4E2A;Looper&#x5BF9;&#x8C61;&#xFF0C;&#x4E00;&#x4E2A;MessageQueue&#x5BF9;&#x8C61;&#xFF0C;&#x6211;&#x4EEC;&#x6765;&#x770B;&#x770B;&#x8FD9;&#x4E24;&#x4E2A;&#x5230;&#x5E95;&#x662F;&#x4EC0;&#x4E48;&#xFF1F;&#x4EC0;&#x4E48;&#x65F6;&#x5019;&#x521B;&#x5EFA;&#x7684;&#xFF1F; &#x5148;&#x6765;&#x770B;&#x770B;Looper&#xFF1A; 1234567891011public final class Looper { private static final String TAG = &quot;Looper&quot;; // sThreadLocal.get() will return null unless you&apos;ve called prepare(). //&#x4F7F;&#x7528;ThreadLocal&#x6765;&#x786E;&#x4FDD;&#x4E00;&#x4E2A;&#x7EBF;&#x7A0B;&#x4E2D;&#x53EA;&#x5B58;&#x5728;&#x4E00;&#x4E2A;Looper static final ThreadLocal&lt;Looper&gt; sThreadLocal = new ThreadLocal&lt;Looper&gt;(); private static Looper sMainLooper; // guarded by Looper.class final MessageQueue mQueue; final Thread mThread; ...} &#x6211;&#x4EEC;&#x63A5;&#x7740;&#x770B;&#x4E0B; Looper.myLooper() &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF1A; 1234public static @Nullable Looper myLooper() { //&#x76F4;&#x63A5;&#x628A;sThreadLocal&#x4E2D;&#x7684;Looper&#x5BF9;&#x8C61;&#x8FD4;&#x56DE; return sThreadLocal.get();} &#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#x8BE5;&#x65B9;&#x6CD5;&#x76F4;&#x63A5;&#x8FD4;&#x56DE;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7684;Looper&#xFF0C;&#x5982;&#x679C;&#x4E3A;null&#x7684;&#x8BDD;&#xFF0C;&#x90A3;&#x4E48;&#x629B;&#x51FA;&#x4E86;&#x4E00;&#x4E2A;&#x5F02;&#x5E38;Can&#x2019;t create handler inside thread that has not called Looper.prepare()&#xFF0C;&#x5F53;&#x7136;&#x5566;&#xFF0C;&#x6211;&#x4EEC;&#x7684;Handler&#x5728;&#x4E3B;&#x7EBF;&#x7A0B;&#x4E2D;&#x521B;&#x5EFA;&#x7684;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x5F97;&#x5230;&#x7684;Looper&#x5BF9;&#x8C61;&#x4E00;&#x5B9A;&#x662F;&#x4E0D;&#x4E3A;null&#x7684;&#x3002;&#x4E3A;&#x4EC0;&#x4E48;&#x8FD9;&#x4E48;&#x80AF;&#x5B9A;&#x5462;&#xFF1F;&#x8FD9;&#x8981;&#x4ECE;App&#x7684;&#x542F;&#x52A8;&#x6D41;&#x7A0B;&#x8BF4;&#x8D77;&#xFF08;&#x6709;&#x70B9;&#x626F;&#x8FDC;&#x4E86;&#xFF0C;&#x4E5F;&#x662F;&#x6211;&#x4E0B;&#x4E2A;&#x9636;&#x6BB5;&#x6B63;&#x5728;&#x770B;&#x7684;&#xFF09;&#x3002;&#x6211;&#x4EEC;&#x77E5;&#x9053;Android &#x7CFB;&#x7EDF;&#x57FA;&#x4E8E;Linux&#x7684;&#xFF0C;&#x6211;&#x4EEC;&#x6BCF;&#x4E2A;App&#x90FD;&#x76F8;&#x5F53;&#x4E8E;&#x4E00;&#x4E2A;&#x662F;&#x7CFB;&#x7EDF;&#x7684;&#x5B50;&#x8FDB;&#x884C;&#x3002;&#x4E3E;&#x4E2A;&#x6817;&#x5B50;&#xFF1A;&#x6211;&#x4EEC;&#x7684;Eclipse&#xFF08;&#x597D;&#x4E45;&#x4E0D;&#x7528;&#x4E86;&#xFF09;&#x4E2D;&#x6709;&#x5F88;&#x591A;&#x4E2A;&#x5DE5;&#x7A0B;&#xFF0C;&#x5F53;&#x6211;&#x4EEC;&#x6267;&#x884C;&#x67D0;&#x4E00;&#x4E2A;&#x5DE5;&#x7A0B;&#x7684;&#x65F6;&#x5019;&#x5C31;&#x76F8;&#x5F53;&#x4E8E;Eclipse&#x7ED9;&#x6211;&#x4EEC;&#x7684;&#x5DE5;&#x7A0B;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;&#x8FDB;&#x7A0B;&#xFF0C;&#x901A;&#x8FC7;&#x8C03;&#x7528;&#x5DE5;&#x7A0B;&#x7684;&#x5165;&#x53E3;&#x65B9;&#x6CD5;&#x2014;&#x2014;main()&#x65B9;&#x6CD5;&#x6765;&#x542F;&#x52A8;&#x3002;&#x6211;&#x4EEC;App&#x542F;&#x52A8;&#x4E5F;&#x662F;&#x8FD9;&#x4E2A;&#x6D41;&#x7A0B;&#xFF0C;&#x5165;&#x53E3;&#x5728;ActivityThread&#x4E2D;&#x3002;&#x6211;&#x4EEC;&#x6765;&#x770B;&#x4E0B;main()&#x65B9;&#x6CD5;&#xFF1A; 123456789101112131415161718192021222324public static void main(String[] args) { ... //&#x521B;&#x5EFA;mainLooper&#x3002;&#x8FD9;&#x91CC;mark&#x4E0B;&#xFF0C;&#x4E00;&#x4F1A;&#x8981;&#x770B; Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false); if (sMainThreadHandler == null) { sMainThreadHandler = thread.getHandler(); } if (false) { Looper.myLooper().setMessageLogging(new LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;)); } // End of event ActivityThreadMain. Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); //&#x5F00;&#x59CB;&#x5FAA;&#x73AF;&#x5904;&#x7406;&#x6D88;&#x606F;==&gt;&gt;&#x6B7B;&#x5FAA;&#x73AF;&#xFF0C;&#x5E94;&#x7528;&#x4E0D;&#x4F1A;&#x9000;&#x51FA; Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);} &#x6211;&#x4EEC;&#x8981;&#x6CE8;&#x610F;&#x7684;&#x662F; Looper.prepareMainLooper() &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF1A; 12345678910111213141516171819202122232425262728293031public static void prepareMainLooper() { prepare(false); synchronized (Looper.class) { if (sMainLooper != null) { throw new IllegalStateException(&quot;The main Looper has already been prepared.&quot;); } sMainLooper = myLooper(); }}private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(&quot;Only one Looper may be created per thread&quot;); } //&#x521B;&#x5EFA;&#x4E00;&#x4E2A;Looper&#xFF0C;&#x5E76;&#x548C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x201C;&#x7ED1;&#x5B9A;&#x201D; sThreadLocal.set(new Looper(quitAllowed));}public static @Nullable Looper myLooper() { return sThreadLocal.get();}//ThreadLocalpublic void set(T value) { Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);} &#x89E3;&#x91CA;&#x4E0B;&#x5927;&#x6982;&#x610F;&#x601D;&#xFF1A;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;Looper&#x5BF9;&#x8C61;&#xFF0C;&#x5E76;&#x4E0E;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x7ED1;&#x5B9A;&#xFF0C;&#x63A5;&#x4E0B;&#x6765;&#x770B;&#x4E0B;Looper&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;: 1234private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread();} &#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53EA;&#x662F;&#x521B;&#x5EFA;&#x4E86;&#x4E00;&#x4E2A;MessageQueue&#x5BF9;&#x8C61;&#xFF0C;&#x8FD9;&#x91CC;&#x7B80;&#x5355;&#x770B;&#x4E0B;MessageQueue&#x7684;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#xFF1A; 12345//quitAllowed&#x662F;&#x5426;&#x5141;&#x8BB8;&#x505C;&#x6B62;MessageQueue(boolean quitAllowed) { mQuitAllowed = quitAllowed; mPtr = nativeInit();//native&#x65B9;&#x6CD5;} &#x6211;&#x4EEC;&#x8FD9;&#x91CC;&#x770B;Looper&#x6700;&#x91CD;&#x8981;&#x7684;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;loop()&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(&quot;No Looper; Looper.prepare() wasn&apos;t called on this thread.&quot;); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); //&#x6B7B;&#x5FAA;&#x73AF; for (;;) { //&#x5982;&#x679C;&#x6709;&#x6D88;&#x606F;&#x6765;&#x4E86;&#x4F1A;&#x5524;&#x9192;&#xFF0C;&#x6CA1;&#x6709;&#x7684;&#x8BDD;&#x4F1A;&#x963B;&#x585E;&#xFF0C;&#x5524;&#x9192;&#x64CD;&#x4F5C;&#x540E;&#x9762;&#x4F1A;&#x63D0;&#x5230; Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger final Printer logging = me.mLogging; if (logging != null) { logging.println(&quot;&gt;&gt;&gt;&gt;&gt; Dispatching to &quot; + msg.target + &quot; &quot; + msg.callback + &quot;: &quot; + msg.what); } final long traceTag = me.mTraceTag; if (traceTag != 0 &amp;&amp; Trace.isTagEnabled(traceTag)) { Trace.traceBegin(traceTag, msg.target.getTraceName(msg)); } try { //&#x8C03;&#x7528;Handler&#x7684;dispatchMessage&#x65B9;&#x6CD5; msg.target.dispatchMessage(msg); } finally { if (traceTag != 0) { Trace.traceEnd(traceTag); } } if (logging != null) { logging.println(&quot;&lt;&lt;&lt;&lt;&lt; Finished to &quot; + msg.target + &quot; &quot; + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn&apos;t corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, &quot;Thread identity changed from 0x&quot; + Long.toHexString(ident) + &quot; to 0x&quot; + Long.toHexString(newIdent) + &quot; while dispatching to &quot; + msg.target.getClass().getName() + &quot; &quot; + msg.callback + &quot; what=&quot; + msg.what); } msg.recycleUnchecked(); }} &#x4ECE;&#x6784;&#x9020;&#x65B9;&#x6CD5;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;&#x6211;&#x4EEC;&#x7684;mainLooper&#x662F;&#x4E0D;&#x5141;&#x8BB8;&#x505C;&#x6B62;&#x7684;&#x3002;&#x770B;&#x5230;&#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x8981;&#x8F6C;&#x56DE;&#x53BB;&#x770B;&#x770B;&#x6211;&#x4EEC;&#x7684;Handler sendEmptyMessage &#x662F;&#x5982;&#x4F55;&#x5904;&#x7406;&#x7684;&#xFF1A; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public final boolean sendEmptyMessage(int what){ return sendEmptyMessageDelayed(what, 0);}public final boolean sendEmptyMessageDelayed(int what, long delayMillis) { Message msg = Message.obtain();//&#x751F;&#x6210;&#x4E00;&#x4E2A;Message&#x5BF9;&#x8C61; msg.what = what; return sendMessageDelayed(msg, delayMillis);} public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message();}public final boolean sendMessageDelayed(Message msg, long delayMillis){ if (delayMillis &lt; 0) { delayMillis = 0; } return sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);}public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + &quot; sendMessageAtTime() called with no mQueue&quot;); Log.w(&quot;Looper&quot;, e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis);//&#x6D88;&#x606F;&#x5165;&#x961F;&#x64CD;&#x4F5C;}private boolean enqueueMessage(MessageQueue queue, Message msg, long uptimeMillis) { msg.target = this;//&#x8FD9;&#x91CC;&#x6CE8;&#x610F;&#x4E0B;&#xFF0C;&#x628A;&#x5F53;&#x524D;Handler&#x5BF9;&#x8C61;&#x8D4B;&#x503C;&#x7ED9;target&#xFF0C;&#x540E;&#x9762;&#x4F1A;&#x7528;&#x5230; if (mAsynchronous) { msg.setAsynchronous(true); } return queue.enqueueMessage(msg, uptimeMillis);} &#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x4E5F;&#x633A;&#x7B80;&#x5355;&#xFF0C;&#x6267;&#x884C;&#x8FC7;&#x7A0B;&#x4E2D;&#x5982;&#x679C; Message&#x4E3A;null &#x7684;&#x8BDD;&#xFF0C;&#x5C31;&#x751F;&#x6210;&#x4E00;&#x4E2A;Message&#xFF0C;&#x628A;&#x5F53;&#x524D;Handler&#x8D4B;&#x503C;&#x7ED9;Message&#x5BF9;&#x8C61;&#x7684;target&#x5C5E;&#x6027;&#xFF0C;&#x7136;&#x540E;&#x8C03;&#x7528;MessageQueue &#x7684;&#x5165;&#x961F;&#x65B9;&#x6CD5;enqueueMessage&#xFF1A; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455boolean enqueueMessage(Message msg, long when) { if (msg.target == null) { throw new IllegalArgumentException(&quot;Message must have a target.&quot;); } if (msg.isInUse()) { throw new IllegalStateException(msg + &quot; This message is already in use.&quot;); } synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + &quot; sending message to a Handler on a dead thread&quot;); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when &lt; p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { // Inserted within the middle of the queue. Usually we don&apos;t have to wake // up the event queue unless there is a barrier at the head of the queue // and the message is the earliest asynchronous message in the queue. needWake = mBlocked &amp;&amp; p.target == null &amp;&amp; msg.isAsynchronous(); Message prev; //&#x5165;&#x961F;&#x64CD;&#x4F5C;&#xFF0C;&#x628A;&#x65B0;&#x7684;&#x6D88;&#x606F;&#x653E;&#x5230;&#x6700;&#x540E;&#x9762; for (;;) { prev = p; p = p.next; if (p == null || when &lt; p.when) { break; } if (needWake &amp;&amp; p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } // We can assume mPtr != 0 because mQuitting is false. if (needWake) { nativeWake(mPtr);//&#x5524;&#x9192;Looper.loop()&#x4E2D;&#x7684;queue.next()&#xFF0C;&#x7EE7;&#x7EED;&#x6267;&#x884C; } } return true;} &#x4ECE;&#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x770B;&#x5230;&#xFF0C;&#x6211;&#x4EEC;&#x7684;Handler&#x628A;&#x8FD9;&#x6761;&#x6D88;&#x606F;&#x653E;&#x5165;&#x5230;MessageQueue&#x7684;&#x5C3E;&#x90E8;&#xFF0C;&#x5373;&#x5148;&#x8FDB;&#x5148;&#x51FA;&#xFF0C;&#x5982;&#x679C;&#x8FD9;&#x4E2A;&#x961F;&#x5217;&#x4E2D;&#x6CA1;&#x6709;&#x6D88;&#x606F;&#xFF0C;&#x5373;&#x5F53;&#x524D;&#x5904;&#x4E8E;&#x963B;&#x585E;&#x72B6;&#x6001;&#xFF0C;&#x5219;&#x5524;&#x9192;Looper.loop() &#x4E2D;&#x7684; queue.next()&#xFF0C;&#x7EE7;&#x7EED;&#x5904;&#x7406;&#x8FD9;&#x4E2A;&#x6D88;&#x606F;&#x3002;&#x6211;&#x4EEC;&#x4E0A;&#x9762;&#x63D0;&#x5230;&#x4E86;Looper.loop() &#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#xFF0C;&#x5B83;&#x662F;&#x4E00;&#x4E2A;&#x6B7B;&#x5FAA;&#x73AF;&#xFF0C;&#x5982;&#x679C;&#x5F53;&#x524D;&#x7684;&#x6D88;&#x606F;&#x4E0D;&#x4E3A;null&#x7684;&#x65F6;&#x5019;&#x5C31;&#x53BB;&#x6267;&#x884C;msg.target.dispatchMessage(msg)&#xFF0C;&#x53BB;&#x5904;&#x7406;&#x8FD9;&#x4E2A;&#x6D88;&#x606F;&#xFF1A; 12345678910111213141516171819202122232425public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { //mCallback&#x7684;handleMessage&#x65B9;&#x6CD5;&#x5982;&#x679C;&#x8FD4;&#x56DE;true&#xFF0C;&#x5219;&#x4E0D;&#x4F1A;&#x7EE7;&#x7EED;&#x6267;&#x884C;handleMessage&#x65B9;&#x6CD5; if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); }}private static void handleCallback(Message message) { //&#x8FD9;&#x4E2A;callback&#x662F;&#x901A;&#x8FC7;handler.post(new Runnable)&#x65B9;&#x5F0F;&#x4F20;&#x9012;&#x8FC7;&#x6765;&#x7684;&#xFF0C;&#x6267;&#x884C;&#x5176;run()&#x65B9;&#x6CD5; message.callback.run();} public interface Callback { public boolean handleMessage(Message msg);} public void handleMessage(Message msg) {} &#x5728;&#x5904;&#x7406;&#x6D88;&#x606F;&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x5148;&#x5224;&#x65AD;msg.callback&#x662F;&#x4E0D;&#x662F;&#x4E3A;null&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x4E3A;null&#xFF0C;&#x5219;&#x6267;&#x884C;&#x5176;run()&#x65B9;&#x6CD5;&#xFF0C;&#x5426;&#x5219;&#x5224;&#x65AD;Callback&#x662F;&#x5426;&#x4E3A;null&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x4E3A;null&#x5219;&#x6267;&#x884C;Callback &#x4E2D;&#x7684; handleMessage&#x65B9;&#x6CD5;&#xFF0C;&#x5E76;&#x6839;&#x636E;&#x5176;&#x8FD4;&#x56DE;&#x503C;&#x6765;&#x5224;&#x65AD;&#x662F;&#x5426;&#x6267;&#x884C;Hadler&#x7684;handleMessage&#x65B9;&#x6CD5;&#x3002; &#x6240;&#x6709;&#x7684;&#x65B9;&#x6CD5;&#x90FD;&#x662F;&#x5728;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x53BB;&#x6267;&#x884C;&#x7684;&#x3002; By the way, ViewRootImpl&#x4E2D;&#x6709;&#x4E00;&#x4E2A;checkThread()&#x65B9;&#x6CD5;&#xFF0C;&#x7528;&#x6765;&#x5224;&#x65AD;&#x662F;&#x4E0D;&#x662F;&#x5904;&#x4E8E; &#x5F53;&#x524D; &#x7EBF;&#x7A0B; &#x7531;&#x4E8E;&#x80FD;&#x529B;&#x6709;&#x9650;&#x8FD9;&#x91CC;&#x6211;&#x6CA1;&#x6709;&#x5BF9;native&#x65B9;&#x6CD5;&#x8FDB;&#x884C;&#x89E3;&#x6790;&#xFF0C;&#x6709;&#x673A;&#x4F1A;&#x7684;&#x8BDD;&#x518D;&#x53BB;&#x6DF1;&#x5165;&#x7814;&#x7A76;&#x4E0B;&#x3002; 3.&#x6211;&#x7684;&#x7406;&#x89E3; &#x7B80;&#x5355;&#x7684;&#x8BF4;&#xFF0C;&#x6211;&#x8BA4;&#x4E3A;Looper&#x3001;Handler&#x5C31;&#x662F;&#x8BA9;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x6267;&#x884C;&#x5F53;&#x524D;&#x7EBF;&#x7A0B;&#x4E2D;&#x6240;&#x6709;&#x7684;&#x6D88;&#x606F;&#xFF0C;Handler&#x5BF9;&#x8C61;&#x5728;&#x54EA;&#x4E2A;&#x7EBF;&#x7A0B;&#x88AB;&#x521B;&#x5EFA;&#xFF0C;&#x5176;&#x6D88;&#x606F;&#x7684;&#x6267;&#x884C;&#x5C06;&#x4F1A;&#x5728;&#x88AB;&#x521B;&#x5EFA;&#x7684;&#x90A3;&#x4E2A;&#x7EBF;&#x7A0B;&#x4E2D;&#x6267;&#x884C;&#x3002; &#x57FA;&#x4E8E;Handler&#x548C;Looper&#x7684;&#x6E90;&#x7801;&#xFF0C;&#x6211;&#x81EA;&#x5DF1;&#x5199;&#x4E86;&#x4E00;&#x4E2A;&#x7C7B;&#x4F3C;Handler&#x6D88;&#x606F;&#x673A;&#x5236;&#xFF0C;&#x4FBF;&#x4E8E;&#x7406;&#x89E3;&#x548C;&#x8BB0;&#x5FC6;&#x3002;&#x6E90;&#x7801;&#x5728;GitHub&#x4E0A;&#xFF0C;&#x6B22;&#x8FCE;&#x8BA8;&#x8BBA;&#x3002;","tags":[]},{"title":"Android 事件统计","date":"2017-03-17T13:00:51.758Z","path":"2017/03/17/Android-Listener/","text":"1.&#x5199;&#x5728;&#x524D;&#x9762;&#x7684;&#x8BDD; &#x6700;&#x8FD1;&#x90FD;&#x5728;&#x770B;framework&#x7684;&#x4E1C;&#x897F;&#xFF0C;&#x4E5F;&#x51E0;&#x5929;&#x6CA1;&#x6709;&#x5199;&#x4EC0;&#x4E48;&#x4E1C;&#x897F;&#xFF0C;&#x4ECA;&#x5929;&#x6709;&#x70B9;&#x65F6;&#x95F4;&#x5199;&#x4E0B;&#x4E0A;&#x6B21;&#x9762;&#x8BD5;&#x9047;&#x5230;&#x7684;&#x4E00;&#x4E2A;&#x95EE;&#x9898;&#x3002;&#x95EE;&#x9898;&#x5927;&#x6982;&#x662F;&#x8FD9;&#x6837;&#x7684;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x9700;&#x8981;&#x7EDF;&#x8BA1;&#x9875;&#x9762;&#x7684;&#x70B9;&#x51FB;&#x4E8B;&#x4EF6;&#xFF0C;&#x5373;&#x6DFB;&#x52A0;&#x57CB;&#x70B9;&#x8FDB;&#x884C;&#x7EDF;&#x8BA1;&#xFF0C;&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#xFF1F;&#x6211;&#x5F53;&#x65F6;&#x56DE;&#x7B54;&#x7684;&#x662F;&#x53CD;&#x5C04;&#x52A0;&#x4EE3;&#x7406;&#x53BB;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x529F;&#x80FD;&#x3002;&#x6709;&#x670B;&#x53CB;&#x8BF4;&#xFF0C;&#x8FD9;&#x4E0D;&#x662F;&#x5F88;&#x7B80;&#x5355;&#x561B;&#xFF0C;&#x76F4;&#x63A5;&#x7528;&#x4EE3;&#x7406;&#x6A21;&#x5F0F;&#x5C31;OK&#x4E86;&#x554A;&#xFF0C;&#x5E72;&#x561B;&#x8FD8;&#x53CD;&#x5C04;&#x3002;&#x7684;&#x786E;&#xFF0C;&#x5982;&#x679C;&#x5728;&#x9879;&#x76EE;&#x521D;&#x671F;&#x5C31;&#x786E;&#x5B9A;&#x4E86;&#x8FD9;&#x4E2A;&#x9700;&#x6C42;&#x7684;&#x8BDD;&#xFF0C;&#x6211;&#x60F3;&#x5927;&#x90E8;&#x5206;&#x4EBA;&#x90FD;&#x4F1A;&#x60F3;&#x5230;&#x7528;&#x4EE3;&#x7406;&#x6A21;&#x5F0F;&#x6765;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x529F;&#x80FD;&#x3002;&#x4F46;&#x662F;&#x5982;&#x679C;&#x9879;&#x76EE;&#x5DF2;&#x7ECF;&#x7A33;&#x5B9A;&#x8FD0;&#x884C;&#x4E86;&#x4E00;&#x6BB5;&#x65F6;&#x95F4;&#x5462;&#xFF1F;&#x6211;&#x4EEC;&#x4E0D;&#x53EF;&#x80FD;&#x628A;&#x6BCF;&#x4E2A;&#x4E8B;&#x4EF6;&#x90FD;&#x91CD;&#x65B0;&#x66FF;&#x6362;&#x6210;&#x6211;&#x4EEC;&#x7684;&#x4EE3;&#x7406;&#x7C7B;&#x5427;&#xFF1F;&#x8FD9;&#x6837;&#x91CD;&#x590D;&#x7684;&#x5DE5;&#x4F5C;&#x592A;&#x6CA1;&#x6709;&#x6548;&#x7387;&#x4E86;&#xFF0C;&#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x52A0;&#x4EE3;&#x7406;&#x6280;&#x672F;&#x6765;&#x5B9E;&#x73B0;&#x8FD9;&#x4E2A;&#x529F;&#x80FD;&#x3002; 2.&#x53CD;&#x5C04;&#x548C;&#x4EE3;&#x7406; &#x53CD;&#x5C04;&#x673A;&#x5236;&#x662F;&#x5728;&#x8FD0;&#x884C;&#x72B6;&#x6001;&#x4E2D;&#xFF0C;&#x5BF9;&#x4E8E;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x7C7B;&#xFF0C;&#x90FD;&#x80FD;&#x591F;&#x77E5;&#x9053;&#x8FD9;&#x4E2A;&#x7C7B;&#x7684;&#x6240;&#x6709;&#x5C5E;&#x6027;&#x548C;&#x65B9;&#x6CD5;&#xFF1B;&#x5BF9;&#x4E8E;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#xFF0C;&#x90FD;&#x80FD;&#x591F;&#x8C03;&#x7528;&#x5B83;&#x7684;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x65B9;&#x6CD5;&#x548C;&#x5C5E;&#x6027;&#xFF1B; &#x5728;&#x8FD0;&#x884C;&#x65F6;&#x5224;&#x65AD;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x6240;&#x5C5E;&#x7684;&#x7C7B;&#xFF1B; &#x5728;&#x8FD0;&#x884C;&#x65F6;&#x6784;&#x9020;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x7C7B;&#x7684;&#x5BF9;&#x8C61;&#xFF1B; &#x5728;&#x8FD0;&#x884C;&#x65F6;&#x5224;&#x65AD;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x7C7B;&#x6240;&#x5177;&#x6709;&#x7684;&#x6210;&#x5458;&#x53D8;&#x91CF;&#x548C;&#x65B9;&#x6CD5;&#xFF1B; &#x5728;&#x8FD0;&#x884C;&#x65F6;&#x8C03;&#x7528;&#x4EFB;&#x610F;&#x4E00;&#x4E2A;&#x5BF9;&#x8C61;&#x7684;&#x65B9;&#x6CD5;&#xFF1B; &#x751F;&#x6210;&#x52A8;&#x6001;&#x4EE3;&#x7406;&#x3002; &#x4E0B;&#x9762;&#x901A;&#x8FC7;&#x4E00;&#x4E2A;&#x4F8B;&#x5B50;&#x6765;&#x8BB2;&#x89E3;&#x4E0B;&#x53CD;&#x5C04;&#x7684;&#x7528;&#x9014;&#x3002; 1234567891011121314151617181920212223242526272829303132333435363738package com.nick.model;//&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;&#x5B9E;&#x4F53;&#x7C7B;UserModelpublic class UserModel { private String userName; private String password; private UserInfoModel userInfoModel; public String getUserName() { return userName; } public void setUserName(String userName) { this.userName = userName; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public UserInfoModel getUserInfoModel() { return userInfoModel; } public void setUserInfoModel(UserInfoModel userInfoModel) { this.userInfoModel = userInfoModel; } @Override public String toString() { String result = &quot;userName = &quot; + userName + &quot; password = &quot; + password + &quot; &quot; + userInfoModel.toString(); return result; }} &#x53E6;&#x4E00;&#x4E2A;Model 123456789101112131415161718192021222324252627package com.nick.model;public class UserInfoModel { private int age; private String birth; public int getAge() { return age; } public void setAge(int age) { this.age = age; } public String getBirth() { return birth; } public void setBirth(String birth) { this.birth = birth; } @Override public String toString() { return &quot;age = &quot; + age + &quot; birth = &quot; + birth; }} 123456789101112131415161718192021222324252627282930public static void main(String[] args) { UserInfoModel userInfoModel = new UserInfoModel(); userInfoModel.setAge(10); userInfoModel.setBirth(&quot;2017-03-17 17:08:56&quot;); UserModel userModel = new UserModel(); userModel.setUserName(&quot;&#x5C0F;&#x7EA2;&quot;); userModel.setPassword(&quot;password&quot;); userModel.setUserInfoModel(userInfoModel); System.out.println(userModel.toString()); // &#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x4FEE;&#x6539;&#x5C5E;&#x6027; try { Class userModelRe = Class.forName(UserModel.class.getName()); Field userName = userModelRe.getDeclaredField(&quot;userName&quot;); userName.setAccessible(true);// setAccessible(true)&#x7684;&#x65B9;&#x5F0F;&#x5173;&#x95ED;&#x5B89;&#x5168;&#x68C0;&#x67E5;&#x5C31;&#x53EF;&#x4EE5;&#x8FBE;&#x5230;&#x63D0;&#x5347;&#x53CD;&#x5C04;&#x901F;&#x5EA6;&#x7684;&#x76EE;&#x7684; userName.set(userModel, &quot;&#x5C0F;&#x660E;&quot;); } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (SecurityException e) { e.printStackTrace(); } catch (IllegalArgumentException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } System.out.println(userModel.toString()); } &#x8FD0;&#x884C;&#x7ED3;&#x679C;&#x4E3A;&#xFF1A; &#x4EE3;&#x7406;&#x6A21;&#x5F0F;&#x7684;&#x8BDD;&#x5206;&#x4E3A;&#x52A8;&#x6001;&#x4EE3;&#x7406;&#x548C;&#x9759;&#x6001;&#x4EE3;&#x7406;&#xFF0C;&#x6211;&#x4EEC;&#x8FD9;&#x91CC;&#x4F7F;&#x7528;&#x5230;&#x4E86;&#x9759;&#x6001;&#x4EE3;&#x7406;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x505A;&#x8FC7;&#x591A;&#x8D58;&#x8FF0;&#x3002; 3. &#x51C6;&#x5907;&#x5DE5;&#x4F5C; &#x9996;&#x5148;&#x6211;&#x4EEC;&#x901A;&#x8FC7;&#x6E90;&#x7801;&#x6765;&#x770B;&#x6211;&#x4EEC;&#x7684;&#x70B9;&#x51FB;&#x4E8B;&#x4EF6;&#x662F;&#x5982;&#x4F55;&#x6267;&#x884C;&#x7684;&#xFF0C;&#x6211;&#x4EEC;&#x5148;&#x770B;setOnClickListener&#x600E;&#x4E48;&#x5B9E;&#x73B0;&#xFF1A;123456public void setOnClickListener(@Nullable OnClickListener l) { if (!isClickable()) { setClickable(true); } getListenerInfo().mOnClickListener = l;} &#x8FD9;&#x91CC;&#x5F88;&#x7B80;&#x5355;&#xFF0C;&#x5C31;&#x662F;&#x628A;&#x6211;&#x4EEC;&#x7684;OnClickListener&#x8D4B;&#x503C;&#x7ED9;listenerInfo&#x5BF9;&#x50CF;&#x7684;mOnClickListener&#x3002;&#x7B80;&#x5355;&#x8BF4;&#x4E0B;&#xFF0C;&#x8FD9;&#x91CC;&#x8FDB;&#x884C;&#x4E86; isClickable() &#x5224;&#x65AD;&#xFF0C;&#x5982;&#x679C;&#x4E0D;&#x53EF;&#x4EE5;&#x70B9;&#x51FB;&#xFF0C;&#x5C31;&#x8BBE;&#x7F6E;&#x4E3A;&#x53EF;&#x70B9;&#x51FB;&#x3002;&#x63A5;&#x7740;&#x6211;&#x4EEC;&#x770B;&#x4E0B;listenerInfo&#x53C8;&#x662F;&#x4EC0;&#x4E48;&#x9B3C;&#xFF1A; 123456789101112131415161718192021222324252627282930313233343536373839ListenerInfo getListenerInfo() { if (mListenerInfo != null) { return mListenerInfo; } mListenerInfo = new ListenerInfo(); return mListenerInfo;}static class ListenerInfo { protected OnFocusChangeListener mOnFocusChangeListener; private ArrayList&lt;OnLayoutChangeListener&gt; mOnLayoutChangeListeners; protected OnScrollChangeListener mOnScrollChangeListener; private CopyOnWriteArrayList&lt;OnAttachStateChangeListener&gt; mOnAttachStateChangeListeners; public OnClickListener mOnClickListener; protected OnLongClickListener mOnLongClickListener; protected OnContextClickListener mOnContextClickListener; protected OnCreateContextMenuListener mOnCreateContextMenuListener; private OnKeyListener mOnKeyListener; private OnTouchListener mOnTouchListener; private OnHoverListener mOnHoverListener; private OnGenericMotionListener mOnGenericMotionListener; private OnDragListener mOnDragListener; private OnSystemUiVisibilityChangeListener mOnSystemUiVisibilityChangeListener; OnApplyWindowInsetsListener mOnApplyWindowInsetsListener;} &#x901A;&#x8FC7;&#x6E90;&#x7801;&#x53EF;&#x4EE5;&#x770B;&#x5230;&#xFF0C;ListenerInfo&#x662F;&#x4E00;&#x4E9B;&#x4E8B;&#x4EF6;&#x76D1;&#x542C;&#x7684;&#x7C7B;&#x3002;&#x90A3;&#x6211;&#x4EEC;&#x7684;OnClick&#x53C8;&#x662F;&#x5728;&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x7684;&#x5462;&#xFF1F; 123456789101112131415161718192021private final class PerformClick implements Runnable { @Override public void run() { performClick(); }}public boolean performClick() { final boolean result; final ListenerInfo li = mListenerInfo; if (li != null &amp;&amp; li.mOnClickListener != null) { playSoundEffect(SoundEffectConstants.CLICK); li.mOnClickListener.onClick(this); result = true; } else { result = false; } sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED); return result;} &#x53EF;&#x4EE5;&#x770B;&#x5230;&#x662F;&#x7528;&#x8FC7;PerformClick&#x8FD9;&#x4E2A;&#x65B9;&#x6CD5;&#x53BB;&#x8C03;&#x7528;&#x7684;&#xFF0C;&#x90A3;&#x4E48;&#x95EE;&#x9898;&#x6765;&#x4E86;&#xFF0C;&#x8FD9;&#x4E2A;PerformClick&#x53C8;&#x5728;&#x54EA;&#x91CC;&#x8C03;&#x7528;&#x4E86;&#x5462;&#xFF1F;&#x8FD8;&#x662F;&#x7EE7;&#x7EED;&#x770B;&#x6E90;&#x7801;&#xFF1A; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public boolean onTouchEvent(MotionEvent event) { if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) { switch (action) { case MotionEvent.ACTION_UP: boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0; if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) { // take focus if we don&apos;t have it already and we should in // touch mode. boolean focusTaken = false; if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) { focusTaken = requestFocus(); } if (prepressed) { // The button is being released before we actually // showed it as pressed. Make it show the pressed // state now (before scheduling the click) to ensure // the user sees it. setPressed(true, x, y); } if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) { // This is a tap, so remove the longpress check removeLongPressCallback(); // Only perform take click actions if we were in the pressed state if (!focusTaken) { // Use a Runnable and post this rather than calling // performClick directly. This lets other visual state // of the view update before click actions start. if (mPerformClick == null) { mPerformClick = new PerformClick(); } if (!post(mPerformClick)) { performClick(); } } } if (mUnsetPressedState == null) { mUnsetPressedState = new UnsetPressedState(); } if (prepressed) { postDelayed(mUnsetPressedState, ViewConfiguration.getPressedStateDuration()); } else if (!post(mUnsetPressedState)) { // If the post failed, unpress right now mUnsetPressedState.run(); } removeTapCallback(); } mIgnoreNextUpEvent = false; break; ... ... } &#x4ECE;&#x4EE3;&#x7801;&#x91CC;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x5230;performClick&#x662F;&#x5728;onTouchEvent&#x4E2D;&#x7684;MotionEvent.ACTION_UP&#x8FDB;&#x884C;&#x5224;&#x65AD;&#x5E76;&#x6267;&#x884C;&#x3002;&#x597D;&#x50CF;&#x6709;&#x70B9;&#x626F;&#x8FDC;&#x4E86;&#xFF0C;&#x56DE;&#x8FC7;&#x5934;&#x6765;&#x6211;&#x4EEC;&#x770B;&#x4E0B;&#x5E94;&#x8BE5;&#x600E;&#x6837;&#x53BB;&#x53CD;&#x5C04;&#x83B7;&#x5F97;mListenerInfo&#x8FD9;&#x4E2A;&#x5C5E;&#x6027;&#xFF0C;&#x5E76;&#x4E14;&#x83B7;&#x5F97;mListenerInfo&#x4E2D;&#x7684;mOnClickListener,&#x7136;&#x540E;&#x5C06;&#x6211;&#x4EEC;&#x7684;&#x4EE3;&#x7406;&#x7C7B;&#x8D4B;&#x503C;&#x8FDB;&#x53BB;&#x3002; 4.&#x4EE3;&#x7801;&#x5B9E;&#x73B0; &#x539F;&#x7406;&#x4E0A;&#x9762;&#x6211;&#x4EEC;&#x90FD;&#x8BB2;&#x4E86;&#xFF0C;&#x4E0B;&#x9762;&#x5C31;&#x662F;&#x4EE3;&#x7801;&#x7684;&#x5B9E;&#x73B0;&#x90E8;&#x5206;&#xFF1A; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class HookUtils { private static final String VIEW_CLASS = &quot;android.view.View&quot;; /** * @param mActivity * @param onClickListener */ public static void hookListener(Activity mActivity, OnClickListener onClickListener) { if (mActivity != null) { View decorView = mActivity.getWindow().getDecorView(); getView(decorView, onClickListener); } } /** * &#x9012;&#x5F52;&#x8FDB;&#x884C;viewHook * @param view * @param onClickListener */ private static void getView(View view, OnClickListener onClickListener) { //&#x9012;&#x5F52;&#x904D;&#x5386;&#xFF0C;&#x5224;&#x65AD;&#x5F53;&#x524D;view&#x662F;&#x4E0D;&#x662F;ViewGroup&#xFF0C;&#x5982;&#x679C;&#x662F;&#x7EE7;&#x7EED;&#x904D;&#x5386;&#xFF0C;&#x77E5;&#x9053;&#x4E0D;&#x662F;&#x4E3A;&#x6B62; if (view instanceof ViewGroup) { for (int i = 0; i &lt; ((ViewGroup) view).getChildCount(); i++) { getView(((ViewGroup) view).getChildAt(i), onClickListener); } } viewHook(view, onClickListener); } /** * &#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x5C06;&#x6211;&#x4EEC;&#x7684;&#x4EE3;&#x7406;&#x7C7B;&#x66FF;&#x6362;&#x539F;&#x6765;&#x7684;onClickListener * * @param view * @param onClickListener */ private static void viewHook(View view, OnClickListener onClickListener) { try { Class viewClass = Class.forName(VIEW_CLASS);//&#x53CD;&#x5C04;&#x521B;&#x5EFA;View Field listenerInfoField = viewClass.getDeclaredField(&quot;mListenerInfo&quot;);//&#x83B7;&#x5F97;View&#x5C5E;&#x6027;mListenerInfo listenerInfoField.setAccessible(true); Object mListenerInfo = listenerInfoField.get(view);//ListenerInfo==&gt;&gt;View&#x5BF9;&#x8C61;&#x4E2D;&#x7684;mListenerInfo&#x7684;&#x5B9E;&#x4F8B; if (mListenerInfo != null) { Class listenerInfo2 = Class.forName(&quot;android.view.View$ListenerInfo&quot;);//&#x53CD;&#x5C04;&#x521B;&#x5EFA;ListenerInfo Field onClickListenerFiled = listenerInfo2.getDeclaredField(&quot;mOnClickListener&quot;);//&#x83B7;&#x5F97;ListenerInfo&#x5C5E;&#x6027;mOnClickListener onClickListenerFiled.setAccessible(true); View.OnClickListener o1 = (View.OnClickListener) onClickListenerFiled.get(mListenerInfo);//&#x83B7;&#x5F97;mListenerInfo&#x7684;&#x5B9E;&#x4F8B;&#x4E2D;&#x7684;mOnClickListener&#x5B9E;&#x4F8B; if (o1 != null) { View.OnClickListener onClickListenerProxy = new OnClickListenerProxy(o1, onClickListener); onClickListenerFiled.set(mListenerInfo, onClickListenerProxy);//&#x8BBE;&#x7F6E;ListenerInfo&#x5C5E;&#x6027;mOnClickListener&#x4E3A;&#x6211;&#x4EEC;&#x7684;&#x4EE3;&#x7406;listener } } } catch (ClassNotFoundException e) { e.printStackTrace(); } catch (NoSuchFieldException e) { e.printStackTrace(); } catch (IllegalAccessException e) { e.printStackTrace(); } } public interface OnClickListener { void beforeInListener(View v); void afterInListener(View v); } private static class OnClickListenerProxy implements View.OnClickListener { private View.OnClickListener object; private HookUtils.OnClickListener mListener; public OnClickListenerProxy(View.OnClickListener object, HookUtils.OnClickListener listener) { this.object = object; this.mListener = listener; } @Override public void onClick(View v) { if (mListener != null) { mListener.beforeInListener(v); } if (object != null) { object.onClick(v); } if (mListener != null) { mListener.afterInListener(v); } } } &#x4EE3;&#x7801;&#x91CC;&#x5DF2;&#x7ECF;&#x6709;&#x5F88;&#x8BE6;&#x7EC6;&#x7684;&#x6CE8;&#x91CA;&#x4E86;&#xFF0C;&#x8FD9;&#x91CC;&#x5927;&#x6982;&#x89E3;&#x91CA;&#x4E0B;&#xFF1A;&#x6211;&#x4EEC;&#x901A;&#x8FC7;&#x53CD;&#x5C04;&#x83B7;&#x5F97;&#x4E86;&#x5F53;&#x524D;View&#x7684;mListenerInfo&#x8FD9;&#x4E2A;&#x5C5E;&#x6027;&#xFF0C;&#x5982;&#x679C;mListenerInfo&#x4E0D;&#x4E3A;&#x7A7A;&#x7684;&#x65F6;&#x5019;,&#x6211;&#x4EEC;&#x83B7;&#x5F97;mListenerInfo&#x4E2D;&#x7684;mOnClickListener,&#x7136;&#x540E;&#x5C06;&#x6211;&#x4EEC;&#x7684;&#x4EE3;&#x7406;&#x7C7B;&#x8D4B;&#x503C;&#x8FDB;&#x53BB;&#x3002;&#x5F53;&#x8C03;&#x7528;onClick&#x65B9;&#x6CD5;&#x65F6;&#xFF0C;&#x4F1A;&#x5148;&#x8C03;&#x7528;&#x6211;&#x4EEC;&#x7684;beforeInListener&#x4E4B;&#x540E;&#x662F;onClick&#x65B9;&#x6CD5;&#xFF0C;&#x6700;&#x540E;&#x8C03;&#x7528;afterInListener&#x3002; 5.&#x6D4B;&#x8BD5;123456789101112131415161718192021222324252627282930@Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View view = findViewById(R.id.tv_1); view.setTag(&quot;1&quot;); view.setOnClickListener(this); View view1 = findViewById(R.id.tv_2); view1.setTag(&quot;2&quot;); view1.setOnClickListener(this); View view2 = findViewById(R.id.tv_3); view2.setTag(&quot;3&quot;); view2.setOnClickListener(this); HookUtils.hookListener(this, this);//&#x8981;&#x5728;setOnxxxListener&#x4E4B;&#x540E;&#x8C03;&#x7528; } @Override public void onClick(View v) { Log.d(&quot;fxxk&quot;, &quot;&#x70B9;&#x51FB;id=&quot; + v.getId() + &quot;v===&quot; + v.getTag().toString()); } @Override public void beforeInListener(View v) { Log.d(&quot;fxxk&quot;, &quot;&#x70B9;&#x51FB;&#x524D;id=&quot; + v.getId() + &quot;v===&quot; + v.getTag().toString()); } @Override public void afterInListener(View v) { Log.d(&quot;fxxk&quot;, &quot;&#x70B9;&#x51FB;&#x540E;id=&quot; + v.getId() + &quot;v===&quot; + v.getTag().toString()); } &#x6EE1;&#x6000;&#x671F;&#x5F85;&#x7684;&#x7ED3;&#x679C;&#xFF1A; 6. &#x5199;&#x5728;&#x6700;&#x540E; &#x8FD9;&#x4E2A;&#x4EE3;&#x7801;&#x867D;&#x7136;&#x6BD4;&#x8F83;&#x5C11;&#xFF0C;&#x4F46;&#x662F;&#x6211;&#x8FD9;&#x91CC;&#x53EA;&#x5B9E;&#x73B0;&#x4E86;&#x5BF9;OnclickListener&#x7684;&#x76D1;&#x542C;&#xFF0C;&#x6211;&#x5C06;&#x4EE3;&#x7801;&#x4E0A;&#x4F20;&#x5230;GitHub&#xFF0C;&#x5E0C;&#x671B;&#x6709;&#x65F6;&#x95F4;&#x80FD;&#x591F;&#x5C06;&#x5176;&#x4ED6;&#x4E8B;&#x4EF6;&#x7684;&#x76D1;&#x542C;&#x4E5F;&#x5B8C;&#x6210;&#x3002;&#x4E0B;&#x9762;&#x5E94;&#x8BE5;&#x662F;&#x5BF9;Looper&#x548C;Handler&#x8FDB;&#x884C;&#x5206;&#x6790;&#xFF0C;&#x62BD;&#x7A7A;&#x5199;&#x4E0B;&#x81EA;&#x5DF1;&#x7684;&#x7406;&#x89E3;&#x3002;","tags":[]},{"title":"Android NDK之增量更新","date":"2017-02-28T16:10:09.345Z","path":"2017/03/01/android-bsdiff1/","text":"1.&#x589E;&#x91CF;&#x66F4;&#x65B0;&#x4F7F;&#x7528;&#x5230;&#x7684;&#x5E93;bsdiff&#x548C;bzip2 bsdiff&#x5E93;&#x662F;&#x4E00;&#x4E2A;&#x5F00;&#x6E90;&#x7684;&#x4E8C;&#x8FDB;&#x5236;&#x5DEE;&#x5206;&#x5DE5;&#x5177;&#xFF0C;&#x901A;&#x8FC7;&#x5BF9;&#x6BD4;Apk&#x7684;&#x4E8C;&#x8FDB;&#x5236;&#xFF0C;&#x4ECE;&#x800C;&#x8FDB;&#x884C;&#x5DEE;&#x5206;&#x5305;&#x7684;&#x751F;&#x6210;&#x3002;bsdiff&#x5E93;&#x53EF;&#x4EE5;&#x53C2;&#x8003;&#x5B98;&#x7F51;&#xFF1A;bsdiff&#x4E0B;&#x8F7D;&#x5730;&#x5740;&#xFF1A;&#x5DF2;&#x7ECF;&#x5C06;&#x7528;&#x5230;&#x7684;bsdiff&#x548C;bzip&#x4E0A;&#x4F20;&#x5230;&#x767E;&#x5EA6;&#x4E91; &#x3002; 2.AS&#x521B;&#x5EFA;&#x9879;&#x76EE;&#xFF0C;&#x5E76;&#x5BFC;&#x5165;&#x5934;&#x6587;&#x4EF6; &#x672C;&#x9879;&#x76EE;&#x4F7F;&#x7528;Android Studio&#xFF0C;&#x901A;&#x8FC7;cmake&#x8FDB;&#x884C;&#x7F16;&#x8BD1;&#x3002;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x5DE5;&#x5177;&#x7C7B;&#xFF0C;&#x8FDB;&#x884C;&#x5DEE;&#x5206;&#x5305;&#x7684;&#x751F;&#x6210;&#x53CA;&#x5408;&#x5E76;Diffutils1234567891011121314151617181920212223 public class Diffutils { static { System.loadLibrary(&quot;native-lib&quot;); } /** * @param oldPath &#x65E7;&#x7684;&#x5B89;&#x88C5;&#x5305;&#x8DEF;&#x5F84; * @param newPath &#x65B0;&#x7684;&#x5B89;&#x88C5;&#x5305;&#x8DEF;&#x5F84; * @param patchPath &#x5DEE;&#x5206;&#x5305;&#x8DEF;&#x5F84; * @return &#x751F;&#x6210;&#x7684;&#x7ED3;&#x679C; */ public static native int generateDiffApk(String oldPath, String newPath, String patchPath); /** * @param oldPath &#x65E7;&#x7684;&#x5B89;&#x88C5;&#x5305;&#x8DEF;&#x5F84; * @param newPath &#x65B0;&#x7684;&#x5B89;&#x88C5;&#x5305;&#x8DEF;&#x5F84; * @param patchPath &#x5DEE;&#x5206;&#x5305;&#x8DEF;&#x5F84; * @return &#x751F;&#x6210;&#x7684;&#x7ED3;&#x679C; */ public static native int mergeDiffApk(String oldPath, String newPath, String patchPath);} &#x5BFC;&#x5165;bsdiff&#x548C;bzip2&#x7684;&#x5934;&#x6587;&#x4EF6;&#x4EE5;&#x53CA;.c&#x6587;&#x4EF6;&#x5C06;&#x751F;&#x6210;&#x7684;.cpp&#x6587;&#x4EF6;&#x6539;&#x6210;.c&#x6587;&#x4EF6;&#x3002;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4FEE;&#x6539;&#x6210;.c&#x6587;&#x4EF6;&#xFF1F;&#x4E3B;&#x8981;&#x662F;&#x56E0;&#x4E3A;c&#x548C;c++&#x5BF9;void malloc&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7F16;&#x8BD1;&#x4E0D;&#x540C;&#xFF0C;c&#x4E2D;&#x4E0D;&#x7528;&#x5C06;&#x7ED3;&#x679C;&#x5F3A;&#x5236;&#x8F6C;&#x6362;&#x6210;&#x7C7B;&#x578B; &#xFF0C;&#x800C;c++&#x5219;&#x4E0D;&#x540C;&#xFF0C;&#x5B83;&#x5FC5;&#x987B;&#x8981;&#x5C06;&#x7ED3;&#x679C;&#x5F3A;&#x5236;&#x8F6C;&#x6362;&#x6210;&#x7C7B;&#x578B;*&#x3002;&#x6211;&#x4EEC;&#x4F7F;&#x7528;&#x5230;&#x7684;bsdiff&#x5E93;&#x548C;bzip2&#x5E93;&#x597D;&#x591A;&#x5730;&#x65B9;&#x90FD;&#x4F7F;&#x7528;&#x4E86;malloc&#x51FD;&#x6570;&#xFF0C;&#x5982;&#x679C;&#x4F7F;&#x7528;c++&#x7F16;&#x8BD1;&#x4F1A;&#x62A5;&#x5927;&#x91CF;&#x7684;&#x9519;&#x8BEF;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x91C7;&#x7528;c&#x7F16;&#x8BD1;&#x3002;&#x4FEE;&#x6539;&#x4E86;cpp&#x6587;&#x4EF6;&#x6211;&#x4EEC;&#x4E0D;&#x8981;&#x5FD8;&#x8BB0;&#x5728;CMakeList&#x4E2D;&#x8FDB;&#x884C;&#x66F4;&#x65B0;&#x4EE5;&#x53CA;&#x5BFC;&#x5165;&#x65B0;&#x7684;&#x6587;&#x4EF6;CMakeList.txt1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# Sets the minimum version of CMake required to build the native# library. You should either keep the default value or only pass a# value of 3.4.0 or lower.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds it for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # Associated headers in the same location as their source # file are automatically included. src/main/cpp/native-lib.c )#include src/main/cpp/include&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x6240;&#x6709;&#x6587;&#x4EF6;include_directories(src/main/cpp/include)# Searches for a specified prebuilt library and stores the path as a# variable. Because system libraries are included in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in the# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. ${log-lib} ) 3. &#x5DEE;&#x5206;&#x65B9;&#x6CD5;&#x4EE5;&#x53CA;&#x5408;&#x5E76;&#x65B9;&#x6CD5;&#x7684;&#x5B9E;&#x73B0; &#x5DEE;&#x5206;&#x7684;&#x65B9;&#x6CD5;&#x5728;bsdiff.c&#x7684;main&#x51FD;&#x6570;&#x5DF2;&#x7ECF;&#x5B9E;&#x73B0;&#xFF0C;&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x4E3A;&#x4E86;&#x533A;&#x5206;&#x5DEE;&#x5206;&#x65B9;&#x6CD5;&#x548C;&#x5408;&#x5E76;&#x65B9;&#x6CD5;&#x6211;&#x5C06;main&#x51FD;&#x6570;&#x4FEE;&#x6539;&#x6210;generateDiffApk&#x3002;&#x540C;&#x7406;&#x5408;&#x5E76;&#x65B9;&#x6CD5;&#x5728;bspatch&#x4E2D;&#x5DF2;&#x7ECF;&#x5B9E;&#x73B0;&#xFF0C;&#x6211;&#x5C06;&#x5176;main&#x51FD;&#x6570;&#x4FEE;&#x6539;&#x6210;mergeDiffApknative-lib.c1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;jni.h&gt;#include &quot;include/bsdiff.c&quot;#include &quot;include/bspatch.c&quot;JNIEXPORT jint JNICALLJava_com_nick_bsdiff_Diffutils_generateDiffApk(JNIEnv *env, jclass type, jstring oldPath_, jstring newPath_, jstring patchPath_) { int argc = 4; char *argv[argc]; argv[0] = (char *) &quot;bspatch&quot;; argv[1] = (char *) (*env)-&gt;GetStringUTFChars(env, oldPath_, 0); argv[2] = (char *) (*env)-&gt;GetStringUTFChars(env, newPath_, 0); argv[3] = (char *) (*env)-&gt;GetStringUTFChars(env, patchPath_, 0); jint result = generateDiffApk(argc, argv); (*env)-&gt;ReleaseStringUTFChars(env, oldPath_, argv[1]); (*env)-&gt;ReleaseStringUTFChars(env, newPath_, argv[2]); (*env)-&gt;ReleaseStringUTFChars(env, patchPath_, argv[3]); return result;}JNIEXPORT jint JNICALLJava_com_nick_bsdiff_Diffutils_mergeDiffApk(JNIEnv *env, jclass type, jstring oldPath_, jstring newPath_, jstring patchPath_) { int argc = 4; char *argv[argc]; argv[0] = (char *) &quot;bspatch&quot;; argv[1] = (char *) (*env)-&gt;GetStringUTFChars(env, oldPath_, 0); argv[2] = (char *) (*env)-&gt;GetStringUTFChars(env, newPath_, 0); argv[3] = (char *) (*env)-&gt;GetStringUTFChars(env, patchPath_, 0); printf(&quot;old apk = %s \\n&quot;, argv[1]); printf(&quot;patch = %s \\n&quot;, argv[3]); printf(&quot;new apk = %s \\n&quot;, argv[2]); jint result = mergeDiffApk(argc, argv); (*env)-&gt;ReleaseStringUTFChars(env, oldPath_, argv[1]); (*env)-&gt;ReleaseStringUTFChars(env, newPath_, argv[2]); (*env)-&gt;ReleaseStringUTFChars(env, patchPath_, argv[3]); return result;} 4.&#x6548;&#x679C;&#x5C55;&#x793A; &#x65E7;&#x7248;&#x672C;&#xFF1A;&#x751F;&#x6210;&#x7684;&#x5DEE;&#x5206;&#x5305;&#xFF08;app3.patch&#xFF09;: &#x5408;&#x5E76;&#x540E;&#x7684;&#x65B0;&#x7684;&#x5B89;&#x88C5;&#x5305;&#xFF08;app1&#xFF09;&#xFF1A;&#x5B89;&#x88C5;&#x540E;&#xFF1A; 5.&#x9879;&#x76EE;&#x5730;&#x5740; &#x6211;&#x5C06;&#x5B8C;&#x6574;&#x9879;&#x76EE;&#x4E0A;&#x4F20;&#x5230;&#x4E86;GitHub&#x4E0A;&#xFF0C;&#x6709;&#x5174;&#x8DA3;&#x7684;&#x53EF;&#x4EE5;&#x70B9;&#x51FB;&#x8FD9;&#x91CC;&#x8FDB;&#x5165;&#x3002;","tags":[]},{"title":"Android 调用jepg库进行图片压缩，保持图片不失真","date":"2017-02-25T14:36:06.541Z","path":"2017/02/25/android-jpeg/","text":"1.&#x6D45;&#x8C08;&#x4E3A;&#x4EC0;&#x4E48;Android&#x548C;iOS&#x56FE;&#x7247;&#x8D28;&#x91CF;&#x5DEE;&#x8DDD;&#x90A3;&#x4E48;&#x5927;&#xFF1F; &#x9996;&#x5148;&#x6765;&#x8BF4;&#xFF0C;&#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x5B89;&#x5353;&#x72D7;&#xFF0C;&#x673A;&#x5668;&#x5F53;&#x7136;&#x7528;&#x7684;&#x662F;&#x5B89;&#x5353;&#x7684;&#x624B;&#x673A;&#x3002;&#x73B0;&#x5728;&#x7684;&#x5B89;&#x5353;&#x624B;&#x673A;&#x5927;&#x591A;&#x6570;&#x90FD;&#x4F1A;&#x4EE5;&#x9AD8;&#x6E05;&#x62CD;&#x7167;&#xFF0C;&#x52A8;&#x4E0D;&#x52A8;&#x5C31;&#x51E0;&#x5343;&#x4E07;&#x67D4;&#x5149;&#x76F8;&#x673A;&#x6765;&#x5438;&#x5F15;&#x5404;&#x79CD;&#x4E70;&#x5BB6;&#x3002;&#x4E70;&#x6765;&#x540E;&#xFF0C;&#x62CD;&#x7167;&#x53D1;&#x73B0;&#xFF0C;&#x54C7;&#x585E;&#x2014;&#x2014;&#x4E00;&#x5F20;&#x56FE;&#x7247;&#x597D;&#x51E0;M&#x5462;&#xFF0C;&#x4F46;&#x662F;&#x8FD8;&#x662F;&#x4E0D;&#x5982;iOS&#x7684;&#x611F;&#x89C9;&#xFF0C;iOS&#x7684;&#x56FE;&#x7247;&#x4E5F;&#x5C31;1M&#x5DE6;&#x53F3;&#x5427;&#x3002;&#x4E3A;&#x4EC0;&#x4E48;&#x4F1A;&#x6709;&#x8FD9;&#x4E48;&#x5927;&#x7684;&#x5DEE;&#x8DDD;&#x5462;&#xFF1F;&#x8FD9;&#x8981;&#x4ECE;&#x5B89;&#x5353;&#x7684;&#x8BBE;&#x8BA1;&#x521D;&#x8877;&#x6765;&#x8BF4;&#x8D77;&#xFF0C;&#x5F53;&#x65F6;&#x8C37;&#x6B4C;&#x5F00;&#x53D1;Android&#x7684;&#x65F6;&#x5019;&#xFF0C;&#x8003;&#x8651;&#x4E86;&#x5927;&#x90E8;&#x5206;&#x624B;&#x673A;&#x7684;&#x914D;&#x7F6E;&#x5E76;&#x6CA1;&#x6709;&#x90A3;&#x4E48;&#x9AD8;&#xFF0C;&#x6240;&#x4EE5;&#x5BF9;&#x56FE;&#x7247;&#x5904;&#x7406;&#x662F;&#x4F7F;&#x7528;&#x7684;Skia&#x8FD9;&#x4E2A;&#x5E93;&#x3002;&#x5F53;&#x7136;&#x8FD9;&#x4E2A;&#x5E93;&#x7684;&#x5E95;&#x5C42;&#x8FD8;&#x662F;&#x662F;&#x7528;&#x7684;jpeg&#x5BF9;&#x56FE;&#x7247;&#x8FDB;&#x884C;&#x538B;&#x7F29;&#x5904;&#x7406;&#x3002;&#x4F46;&#x662F;&#x4E3A;&#x4E86;&#x80FD;&#x591F;&#x9002;&#x914D;&#x4F4E;&#x7AEF;&#x7684;&#x624B;&#x673A;&#xFF08;&#x8FD9;&#x91CC;&#x7684;&#x4F4E;&#x7AEF;&#x662F;&#x6307;&#x4EE5;&#x524D;&#x7684;&#x786C;&#x4EF6;&#x914D;&#x7F6E;&#x4E0D;&#x9AD8;&#x7684;&#x624B;&#x673A;&#xFF09;&#xFF0C;&#x6240;&#x4EE5;Skia&#x5728;&#x8FDB;&#x884C;&#x56FE;&#x7247;&#x5904;&#x7406;&#x5E76;&#x6CA1;&#x6709;&#x53BB;&#x4F7F;&#x7528;&#x538B;&#x7F29;&#x56FE;&#x50CF;&#x8FC7;&#x7A0B;&#x4E2D;&#x57FA;&#x4E8E;&#x56FE;&#x50CF;&#x6570;&#x636E;&#x8BA1;&#x7B97;&#x54C8;&#x5F17;&#x66FC;&#x8868;&#xFF08;&#x5173;&#x4E8E;&#x56FE;&#x7247;&#x538B;&#x7F29;&#x4E2D;&#x7684;&#x54C8;&#x5F17;&#x66FC;&#x8868;&#xFF0C;&#x8BF7;&#x81EA;&#x884C;&#x67E5;&#x9605;&#x76F8;&#x5173;&#x8D44;&#x6599;&#xFF09;&#xFF0C;&#x53EF;&#x4EE5;&#x53C2;&#x8003;&#x8FD9;&#x91CC;&#x3002;&#x8FD9;&#x91CC;&#x9762;&#x8BE6;&#x7EC6;&#x89E3;&#x91CA;&#x4E3A;&#x4F55;Google&#x6CA1;&#x6709;&#x4F7F;&#x7528;&#x9AD8;&#x6027;&#x80FD;&#x7684;&#x538B;&#x7F29;&#xFF0C;&#x7B80;&#x5355;&#x6765;&#x8BF4;&#x5C31;&#x662F;&#x8003;&#x8651;&#x4E86;&#x5F53;&#x65F6;&#x7684;&#x624B;&#x673A;&#x786C;&#x4EF6;&#xFF0C;&#x5C06;&#x4E00;&#x4E2A;&#x538B;&#x7F29;&#x53C2;&#x6570;optimize_coding&#x8BBE;&#x7F6E;&#x4E3A;&#x4E86;false&#xFF0C;&#x4F7F;&#x5F97;&#x786C;&#x4EF6;&#x8F83;&#x4F4E;&#x7684;&#x624B;&#x673A;&#x80FD;&#x591F;&#x5F88;&#x597D;&#x7684;&#x5904;&#x7406;&#x56FE;&#x7247;&#x3002; 2. NDK&#x73AF;&#x5883;&#x4EE5;&#x53CA;Cmake&#x914D;&#x7F6E;&#xFF08;&#x7BC7;&#x5E45;&#x6709;&#x9650;&#x8FD9;&#x91CC;&#x4E0D;&#x505A;&#x8FC7;&#x591A;&#x7684;&#x63CF;&#x8FF0;&#xFF09; &#x6DFB;&#x52A0;&#x73AF;&#x5883;&#x53D8;&#x91CF; &#xFF0C;&#x5C06;&#x914D;&#x7F6E;&#x7684;&#x73AF;&#x5883;&#x53D8;&#x91CF;&#x6DFB;&#x52A0;&#x5230;&#x7CFB;&#x7EDF;&#x73AF;&#x5883;&#x53D8;&#x91CF;&#x4E2D;&#x3002;&#x628A;%NDK_HOME%;&#x6DFB;&#x52A0;&#x5230;Path&#x4E2D;&#x3002; 3. jpeg&#x5E93;&#x7684;&#x4E0B;&#x8F7D;&#x53CA;&#x7F16;&#x8BD1;.so&#x6587;&#x4EF6; &#x4E0B;&#x8F7D;libjpeg&#x5E93;&#x6E90;&#x7801;&#xFF0C;git clone&#x5730;&#x5740;1git clone git://git.linaro.org/people/tomgall/libjpeg-turbo/libjpeg-turbo.git -b linaro-android &#x5C06;clone&#x4E0B;&#x6765;&#x7684;&#x6E90;&#x7801;&#x76EE;&#x5F55;&#x6539;&#x4E3A;jni&#xFF08;&#x5373;&#x6E90;&#x76EE;&#x5F55;libjpeg-turbo&#x6539;&#x4E3A;jni&#xFF09;&#xFF0C;&#x901A;&#x8FC7;ndk&#x547D;&#x4EE4;&#x8FDB;&#x884C;&#x7F16;&#x8BD1;&#xFF08;&#x9700;&#x8981;&#x914D;&#x597D;ndk&#x73AF;&#x5883;&#x53D8;&#x91CF;&#xFF0C;&#x547D;&#x4EE4;&#x884C;&#x8FDB;&#x5165;&#x4FEE;&#x6539;&#x597D;&#x7684;jni&#x76EE;&#x5F55;&#x8F93;&#x5165;&#x547D;&#x4EE4;&#x5373;&#x53EF;&#xFF09;&#xFF1A;1ndk-build APP_ABI=armeabi-v7a,armeabi &#x5728;&#x5F53;&#x524D;&#x76EE;&#x5F55;&#x4E0B;&#x751F;&#x6210;libs&#x548C;obj&#x6587;&#x4EF6;&#x5939;&#x3002;libjpeg.so&#x5C31;&#x662F;&#x6211;&#x4EEC;&#x6240;&#x9700;&#x8981;&#x7684;&#x6587;&#x4EF6;&#x3002; 4.&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;Android&#x9879;&#x76EE; &#x65B0;&#x5EFA;&#x4E00;&#x4E2A;Android&#x9879;&#x76EE;&#xFF0C;&#x5E76;&#x52FE;&#x9009;c++support&#x3002;&#x5982;&#x679C;&#x73AF;&#x5883;&#x914D;&#x7F6E;&#x597D;&#x7684;&#x8BDD;&#xFF0C;AS&#x4F1A;&#x81EA;&#x52A8;&#x751F;&#x6210;&#x4E00;&#x4E2A;&#x5305;&#x542B;NDK&#x7684;&#x9879;&#x76EE;&#xFF0C;&#x91CC;&#x9762;&#x5B9E;&#x73B0;&#x4E86;hello world&#x3002;&#x76EE;&#x5F55;&#x7ED3;&#x6784;&#x5982;&#x4E0B;&#x56FE;&#xFF1A;&#x65B0;&#x5EFA;&#x4E00;&#x4E2A;&#x7C7B;&#xFF0C;JpegUtils&#xFF0C;&#x58F0;&#x660E;native&#x65B9;&#x6CD5;1234567public class JpegUtils { static { System.loadLibrary(&quot;native-lib&quot;); } public static native boolean compressBitmap(Bitmap bitmap, int width, int height, String fileName, int quality);} &#x5728;&#x65B0;&#x5EFA;&#x7684;&#x65B9;&#x6CD5;&#x4E0A;&#x76F4;&#x63A5;&#x751F;&#x6210;c++&#x65B9;&#x6CD5;&#x3002;&#x628A;&#x521A;&#x624D;jpeg&#x5E93;&#x7684;&#x5934;&#x6587;&#x4EF6;&#x5BFC;&#x5165;&#x5230;cpp\\include&#x76EE;&#x5F55;&#x4E0B;&#x3002;&#x6211;&#x53EA;&#x4FDD;&#x7559;&#x4E86;android&#x4E0B;&#x9762;&#x7684;&#x5934;&#x6587;&#x4EF6;&#x548C;&#x5176;&#x4ED6;&#x7684;.h&#x4EE5;&#x53CA;.c&#x6587;&#x4EF6;&#xFF0C;&#x5176;&#x5B9E;&#x8FD9;&#x91CC;&#x9762;&#x6709;&#x65E0;&#x7528;&#x7684;&#xFF0C;&#x4F46;&#x662F;&#x5177;&#x4F53;&#x4E0D;&#x6E05;&#x695A;&#xFF0C;&#x6240;&#x4EE5;&#x76F4;&#x63A5;&#x5BFC;&#x5165;&#x4E86;&#x3002; jpeg&#x538B;&#x7F29;&#x7684;&#x6B65;&#x9AA4;1&#x3001;&#x5C06;Android&#x7684;bitmap&#x89E3;&#x7801;&#x5E76;&#x8F6C;&#x6362;&#x4E3A;RGB&#x6570;&#x636E;2&#x3001;&#x4E3A;JPEG&#x5BF9;&#x8C61;&#x5206;&#x914D;&#x7A7A;&#x95F4;&#x5E76;&#x521D;&#x59CB;&#x5316;3&#x3001;&#x6307;&#x5B9A;&#x538B;&#x7F29;&#x6570;&#x636E;&#x6E90;4&#x3001;&#x83B7;&#x53D6;&#x6587;&#x4EF6;&#x4FE1;&#x606F;5&#x3001;&#x4E3A;&#x538B;&#x7F29;&#x8BBE;&#x5B9A;&#x53C2;&#x6570;&#xFF0C;&#x5305;&#x62EC;&#x56FE;&#x50CF;&#x5927;&#x5C0F;&#xFF0C;&#x989C;&#x8272;&#x7A7A;&#x95F4;6&#x3001;&#x5F00;&#x59CB;&#x538B;&#x7F29;7&#x3001;&#x538B;&#x7F29;&#x5B8C;&#x6BD5;8&#x3001;&#x91CA;&#x653E;&#x8D44;&#x6E90;&#x5728;native-lib&#x6587;&#x4EF6;&#x4E2D;&#x8FDB;&#x884C;&#x4EE3;&#x7801;&#x7F16;&#x5199;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111extern &quot;C&quot;JNIEXPORT jboolean JNICALLJava_com_nick_compress_JpegUtils_compressBitmap(JNIEnv *env, jclass type, jobject bitmap, jint width, jint height, jstring fileName, jint quality) { AndroidBitmapInfo infoColor; BYTE *pixelColor; BYTE *data; BYTE *tempData; const char *filename = env-&gt;GetStringUTFChars(fileName, 0); if ((AndroidBitmap_getInfo(env, bitmap, &amp;infoColor)) &lt; 0) { LOGE(&quot;&#x89E3;&#x6790;&#x9519;&#x8BEF;&quot;); return false; } if ((AndroidBitmap_lockPixels(env, bitmap, (void **) &amp;pixelColor)) &lt; 0) { LOGE(&quot;&#x52A0;&#x8F7D;&#x5931;&#x8D25;&quot;); return false; } BYTE r, g, b; int color; data = (BYTE *) malloc(width * height * 3); tempData = data; for (int i = 0; i &lt; height; i++) { for (int j = 0; j &lt; width; j++) { color = *((int *) pixelColor); r = ((color &amp; 0x00FF0000) &gt;&gt; 16);//&#x4E0E;&#x64CD;&#x4F5C;&#x83B7;&#x5F97;rgb&#xFF0C;&#x53C2;&#x8003;java Color&#x5B9A;&#x4E49;alpha color &gt;&gt;&gt; 24 red (color &gt;&gt; 16) &amp; 0xFF g = ((color &amp; 0x0000FF00) &gt;&gt; 8); b = color &amp; 0X000000FF; *data = b; *(data + 1) = g; *(data + 2) = r; data += 3; pixelColor += 4; } } AndroidBitmap_unlockPixels(env, bitmap); int resultCode = generateJPEG(tempData, width, height, quality, filename, true); free(tempData); if (resultCode == 0) { return false; } return true;}extern &quot;C&quot;//&#x56FE;&#x7247;&#x538B;&#x7F29;&#x65B9;&#x6CD5;int generateJPEG(BYTE *data, int w, int h, int quality, const char *outfilename, jboolean optimize) { int nComponent = 3; struct jpeg_compress_struct jcs; struct jpeg_error_mgr jem; jcs.err = jpeg_std_error(&amp;jem); //&#x4E3A;JPEG&#x5BF9;&#x8C61;&#x5206;&#x914D;&#x7A7A;&#x95F4;&#x5E76;&#x521D;&#x59CB;&#x5316; jpeg_create_compress(&amp;jcs); //&#x83B7;&#x53D6;&#x6587;&#x4EF6;&#x4FE1;&#x606F; FILE *f = fopen(outfilename, &quot;wb&quot;); if (f == NULL) { return 0; } //&#x6307;&#x5B9A;&#x538B;&#x7F29;&#x6570;&#x636E;&#x6E90; jpeg_stdio_dest(&amp;jcs, f); jcs.image_width = w;//image_width-&gt;JDIMENSION-&gt;typedef unsigned int jcs.image_height = h; jcs.arith_code = false; //input_components&#x4E3A;1&#x4EE3;&#x8868;&#x7070;&#x5EA6;&#x56FE;&#xFF0C;&#x5728;&#x7B49;&#x4E8E;3&#x65F6;&#x4EE3;&#x8868;&#x5F69;&#x8272;&#x4F4D;&#x56FE;&#x56FE;&#x50CF; jcs.input_components = nComponent; if (nComponent == 1) //in_color_space&#x4E3A;JCS_GRAYSCALE&#x8868;&#x793A;&#x7070;&#x5EA6;&#x56FE;&#xFF0C;&#x5728;&#x7B49;&#x4E8E;JCS_RGB&#x65F6;&#x4EE3;&#x8868;&#x5F69;&#x8272;&#x4F4D;&#x56FE;&#x56FE;&#x50CF; jcs.in_color_space = JCS_GRAYSCALE; else jcs.in_color_space = JCS_RGB; jpeg_set_defaults(&amp;jcs); //optimize_coding&#x4E3A;TRUE&#xFF0C;&#x5C06;&#x4F1A;&#x4F7F;&#x5F97;&#x538B;&#x7F29;&#x56FE;&#x50CF;&#x8FC7;&#x7A0B;&#x4E2D;&#x57FA;&#x4E8E;&#x56FE;&#x50CF;&#x6570;&#x636E;&#x8BA1;&#x7B97;&#x54C8;&#x5F17;&#x66FC;&#x8868;&#xFF0C;&#x7531;&#x4E8E;&#x8FD9;&#x4E2A;&#x8BA1;&#x7B97;&#x4F1A;&#x663E;&#x8457;&#x6D88;&#x8017;&#x7A7A;&#x95F4;&#x548C;&#x65F6;&#x95F4;&#xFF0C;&#x9ED8;&#x8BA4;&#x503C;&#x88AB;&#x8BBE;&#x7F6E;&#x4E3A;FALSE&#x3002; jcs.optimize_coding = optimize; //&#x4E3A;&#x538B;&#x7F29;&#x8BBE;&#x5B9A;&#x53C2;&#x6570;&#xFF0C;&#x5305;&#x62EC;&#x56FE;&#x50CF;&#x5927;&#x5C0F;&#xFF0C;&#x989C;&#x8272;&#x7A7A;&#x95F4; jpeg_set_quality(&amp;jcs, quality, true); //&#x5F00;&#x59CB;&#x538B;&#x7F29; jpeg_start_compress(&amp;jcs, TRUE); JSAMPROW row_pointer[1];//JSAMPROW&#x5C31;&#x662F;&#x4E00;&#x4E2A;&#x5B57;&#x7B26;&#x578B;&#x6307;&#x9488; &#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x53D8;&#x91CF;&#x5C31;&#x7B49;&#x4EF7;&#x4E8E;=========unsigned char *temp int row_stride; row_stride = jcs.image_width * nComponent; while (jcs.next_scanline &lt; jcs.image_height) { row_pointer[0] = &amp;data[jcs.next_scanline * row_stride]; //&#x5199;&#x5165;&#x6570;&#x636E; http://www.cnblogs.com/darkknightzh/p/4973828.html jpeg_write_scanlines(&amp;jcs, row_pointer, 1); } //&#x538B;&#x7F29;&#x5B8C;&#x6BD5; jpeg_finish_compress(&amp;jcs); //&#x91CA;&#x653E;&#x8D44;&#x6E90; jpeg_destroy_compress(&amp;jcs); fclose(f); return 1;} &#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x6BD4;&#x8F83;&#x591A;&#xFF0C;&#x4F46;&#x662F;&#x8FD9;&#x662F;&#x5F88;&#x5E38;&#x7528;&#x7684;jpeg&#x5E93;&#x7684;&#x4F7F;&#x7528;&#xFF0C;&#x7F51;&#x4E0A;&#x89E3;&#x91CA;&#x6BD4;&#x8F83;&#x591A;&#xFF0C;&#x6211;&#x8FD9;&#x91CC;&#x4E5F;&#x8FDB;&#x884C;&#x4E86;&#x8F83;&#x8BE6;&#x7EC6;&#x7684;&#x6CE8;&#x91CA;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x8FC7;&#x591A;&#x7684;&#x63CF;&#x8FF0;&#x3002;OK&#xFF0C;&#x4EE3;&#x7801;&#x7684;&#x7F16;&#x5199;&#x5C31;&#x5230;&#x8FD9;&#x91CC;&#xFF0C;&#x70B9;&#x51FB;&#x8FD0;&#x884C;&#x3002;&#x2014;&#x2014;&#x5D29;&#x6492;&#x5361;&#x62C9;&#x5361;&#xFF0C;&#x679C;&#x7136;&#x6CA1;&#x80FD;&#x8FD0;&#x884C;&#x6210;&#x529F;&#x3002;&#x663E;&#x793A;&#x597D;&#x591A;undifined reference&#xFF0C;&#x719F;&#x6089;NDK&#x7684;&#x90FD;&#x77E5;&#x9053;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x5728;mk&#x6587;&#x4EF6;&#x4E2D;&#x53BB;&#x5B9A;&#x4E49;&#x8FD9;&#x4E9B;&#x4F7F;&#x7528;&#x5230;&#x7684;&#x5934;&#x6587;&#x4EF6;&#xFF0C;&#x4F46;&#x662F;&#x6211;&#x4EEC;&#x9879;&#x76EE;&#x662F;&#x4F7F;&#x7528;&#x7684;Cmake&#x5DE5;&#x5177;&#x8FDB;&#x884C;&#x7F16;&#x8BD1;&#xFF0C;&#x6240;&#x4EE5;&#x9700;&#x8981;&#x5728;CMakelist.txt&#x4E2D;&#x53BB;&#x5B9A;&#x4E49;&#x6211;&#x4EEC;&#x7528;&#x5230;&#x7684;&#x5E93;&#x53CA;&#x5934;&#x6587;&#x4EF6;CMakelist.txt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# Sets the minimum version of CMake required to build the native# library. You should either keep the default value or only pass a# value of 3.4.0 or lower.cmake_minimum_required(VERSION 3.4.1)# Creates and names a library, sets it as either STATIC# or SHARED, and provides the relative paths to its source code.# You can define multiple libraries, and CMake builds it for you.# Gradle automatically packages shared libraries with your APK.add_library( # Sets the name of the library. native-lib # Sets the library as a shared library. SHARED # Provides a relative path to your source file(s). # Associated headers in the same location as their source # file are automatically included. src/main/cpp/native-lib.cpp )#include &#x8FD9;&#x4E2A;&#x76EE;&#x5F55;&#x4E0B;&#x6240;&#x6709;&#x7684;&#x6587;&#x4EF6;include_directories(src/main/cpp/include)#&#x5916;&#x90E8;&#x5BFC;&#x5165;jpeg&#x8FD9;&#x4E2A;&#x5E93;add_library(jpeg SHARED IMPORTED )#&#x8FD9;&#x53E5;&#x8BDD;&#x662F;jpeg&#x5BF9;&#x5E94;&#x7684;so&#x6587;&#x4EF6;,so&#x6587;&#x4EF6;&#x662F;&#x653E;&#x5230;ibs&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x5939;&#x4E2D;(&#x76F8;&#x5BF9;&#x4E0E;cpp&#x8FD9;&#x4E2A;&#x6587;&#x4EF6;&#x7684;&#x4F4D;&#x7F6E;)set_target_properties(jpeg PROPERTIES IMPORTED_LOCATION ../../../../libs/armeabi/libjpeg.so)# Searches for a specified prebuilt library and stores the path as a# variable. Because system libraries are included in the search path by# default, you only need to specify the name of the public NDK library# you want to add. CMake verifies that the library exists before# completing its build.find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log )# Specifies libraries CMake should link to your target library. You# can link multiple libraries, such as libraries you define in the# build script, prebuilt third-party libraries, or system libraries.target_link_libraries( # Specifies the target library. native-lib # Links the target library to the log library # included in the NDK. jpeg #jnigraphics&#x8FD9;&#x4E2A;&#x662F;android&#x4E0B;&#x9762;&#x7684;bitmap.h&#x5BF9;&#x5E94;&#x7684;&#x5E93; jnigraphics ${log-lib}) &#x7528;AS&#x53BB;&#x5F00;&#x53D1;NDK&#x6700;&#x96BE;&#x7684;&#x5730;&#x65B9;&#x5E76;&#x4E0D;&#x662F;&#x4EC0;&#x4E48;&#x4EE3;&#x7801;&#xFF0C;&#x800C;&#x662F;&#x8FD9;&#x4E2A;CMakelist&#x6587;&#x4EF6;&#x3002;&#x5988;&#x86CB;&#x60F3;&#x60F3;&#x6211;&#x7F51;&#x4E0A;&#x627E;&#x4E86;n&#x4E45;&#xFF0C;&#x771F;&#x7684;&#x8D44;&#x6599;&#x592A;&#x5C11;&#x4E86;&#x3002;NND&#xFF01;&#x6709;&#x4E86;&#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x5C31;&#x53EF;&#x4EE5;&#x6210;&#x529F;&#x7684;&#x8FD0;&#x884C;&#x4E86;&#xFF0C;&#x6211;&#x628A;&#x4EE3;&#x7801;&#x653E;&#x5230;&#x4E86;Github&#x4E0A;&#xFF0C;&#x9700;&#x8981;&#x7684;&#x53EF;&#x4EE5;&#x4E0B;&#x4E0B;&#x6765;&#x770B;&#x770B;&#x3002; 5.&#x6700;&#x7EC8;&#x6548;&#x679C; &#x539F;&#x56FE;&#x548C;&#x8BE6;&#x60C5;&#xFF1A; &#x538B;&#x7F29;&#x540E;&#x7684;&#x56FE;&#x7247;&#x548C;&#x8BE6;&#x60C5;&#xFF1A;","tags":[]},{"title":"Android mvp以及Rxjava和Retrofit框架的搭建","date":"2017-02-21T16:40:13.397Z","path":"2017/02/22/mvp/","text":"1. &#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4F7F;&#x7528;mvp&#xFF1F; &#x5728;&#x4F20;&#x7EDF;&#x7684;MVC&#x7684;&#x67B6;&#x6784;&#x4E2D;&#xFF0C;&#x6211;&#x4EEC;&#x6240;&#x4F7F;&#x7528;&#x7684;View&#x901A;&#x5E38;&#x6307;&#x7684;&#x662F;View&#xFF08;layout&#x5E03;&#x5C40;&#xFF09;&#xFF0C;Controller&#x5219;&#x4E3A;Activity&#x3002;&#x4F46;&#x662F;Activity&#x4F5C;&#x4E3A;&#x4E0E;&#x7528;&#x6237;&#x4EA4;&#x4E92;&#x7684;&#x754C;&#x9762;&#x5C55;&#x793A;&#xFF0C;Controller&#x548C;View&#x76F8;&#x4E92;&#x8026;&#x5408;&#xFF0C;&#x4F7F;&#x5F97;&#x4EE3;&#x7801;&#x770B;&#x8D77;&#x6765;&#x5C42;&#x6B21;&#x5E76;&#x6CA1;&#x6709;&#x90A3;&#x4E48;&#x5206;&#x660E;&#x3002;&#x800C;MVP&#x6A21;&#x5F0F;&#x53EF;&#x4EE5;&#x8BA9;&#x663E;&#x793A;&#x754C;&#x9762;&#x548C;&#x6570;&#x636E;&#x5206;&#x79BB;&#xFF0C;&#x5F00;&#x53D1;&#x7684;&#x5E94;&#x7528;&#x53EF;&#x4EE5;&#x5206;&#x79BB;&#x81F3;&#x5C11;&#x4E09;&#x5C42;&#xFF0C;&#x8FD9;&#x6837;&#x4E5F;&#x53EF;&#x4EE5;&#x8FDB;&#x884C;&#x72EC;&#x7ACB;&#x6D4B;&#x8BD5;&#x3002;&#x6709;&#x4E86;MVP&#x5C31;&#x53EF;&#x4EE5;&#x4ECE;Activity&#x4E2D;&#x5206;&#x79BB;&#x5927;&#x90E8;&#x5206;&#x4EE3;&#x7801;&#xFF0C;&#x800C;&#x4E14;&#x4E0D;&#x7528;&#x5355;&#x5143;&#x6D4B;&#x8BD5;&#x53EF;&#x4EE5;&#x5BF9;&#x6BCF;&#x4E2A;&#x6A21;&#x5757;&#x8FDB;&#x884C;&#x5355;&#x72EC;&#x6D4B;&#x8BD5;&#x4E86;&#x3002; 2. &#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4F7F;&#x7528;Rxjava&#xFF1F; &#x5173;&#x4E8E;&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4F7F;&#x7528;Rxjava&#xFF0C;&#x8BB8;&#x591A;&#x4EBA;&#x90FD;&#x7ED9;&#x51FA;&#x4E86;&#x89E3;&#x91CA;&#x3002;&#x6211;&#x4EEC;&#x4E00;&#x822C;&#x5199;&#x7684;&#x7A0B;&#x5E8F; &#x7EDF;&#x79F0;&#x4E3A;&#x547D;&#x4EE4;&#x5F0F;&#x7A0B;&#x5E8F;&#xFF0C;&#x662F;&#x4EE5;&#x6D41;&#x7A0B;&#x4E3A;&#x6838;&#x5FC3;&#x7684;&#xFF0C;&#x6BCF;&#x4E00;&#x884C;&#x4EE3;&#x7801;&#x5B9E;&#x9645;&#x4E0A;&#x90FD;&#x662F;&#x673A;&#x5668;&#x5B9E;&#x9645;&#x4E0A;&#x8981;&#x6267;&#x884C;&#x7684;&#x6307;&#x4EE4;&#x3002;&#x800C;Rxjava&#x8FD9;&#x6837;&#x7684;&#x7F16;&#x7A0B;&#x98CE;&#x683C;&#xFF0C;&#x79F0;&#x4E3A;&#x51FD;&#x6570;&#x54CD;&#x5E94;&#x5F0F;&#x7F16;&#x7A0B;&#x3002;&#x51FD;&#x6570;&#x54CD;&#x5E94;&#x5F0F;&#x7F16;&#x7A0B;&#x662F;&#x4EE5;&#x6570;&#x636E;&#x6D41;&#x4E3A;&#x6838;&#x5FC3;&#xFF0C;&#x5904;&#x7406;&#x6570;&#x636E;&#x7684;&#x8F93;&#x5165;&#xFF0C;&#x5904;&#x7406;&#x4EE5;&#x53CA;&#x8F93;&#x51FA;&#x7684;&#x3002;&#x8FD9;&#x91CC;&#x7684;&#x54CD;&#x5E94;&#x5F0F;&#x7F16;&#x7A0B;&#x5373;&#x4E3A;Rxjava&#x7684;&#x6838;&#x5FC3;&#x8981;&#x70B9;&#xFF0C;Rxjava&#x901A;&#x8FC7;&#x6570;&#x636E;&#x7684;&#x6D41;&#x52A8;&#xFF0C;&#x4EE5;&#x53CA;&#x5404;&#x79CD;&#x53D8;&#x6362;&#xFF08;map&#x3001;flatmap&#x3001;lift&#xFF09;&#x4F7F;&#x5F97;&#x6570;&#x636E;&#x6839;&#x636E;&#x4E0D;&#x540C;&#x7684;&#x9700;&#x6C42;&#x800C;&#x663E;&#x793A;&#x4E0D;&#x540C;&#x7684;&#x7ED3;&#x679C;&#x3002;&#x5F53;&#x7136;&#x4E86;&#xFF0C;&#x5149;&#x8BF4;&#x7684;&#x8BDD;&#x53EF;&#x80FD;&#x6C38;&#x8FDC;&#x4E5F;&#x4F53;&#x4F1A;&#x4E0D;&#x5230;&#x8FD9;&#x79CD;&#x53D8;&#x6362;&#x5E26;&#x7ED9;&#x6211;&#x4EEC;&#x7684;&#x5FEB;&#x611F;&#x3002;&#x53EF;&#x4EE5;&#x53C2;&#x8003;&#x8FD9;&#x7BC7;&#x6587;&#x7AE0;&#xFF0C;&#x8FD9;&#x91CC;&#x9762;&#x8BE6;&#x7EC6;&#x8BB2;&#x89E3;&#x4E86;Rxjava&#x7684;&#x65B9;&#x4FBF;&#x6027;&#xFF0C;&#x8FD9;&#x91CC;&#x5C31;&#x4E0D;&#x505A;&#x8FC7;&#x591A;&#x7684;&#x8D58;&#x8FF0;&#x3002; 3. &#x6846;&#x67B6;&#x642D;&#x5EFA;&#x5206;&#x6790; mvp&#x7684;&#x67B6;&#x6784;&#x56FE; &#x6839;&#x636E;&#x67B6;&#x6784;&#x56FE;&#x5206;&#x6790;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x770B;&#x51FA;&#xFF0C;View&#x548C;Model&#x4E4B;&#x95F4;&#x7684;&#x6570;&#x636E;&#x4EA4;&#x4E92;&#x90FD;&#x901A;&#x8FC7;&#x4E86;&#x4E00;&#x4E2A;&#x4E2D;&#x95F4;&#x4EF6;Presenter&#xFF0C;&#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x4E2D;&#x95F4;&#x4EF6;Presenter&#x5C31;&#x9700;&#x8981;&#x5305;&#x542B;&#x8FD9;&#x4E9B;&#x4EA4;&#x4E92;&#x7684;&#x6240;&#x6709;&#x903B;&#x8F91;&#x64CD;&#x4F5C;&#x3002;&#x6211;&#x4EEC;&#x7684;View&#xFF08;&#x8FD9;&#x91CC;&#x5E94;&#x8BE5;&#x6307;&#x7684;&#x662F;Activity&#xFF09;&#x901A;&#x8FC7;Presenter&#x6765;&#x8FDB;&#x884C;&#x9875;&#x9762;&#x6570;&#x636E;&#x7684;&#x5404;&#x79CD;&#x64CD;&#x4F5C;&#x3002; 4. Rxjava&#x548C;Retrofit&#x6DF7;&#x5408;&#x4F7F;&#x7528;&#x7684;&#x4F18;&#x70B9; Retrofit&#x4F5C;&#x4E3A;&#x5F53;&#x524D;&#x6D41;&#x884C;&#x7684;&#x7F51;&#x7EDC;&#x8BF7;&#x6C42;&#x6846;&#x67B6;&#xFF0C;&#x5355;&#x72EC;&#x4F7F;&#x7528;&#x7684;&#x8BDD;&#x4E5F;&#x6CA1;&#x6709;&#x95EE;&#x9898;&#x3002;1234567891011apiService.getIp2(&quot;63.223.108.42&quot;).enqueue(new Callback&lt;IpModel&gt;() { @Override public void onResponse(Call&lt;IpModel&gt; call, Response&lt;IpModel&gt; response) { } @Override public void onFailure(Call&lt;IpModel&gt; call, Throwable t) { }}); &#x4E0A;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x53EA;&#x4F7F;&#x7528;&#x4E86;Retrofit&#x8FDB;&#x884C;&#x7F51;&#x7EDC;&#x8BF7;&#x6C42;&#xFF0C;&#x6211;&#x4EEC;&#x53EA;&#x9700;&#x8981;&#x8FDB;&#x884C;&#x7B80;&#x5355;&#x7684;&#x5C01;&#x88C5;&#x5C31;&#x53EF;&#x4EE5;&#x5F88;&#x597D;&#x7684;&#x4F7F;&#x7528;&#x4E86;&#x3002;&#x90A3;&#x4E48;&#x95EE;&#x9898;&#x6765;&#x4E86;~Rxjava&#x548C;Retrofit&#x6DF7;&#x5408;&#x4F7F;&#x7528;&#x7684;&#x4F18;&#x70B9;&#x5230;&#x5E95;&#x662F;&#x4EC0;&#x4E48;&#x5462;&#xFF1F;Rxjava&#x4F5C;&#x4E3A;&#x54CD;&#x5E94;&#x5F0F;&#x7F16;&#x7A0B;&#xFF0C;&#x5176;&#x6700;&#x5927;&#x7684;&#x5999;&#x5904;&#x5728;&#x4E8E;&#x6570;&#x636E;&#x7684;&#x53D8;&#x6362;&#x4EE5;&#x53CA;&#x7EBF;&#x7A0B;&#x7684;&#x5207;&#x6362;&#x3002;&#x5C31;&#x7528;&#x6211;&#x4E0A;&#x9762;&#x4F8B;&#x5B50;&#x6765;&#x8BF4;&#xFF0C;&#x5982;&#x679C;&#x6211;&#x9700;&#x8981;&#x7684;&#x662F;&#x4E00;&#x4E2A; List&lt; IpModel&gt;&#xFF0C;&#x800C;&#x4E14;&#x6211;&#x4EEC;&#x8FD8;&#x9700;&#x8981;&#x5BF9;IpModel&#x8FDB;&#x884C;&#x7B5B;&#x9009;&#xFF0C;&#x90A3;&#x4E48;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x901A;&#x8FC7;Map&#x53D8;&#x6362;&#x8FDB;&#x884C;&#x5BF9;IpModel&#x7684;&#x7B5B;&#x9009;&#xFF0C;&#x7136;&#x540E;&#x628A;&#x7ED3;&#x679C;&#x53D1;&#x52A8;&#x5230;&#x4E0B;&#x4E00;&#x6B65;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x8FD9;&#x6837;&#x5927;&#x5927;&#x63D0;&#x9AD8;&#x6211;&#x4EEC;&#x7684;&#x4EE3;&#x7801;&#x53EF;&#x8BFB;&#x6027;&#x3002;123456789101112131415Observable.just(student1, student2, student2) //&#x4F7F;&#x7528;map&#x8FDB;&#x884C;&#x8F6C;&#x6362;&#xFF0C;&#x53C2;&#x6570;1&#xFF1A;&#x8F6C;&#x6362;&#x524D;&#x7684;&#x7C7B;&#x578B;&#xFF0C;&#x53C2;&#x6570;2&#xFF1A;&#x8F6C;&#x6362;&#x540E;&#x7684;&#x7C7B;&#x578B; .map(new Func1&lt;Student, String&gt;() { @Override public String call(Student i) { String name = i.getName();//&#x83B7;&#x53D6;Student&#x5BF9;&#x8C61;&#x4E2D;&#x7684;name return name;//&#x8FD4;&#x56DE;name } }) .subscribe(new Action1&lt;String&gt;() { @Override public void call(String s) { nameList.add(s); } }); 5. &#x6846;&#x67B6;&#x7684;&#x76EE;&#x5F55;&#x7ED3;&#x6784; &#x76EE;&#x5F55;&#x7ED3;&#x6784;&#x5982;&#x4E0B;&#xFF1A;&#x5305;&#x7684;&#x547D;&#x540D;&#x6211;&#x662F;&#x6839;&#x636E;&#x7EC4;&#x4EF6;&#x540D;&#x79F0;&#x6765;&#x547D;&#x540D;&#x7684;&#x3002; 6.&#x9879;&#x76EE;&#x5730;&#x5740; &#x6211;&#x5C06;&#x9879;&#x76EE;&#x653E;&#x5230;&#x4E86;Github&#x4E0A;&#x9762;&#xFF0C;&#x6C42;&#x8F7B;&#x55B7;&#x3002;&#x70B9;&#x51FB;&#x8FD9;&#x91CC;&#x8FDB;&#x5165;","tags":[]},{"title":"再识数据结构绕不过去的坎——值传递、指针传递、引用传递","date":"2017-02-15T12:52:29.041Z","path":"2017/02/15/params/","text":"1. &#x6982;&#x5FF5; &#x503C;&#x4F20;&#x9012;&#xFF1A;&#x6307;&#x5728;&#x8C03;&#x7528;&#x51FD;&#x6570;&#x65F6;&#x5C06;&#x5B9E;&#x9645;&#x53C2;&#x6570;&#x590D;&#x5236;&#x4E00;&#x4EFD;&#x4F20;&#x9012;&#x5230;&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x8FD9;&#x6837;&#x5728;&#x51FD;&#x6570;&#x4E2D;&#x5982;&#x679C;&#x5BF9;&#x53C2;&#x6570;&#x8FDB;&#x884C;&#x4FEE;&#x6539;&#xFF0C;&#x5C06;&#x4E0D;&#x4F1A;&#x5F71;&#x54CD;&#x5230;&#x5B9E;&#x9645;&#x53C2;&#x6570;&#x3002; &#x6307;&#x9488;&#x4F20;&#x9012;&#xFF1A;&#x53EF;&#x4EE5;&#x6539;&#x53D8;&#x6307;&#x9488;&#x6307;&#x5411;&#x5185;&#x5BB9;&#x7684;&#x503C;&#xFF0C;&#x4F46;&#x662F;&#x4E0D;&#x80FD;&#x6539;&#x53D8;&#x6307;&#x9488;&#x672C;&#x8EAB;&#xFF0C;&#x65E0;&#x9700;&#x590D;&#x5236;&#x5F00;&#x9500;&#x3002;&#x5982;&#x679C;&#x9700;&#x8981;&#x6539;&#x53D8;&#x6307;&#x9488;&#x672C;&#x8EAB;&#xFF0C;&#x53EF;&#x4EE5;&#x4F7F;&#x7528;&#x4E8C;&#x91CD;&#x6307;&#x9488;&#x6216;&#x8005;&#x6307;&#x9488;&#x5F15;&#x7528;&#x3002; &#x5F15;&#x7528;&#x4F20;&#x9012;&#xFF1A;&#x76F4;&#x63A5;&#x5BF9;&#x5F53;&#x524D;&#x5BF9;&#x8C61;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x65E0;&#x9700;&#x590D;&#x5236;&#x5F00;&#x9500;&#x3002; 2. &#x7406;&#x89E3; &#x503C;&#x4F20;&#x9012;&#xFF1A;&#x503C;&#x4F20;&#x9012;&#x662F;&#x6307;&#x4EE5;&#x5C06;&#x5B9E;&#x53C2;&#x7684;&#x503C;&#x4F20;&#x9012;&#x5230;&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x5728;&#x51FD;&#x6570;&#x4E2D;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x4F46;&#x662F;&#x6B64;&#x79CD;&#x4F20;&#x9012;&#x4E0D;&#x4F1A;&#x4FEE;&#x6539;&#x5B9E;&#x53C2;&#x7684;&#x503C;&#x3002;&#x51FD;&#x6570;&#x4F53;&#x5185;&#x7684;&#x53C2;&#x6570;&#x53EA;&#x662F;&#x5BF9;&#x6211;&#x4EEC;&#x4F20;&#x5165;&#x53C2;&#x6570;&#x7684;&#x4E00;&#x4E2A;&#x62F7;&#x8D1D;&#xFF0C;&#x5E76;&#x4E0D;&#x662F;&#x6211;&#x4EEC;&#x4F20;&#x5165;&#x7684;&#x53C2;&#x6570;&#x3002;123456789void fun1(int n) { printf(&quot;&#x64CD;&#x4F5C;&#x65F6;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x \\n&quot;, &amp;n); n = n + 10;}int n = 10;printf(&quot;&#x64CD;&#x4F5C;&#x524D;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x\\n&quot;, &amp;n);fun1(n);printf(&quot;&#x64CD;&#x4F5C;&#x540E;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x&#xFF0C;n&#x7684;&#x503C;&#x4E3A;&#xFF1A;%d \\n&quot;, &amp;n, n); &#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x4E3A;&#xFF1A; &#x6307;&#x9488;&#x4F20;&#x9012;&#xFF1A;&#x6307;&#x9488;&#x4F20;&#x9012;&#x662F;&#x6307;&#x51FD;&#x6570;&#x7684;&#x5F62;&#x53C2;&#x662F;&#x6307;&#x9488;&#x7684;&#x5F62;&#x5F0F;&#xFF0C;&#x901A;&#x8FC7;&#x6307;&#x9488;&#x4F20;&#x9012;&#xFF0C;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x4FEE;&#x6539;&#x6307;&#x9488;&#x6307;&#x5411;&#x7684;&#x5730;&#x5740;&#x7684;&#x503C;&#x3002;123456789void fun2(int * n) { printf(&quot;&#x64CD;&#x4F5C;&#x65F6;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x \\n&quot;, n); *n = *n + 10;}int n = 10;printf(&quot;&#x64CD;&#x4F5C;&#x524D;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x\\n&quot;, &amp;n);fun2(&amp;n);//&#x53D6;&#x5730;&#x5740;printf(&quot;&#x64CD;&#x4F5C;&#x540E;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x&#xFF0C;n&#x7684;&#x503C;&#x4E3A;&#xFF1A;%d \\n&quot;, &amp;n, n); &#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x4E3A;&#xFF1A; &#x5F15;&#x7528;&#x4F20;&#x9012;&#xFF1A;&#x76F4;&#x63A5;&#x5BF9;&#x5F53;&#x524D;&#x5BF9;&#x8C61;&#x8FDB;&#x884C;&#x64CD;&#x4F5C;&#xFF0C;&#x65E0;&#x9700;&#x590D;&#x5236;&#x5F00;&#x9500;&#x3002;123456789void fun3(int &amp; n) { printf(&quot;&#x64CD;&#x4F5C;&#x65F6;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x \\n&quot;, &amp;n); n = n + 10;}int n = 10;printf(&quot;&#x64CD;&#x4F5C;&#x524D;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x\\n&quot;, &amp;n);fun3(n);printf(&quot;&#x64CD;&#x4F5C;&#x540E;&#x5730;&#x5740;&#x4E3A;&#xFF1A;%x&#xFF0C;n&#x7684;&#x503C;&#x4E3A;&#xFF1A;%d \\n&quot;, &amp;n, n); &#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x4E3A;&#xFF1A; 3. &#x603B;&#x7ED3; &#x4EE5;&#x524D;&#x5BF9;C/C++&#x4E86;&#x89E3;&#x5E76;&#x4E0D;&#x662F;&#x5F88;&#x6DF1;&#x523B;&#xFF0C;&#x5F53;&#x7136;&#x4E86;&#x4E5F;&#x548C;&#x6700;&#x8FD1;&#x4E00;&#x4E24;&#x5E74;&#x6CA1;&#x6709;&#x63A5;&#x89E6;C/C++&#x6709;&#x5173;&#xFF0C;&#x8BB8;&#x591A;&#x6982;&#x5FF5;&#x6027;&#x7684;&#x4E1C;&#x897F;&#x53C8;&#x8981;&#x91CD;&#x65B0;&#x62FE;&#x8D77;&#x6765;&#xFF0C;&#x52A0;&#x6DF1;&#x5370;&#x8C61;&#x3002;","tags":[]},{"title":"再识数据结构（1）线性表","date":"2017-02-14T10:00:10.083Z","path":"2017/02/14/list/","text":"1. &#x7EBF;&#x6027;&#x8868;&#x7684;&#x5B9A;&#x4E49; &#x7EBF;&#x6027;&#x8868;&#xFF08;linear list&#xFF09;&#x662F;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x7684;&#x4E00;&#x79CD;&#xFF0C;&#x4E00;&#x4E2A;&#x7EBF;&#x6027;&#x8868;&#x662F;n&#x4E2A;&#x5177;&#x6709;&#x76F8;&#x540C;&#x7279;&#x6027;&#x7684;&#x6570;&#x636E;&#x5143;&#x7D20;&#x7684;&#x6709;&#x9650;&#x5E8F;&#x5217;&#x3002;&#x6570;&#x636E;&#x5143;&#x7D20;&#x662F;&#x4E00;&#x4E2A;&#x62BD;&#x8C61;&#x7684;&#x7B26;&#x53F7;&#xFF0C;&#x5176;&#x5177;&#x4F53;&#x542B;&#x4E49;&#x5728;&#x4E0D;&#x540C;&#x7684;&#x60C5;&#x51B5;&#x4E0B;&#x4E00;&#x822C;&#x4E0D;&#x540C;&#x3002; &#x5728;&#x7A0D;&#x590D;&#x6742;&#x7684;&#x7EBF;&#x6027;&#x8868;&#x4E2D;&#xFF0C;&#x4E00;&#x4E2A;&#x6570;&#x636E;&#x5143;&#x7D20;&#x53EF;&#x7531;&#x591A;&#x4E2A;&#x6570;&#x636E;&#x9879;&#xFF08;item&#xFF09;&#x7EC4;&#x6210;&#xFF0C;&#x6B64;&#x79CD;&#x60C5;&#x51B5;&#x4E0B;&#x5E38;&#x628A;&#x6570;&#x636E;&#x5143;&#x7D20;&#x6210;&#x4E3A;&#x8BB0;&#x5F55;&#xFF08;record&#xFF09;&#xFF0C;&#x542B;&#x6709;&#x5927;&#x91CF;&#x8BB0;&#x5F55;&#x7684;&#x7EBF;&#x6027;&#x8868;&#x53C8;&#x79F0;&#x6587;&#x4EF6;&#xFF08;file&#xFF09;&#x3002; &#x7EBF;&#x6027;&#x8868;&#x4E2D;&#x7684;&#x4E2A;&#x6570;$n$&#x5B9A;&#x4E49;&#x4E3A;&#x7EBF;&#x6027;&#x8868;&#x7684;&#x957F;&#x5EA6;&#xFF0C;$n=0$&#x65F6;&#x79F0;&#x4E3A;&#x7A7A;&#x8868;&#x3002;&#x5728;&#x975E;&#x7A7A;&#x8868;&#x4E2D;&#x6BCF;&#x4E2A;&#x6570;&#x636E;&#x5143;&#x7D20;&#x90FD;&#x6709;&#x4E00;&#x4E2A;&#x786E;&#x5B9A;&#x7684;&#x4F4D;&#x7F6E;&#xFF0C;&#x5982;&#x7528;$a_i$&#x8868;&#x793A;&#x6570;&#x636E;&#x5143;&#x7D20;&#xFF0C;&#x5219;i&#x79F0;&#x4E3A;&#x6570;&#x636E;&#x5143;&#x7D20;$a_i$&#x5728;&#x7EBF;&#x6027;&#x8868;&#x4E2D;&#x7684;&#x4F4D;&#x5E8F;&#x3002; &#x7EBF;&#x6027;&#x8868;&#x7684;&#x76F8;&#x90BB;&#x5143;&#x7D20;&#x4E4B;&#x95F4;&#x5B58;&#x5728;&#x7740;&#x5E8F;&#x5076;&#x5173;&#x7CFB;&#x3002;&#x5982;&#x7528;&#xFF08;a1&#xFF0C;&#x2026;&#xFF0C;ai-1&#xFF0C;ai&#xFF0C;ai+1&#xFF0C;&#x2026;&#xFF0C;an&#xFF09;&#x8868;&#x793A;&#x4E00;&#x4E2A;&#x987A;&#x5E8F;&#x8868;&#xFF0C;&#x5219;&#x8868;&#x4E2D;ai-1&#x9886;&#x5148;&#x4E8E;ai&#xFF0C;ai&#x9886;&#x5148;&#x4E8E;ai+1&#xFF0C;&#x79F0;ai-1&#x662F;ai&#x7684;&#x76F4;&#x63A5;&#x524D;&#x9A71;&#x5143;&#x7D20;&#xFF0C;ai+1&#x662F;ai&#x7684;&#x76F4;&#x63A5;&#x540E;&#x7EE7;&#x5143;&#x7D20;&#x3002;&#x5F53;i=1,2&#xFF0C;&#x2026;&#xFF0C;n-1&#x65F6;&#xFF0C;ai&#x6709;&#x4E14;&#x4EC5;&#x6709;&#x4E00;&#x4E2A;&#x76F4;&#x63A5;&#x540E;&#x7EE7;&#xFF0C;&#x5F53;i=2&#xFF0C;3&#xFF0C;&#x2026;&#xFF0C;n&#x65F6;&#xFF0C;ai&#x6709;&#x4E14;&#x4EC5;&#x6709;&#x4E00;&#x4E2A;&#x76F4;&#x63A5;&#x524D;&#x9A71;&#x3002; 2. &#x7EBF;&#x6027;&#x8868;ADT123456789&#x57FA;&#x672C;&#x64CD;&#x4F5C;InitList(&amp;L)//&#x6784;&#x9020;&#x4E00;&#x4E2A;&#x7A7A;&#x7684;&#x7EBF;&#x6027;&#x8868;LDestoryList(&amp;L)//&#x9500;&#x6BC1;&#x7EBF;&#x6027;&#x8868;LClearList(&amp;L)//&#x5C06;L&#x7F6E;&#x4E3A;&#x7A7A;&#x8868;ListEmpty(L)//&#x662F;&#x5426;&#x4E3A;&#x7A7A;&#x8868;ListLength(L)//L&#x4E2D;&#x6570;&#x636E;&#x5143;&#x7D20;&#x7684;&#x4E2A;&#x6570;GetElem(L, i, &amp;e)//&#x7528;e&#x8FD4;&#x56DE;L&#x4E2D;&#x7B2C;i&#x4E2A;&#x5143;&#x7D20;&#x7684;&#x503C;ListInsert(&amp;L, i, e)//&#x5728;L&#x4E2D;&#x7684;&#x7B2C;i&#x4E2A;&#x4F4D;&#x7F6E;&#x63D2;&#x5165;&#x65B0;&#x7684;&#x5143;&#x7D20;eListDelete(&amp;L, i, e)//&#x5220;&#x9664;L&#x4E2D;&#x7684;&#x7B2C;i&#x4E2A;&#x4F4D;&#x7F6E;&#xFF0C;&#x5E76;&#x628A;&#x503C;&#x8D4B;&#x7ED9;e 3. &#x4EE3;&#x7801;&#x5B9E;&#x73B0;&#xFF08;&#x90E8;&#x5206;&#x5B9E;&#x73B0;&#xFF09; InitList(&amp;L) 1234567891011void initListStruct(ListStruct * ls){ ls-&gt;elem = (int *)malloc(DEFAULT_SIZE * sizeof(ls-&gt;elem)); if (ls-&gt;elem == NULL) { exit(OVERFLOW); } ls-&gt;length = 0;} ListInsert(&amp;L, i, e) 1234567891011121314151617181920212223242526void ListInsert(ListStruct *ls, int position, int value){ if (position &lt;= 0 || position &gt; ls-&gt;length) { printf(&quot;&#x8BF7;&#x8F93;&#x5165;&#x6B63;&#x786E;&#x7684;&#x63D2;&#x5165;&#x4F4D;&#x7F6E;&quot;); } else { if (ls-&gt;length % DEFAULT_SIZE == 0)//&#x5982;&#x679C;&#x5F53;&#x524D;list&#x7684;&#x957F;&#x5EA6;&#x548C;&#x9ED8;&#x8BA4;&#x7684;&#x957F;&#x5EA6;&#x76F8;&#x7B49;&#xFF0C;&#x9700;&#x8981;&#x91CD;&#x65B0;&#x5206;&#x914D;&#x5185;&#x5B58; { //&#x91CD;&#x65B0;&#x5206;&#x914D;&#x5185;&#x5B58;&#xFF0C;&#x589E;&#x91CF;&#x4E3A;DEFAULT_SIZE realloc(ls-&gt;elem, DEFAULT_SIZE * (ls-&gt;length / DEFAULT_SIZE + 1) * sizeof(ls-&gt;elem)); } for (int *i = &amp;(ls-&gt;elem[ls-&gt;length - 1]); i &gt;= &amp;(ls-&gt;elem[position - 1]); i--) { *(i + 1) = *i;//&#x5411;&#x540E;&#x79FB; } ls-&gt;elem[position - 1] = value;//&#x63D2;&#x5165;&#x4F4D;&#x7F6E;&#x91CD;&#x65B0;&#x8D4B;&#x503C; ls-&gt;length++;//&#x957F;&#x5EA6;&#x52A0;1 }} ListDelete(&amp;L, i, e) 1234567891011121314151617181920void DeleteElem(ListStruct * ls, int position, int * value){ if (position &lt;= 0 || position &gt; ls-&gt;length) { printf(&quot;&#x8BF7;&#x8F93;&#x5165;&#x6B63;&#x786E;&#x7684;&#x63D2;&#x5165;&#x4F4D;&#x7F6E;&quot;); } else { *value = ls-&gt;elem[position - 1];//&#x5220;&#x9664;&#x7684;&#x5143;&#x7D20;&#x7684;&#x503C; int *p = &amp;ls-&gt;elem[position - 1]; int *q = &amp;ls-&gt;elem[ls-&gt;length - 1]; while (p &lt; q) { *p = *p + 1;//&#x5411;&#x524D;&#x79FB;&#x52A8; p++; } ls-&gt;length--;//&#x957F;&#x5EA6;-1 }} DestoryList(&amp;L) 1234567void DestoryList(ListStruct * ls){ free(ls-&gt;elem);//&#x91CA;&#x653E;&#x7EBF;&#x6027;&#x8868;&#xFF0C;&#x8FD9;&#x91CC;&#x4E0D;&#x80FD;&#x53BB;&#x91CA;&#x653E;ls&#xFF0C;&#x8FD9;&#x4E2A;&#x5185;&#x5B58;&#x5E76;&#x4E0D;&#x662F;&#x6211;&#x4EEC;&#x7533;&#x8BF7;&#x7684; ls-&gt;elem = NULL; ls-&gt;length = 0; printf(&quot;&#x5185;&#x5B58;&#x88AB;&#x91CA;&#x653E;&quot;);} 4. &#x603B;&#x7ED3; &#x5728;&#x8FD9;&#x91CC;&#x6211;&#x4F7F;&#x7528;&#x4E86;C&#x8BED;&#x8A00;&#x6765;&#x5B9E;&#x73B0;&#x90E8;&#x5206;&#x64CD;&#x4F5C;&#xFF0C;&#x603B;&#x7684;&#x6765;&#x8BF4;&#x8FD8;&#x662F;&#x56E0;&#x4E3A;&#x4E4B;&#x524D;&#x5BF9;C&#x8BED;&#x8A00;&#x7684;&#x6050;&#x60E7;&#xFF08;&#x6307;&#x9488;&#x6050;&#x60E7;&#x611F;&#xFF09;&#x3002;&#x4F46;&#x662F;&#x771F;&#x6B63;&#x5DE5;&#x4F5C;&#x4E86;&#x53D1;&#x73B0;&#xFF0C;&#x7ED5;&#x6765;&#x7ED5;&#x53BB;&#x8FD8;&#x662F;&#x7ED5;&#x4E0D;&#x5F00;&#x6307;&#x9488;&#x7684;&#x5404;&#x79CD;&#x64CD;&#x4F5C;&#x3002;&#x4E8E;&#x662F;&#xFF0C;&#x6211;&#x6253;&#x7B97;&#x91CD;&#x65B0;&#x5B66;&#x4E60;&#x6570;&#x636E;&#x7ED3;&#x6784;&#x6765;&#x5DE9;&#x56FA;&#x81EA;&#x5DF1;&#x7684;&#x77E5;&#x8BC6;&#x3002;","tags":[]},{"title":"Android Volley 支持Https（1）","date":"2016-12-23T03:00:12.654Z","path":"2016/12/23/Android-Volley-Https/","text":"&#x76F8;&#x4FE1;&#x5927;&#x90E8;&#x5206;&#x5F00;&#x53D1;&#x8005;&#x90FD;&#x4F1A;&#x9047;&#x5230;Volley&#x5982;&#x4F55;&#x652F;&#x6301;&#x81EA;&#x5B9A;&#x4E49;&#x8BC1;&#x4E66;&#x7684;&#x95EE;&#x9898;&#xFF0C;&#x6700;&#x7B80;&#x5355;&#x7684;&#x529E;&#x6CD5;&#x5C31;&#x662F;&#x652F;&#x6301;&#x6240;&#x6709;&#x7684;SSL&#x8BC1;&#x4E66;&#x3002;&#x4F46;&#x662F;&#x5982;&#x679C;&#x652F;&#x6301;&#x6240;&#x6709;&#x7684;SSL&#x8BC1;&#x4E66;&#x7684;&#x8BDD;&#xFF0C;&#x5C31;&#x5931;&#x53BB;&#x4E86;Https&#x7684;&#x5B89;&#x5168;&#x6027;&#x4E86;&#xFF08;App&#x5728;Google Play&#x4E0A;&#x67B6;&#x4F1A;&#x4E0D;&#x901A;&#x8FC7;&#xFF09;&#x3002; 1.Volley&#x9ED8;&#x8BA4;&#x652F;&#x6301;&#x4E0D;&#x652F;&#x6301;Https&#xFF1F; &#x7B54;&#x6848;&#x662F;&#x652F;&#x6301;&#x7684;&#xFF01;&#x7F51;&#x4E0A;&#x5927;&#x90E8;&#x5206;&#x90FD;&#x8BF4;Volley&#x4E0D;&#x652F;&#x6301;Https&#xFF0C;&#x5176;&#x5B9E;Volley&#x5728;&#x540E;&#x9762;&#x7684;&#x7248;&#x672C;&#x5DF2;&#x7ECF;&#x53EF;&#x4EE5;&#x652F;&#x6301;Https&#x8BF7;&#x6C42;&#x4E86;&#x3002;&#x5177;&#x4F53;&#x554A;&#xFF0C;&#x8FD8;&#x662F;&#x627E;&#x5EA6;&#x5A18;&#x770B;&#x5427;&#xFF0C;&#x8FD9;&#x91CC;&#x4E3B;&#x8981;&#x8BB2;&#x5982;&#x4F55;&#x5B9E;&#x73B0;&#x3002; 2.&#x51C6;&#x5907;&#x5DE5;&#x4F5C; &#x751F;&#x6210;BC&#x8BC1;&#x4E66; Android &#x9700;&#x8981;BC&#x8BC1;&#x4E66;&#xFF0C;&#x800C;Java&#x7684;keytool&#x4E0D;&#x63D0;&#x4F9B;BKS&#x683C;&#x5F0F;&#xFF0C;&#x56E0;&#x6B64;&#x9700;&#x8981;&#x4F7F;&#x7528;&#x5176;&#x4ED6;&#x5DE5;&#x5177;&#x751F;&#x6210;&#x3002; &#x8FD9;&#x91CC;&#x4F7F;&#x7528;Java&#x6269;&#x5C55;&#x7B97;&#x6CD5;&#x548C;&#x8F85;&#x52A9;&#x5DE5;&#x5177;&#xFF08;bcprov-ext-jdk15on-146.jar &#xFF09;&#x6765;&#x751F;&#x6210;BKS&#x6587;&#x4EF6;&#x3002;**&#x5728;&#x8FD9;&#x91CC;&#x8981;&#x8BF4;&#x4E0B;&#xFF0C;&#x6211;&#x662F;&#x7528;&#x4E86;&#x66F4;&#x9AD8;&#x7248;&#x672C;&#x7684;jar&#x6587;&#x4EF6;&#x6765;&#x751F;&#x6210;BKS&#x6587;&#x4EF6;&#xFF0C;&#x4F46;&#x662F;&#x603B;&#x662F;&#x4F1A;&#x51FA;&#x73B0;&#x4E0B;&#x9762;&#x7684;&#x9519;&#x8BEF;&#xFF1A; 1java.lang.ClassNotFoundException: org.bouncycastle.jce.provider.BouncyCastleProvid &#x5982;&#x679C;&#x627E;&#x4E0D;&#x5230;bcprov-ext-jdk15on-146.jar&#xFF0C;&#x53EF;&#x4EE5;&#x4E0B;&#x8F7D;&#xFF0C;&#x63D0;&#x53D6;&#x7801;&#x4E3A;8fvq&#x3002; &#x4E0B;&#x8F7D;&#x5B8C;&#x6210;&#x540E;&#xFF0C;&#x4E0D;&#x7528;&#x8FDB;&#x884C;&#x4EFB;&#x4F55;&#x914D;&#x7F6E;&#x3002;&#x5C06;&#x4E0B;&#x8F7D;&#x7684;jar&#x6587;&#x4EF6;&#x653E;&#x5230;&#x81EA;&#x5DF1;&#x9700;&#x8981;&#x751F;&#x6210;BKS&#x7684;&#x6587;&#x4EF6;&#x5939;&#x4E2D;&#xFF0C;&#x4F7F;&#x7528;&#x547D;&#x4EE4;&#x884C;&#x5DE5;&#x5177;&#x8FDB;&#x5165;&#x6587;&#x4EF6;&#x5939;&#x4E2D;&#xFF0C;&#x4F7F;&#x7528;&#x547D;&#x4EE4;&#xFF1A; 1keytool -importcert -keystore &#x751F;&#x6210;&#x7684;bks&#x6587;&#x4EF6;&#x540D;.bks -file &#x8BC1;&#x4E66;&#x6587;&#x4EF6;.crt -storetype BKS -provider org.bouncycastle.jce.provider.BouncyCastleProvider -providerpath &quot;bcprov-ext-jdk16-146.jar&quot; &#x4E4B;&#x540E;&#x4F1A;&#x51FA;&#x73B0;&#xFF1A;&#xFF0C;&#x8F93;&#x5165;&#x4E24;&#x6B21;&#x5BC6;&#x94A5;&#x53E3;&#x4EE4;&#x5373;&#x53EF;&#x3002; &#x7136;&#x540E;&#x4F1A;&#x63D0;&#x793A;&#x662F;&#x5426;&#x4FE1;&#x4EFB;&#x8F93;&#x5165;y&#x5373;&#x53EF;&#x751F;&#x6210;BKS&#x6587;&#x4EF6;&#x3002; OK&#xFF0C;&#x73B0;&#x5728;&#x5DF2;&#x7ECF;&#x5B8C;&#x6210;&#x4E86;&#x51C6;&#x5907;&#x5DE5;&#x4F5C;&#xFF0C;&#x4E0B;&#x9762;&#x5C31;&#x662F;&#x4FEE;&#x6539;Volley&#x7684;&#x6E90;&#x7801;&#x8FDB;&#x884C;&#x5B9E;&#x73B0;&#x3002; 1&#x6B32;&#x77E5;&#x8BE6;&#x60C5;&#xFF0C;&#x4E14;&#x542C;&#x4E0B;&#x56DE;&#x5206;&#x89E3;&#x3002;","tags":[]}]